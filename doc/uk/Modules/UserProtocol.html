<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="UTF-8" />
<title>Модулі/Протокол користувача - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../../en/files/doc.css" rel="stylesheet" /></head>
<body><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="uk">Модулі/Протокол користувача</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="uk"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Modules%2FUserProtocol&amp;action=page&amp;filter=&amp;language=uk" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Modules/UserProtocol" title="Modules/UserProtocol">Modules/UserProtocol</a> and the translation is 100% complete.</div><hr /><div class="mw-pt-languages noprint" dir="ltr" lang="en"><div class="mw-pt-languages-label">Other languages:</div><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="http://oscada.org/wiki/Modules/UserProtocol" title="Modules/UserProtocol (100% translated)">English</a>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--complete" href="http://oscada.org/wiki/Modules/UserProtocol/ru" title="Модули/Протокол пользователя (100% translated)">российский</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">українська</span></div></div>
<table class="wikitable">

<tr>
<th> Модуль </th>
<th> Ім'я </th>
<th> Версія </th>
<th> Ліцензія </th>
<th> Джерело </th>
<th> Мови </th>
<th> Платформи </th>
<th> Тип </th>
<th> Автор </th>
<th> Опис
</th></tr>

<tr>
<td> <a href="../Modules/UserProtocol.html" title="Special:MyLanguage/Modules/UserProtocol">UserProtocol</a> </td>
<td> Користувацький протокол
</td>
<td> 1.1 </td>
<td> GPL2 </td>
<td> prot_UserProtocol.so </td>
<td> en,uk,ru,de </td>
<td> x86,x86_64,ARM
</td>
<td> Протокол </td>
<td> Роман Савоченко </td>
<td> Забезпечує створення власних протоколів користувача на внутрішній мові OpenSCADA.
</td></tr></table>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.D0.92.D1.85.D1.96.D0.B4.D0.BD.D0.B0_.D1.87.D0.B0.D1.81.D1.82.D0.B8.D0.BD.D0.B0_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.83"><span class="tocnumber">1</span> <span class="toctext">Вхідна частина протоколу</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#.D0.92.D0.B8.D1.85.D1.96.D0.B4.D0.BD.D0.B0_.D1.87.D0.B0.D1.81.D1.82.D0.B8.D0.BD.D0.B0_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.83"><span class="tocnumber">2</span> <span class="toctext">Вихідна частина протоколу</span></a></li>
</ul>
</div>

<p>Модуль призначено для надання користувачу можливості створення реалізацій різних протоколів власними силами на внутрішній мові OpenSCADA, зазвичай це <a href="../Modules/JavaLikeCalc.html" title="Special:MyLanguage/Modules/JavaLikeCalc">JavaLikeCalc</a>, не залучаючи при цьому низькорівневого програмування.
</p><p>Основна мета модуля — спростити завдання підключення до OpenSCADA пристроїв джерел даних, які мають незначне розповсюдження та/або надають доступ до власних даних за специфічним протоколом, зазвичай достатньо простому для реалізації на внутрішній мові OpenSCADA. Для реалізації цього надається механізм формування протоколу вихідного запиту.
</p><p>Крім механізму протоколу вихідного запиту надається механізм протоколу вхідного запиту, який дозволяє OpenSCADA обслуговувати запити на отримання даних за специфічними протоколами, які достатньо просто можуть бути реалізовані на внутрішній мові OpenSCADA.
</p><p>Модуль надає можливість створення реалізацій різних протоколів у об'єкті "Користувацький протокол" (рис.1), а також використовувати для цього <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Documents/Program_manual#DAQTmpl" title="Special:MyLanguage/Documents/Program manual">стандартні шаблони DAQ</a>. Використання шаблонів DAQ дозволяє створювати бібліотеки комплексних протоколів та виклик їх у цьому модулі багаторазово, як їх реалізації, а також надає контекст даних виконання вхідного шаблону із їх зв'язуванням з даними підсистеми "Збір Даних".
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:747px;"><a class="image" href="http://oscada.org/wiki/File:UserProtocol_up_main_uk.png"><img class="thumbimage" height="579" src="../files/UserProtocol_up_main_uk.png" width="745" /></a>  <div class="thumbcaption">Рис.1. Основна вкладка об'єкту "Протокол користувача".</div></div></div></div>
<p>Головна вкладка містить основні налаштування користувацького протоколу:
</p>
<ul><li> Розділ "Стан" — містить властивості, які характеризують стан протоколу: статус, "Ввімкнено", ім'я БД (яка містить конфігурацію) та дату останньої модифікації.</li>
<li> Ідентифікатор, ім'я та опис протоколу.</li>
<li> Стан "Ввімкнено", у який переводити протокол при завантажені.</li>
<li> <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Documents/Program_manual#DAQTmpl" title="Special:MyLanguage/Documents/Program manual">DAQ шаблон</a>, пов'язаний з протоколом. Обрання шаблону тут вимикає режим роботи за прямими процедурами та доступ до наступних опцій. Режим DAQ-шаблону може працювати у вхідному, вихідному або обох режимах запиту, залежно від наявності необхідних атрибутів.</li>
<li> Ознака повного перекладу тексту процедур та мови вхідної та вихідної процедур. Обрання мови для вхідної та/або вихідної процедури вмикає відповідну частину протоколу та відкриває доступ до відповідних вкладок конфігурації.</li></ul>
<h2><span class="mw-headline" id=".D0.92.D1.85.D1.96.D0.B4.D0.BD.D0.B0_.D1.87.D0.B0.D1.81.D1.82.D0.B8.D0.BD.D0.B0_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.83"><span class="mw-headline-number">1</span> Вхідна частина протоколу</span></h2>
<p>Протокол вхідних запитів працює у кооперації з вхідним транспортом та окремий об'єкт "Користувацького протоколу" визначається у полі конфігурації протоколу транспорту, разом з іменем модуля UserProtocol. Надалі всі запити до транспорту будуть спрямовуватися до прямої процедури, або процедури шаблону, з обробки запиту протоколу (рис.2).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:842px;"><a class="image" href="http://oscada.org/wiki/File:UserProtocol_up_in_uk.png"><img class="thumbimage" height="687" src="../files/UserProtocol_up_in_uk.png" width="840" /></a>  <div class="thumbcaption">Рис.2. Вкладка конфігурації та контролю вхідних запитів.</div></div></div></div>
<p>Вкладка конфігурації та контролю вхідних запитів містить:
</p>
<ul><li> Час очікування запиту, у мілісекундах. Використовується для ввімкнення режиму пулінгу-опробування, встановленням у ненульове значення. У режимі пулінгу-опробування вхідний транспорт буде викликати протокол з порожнім запитом, у випадку відсутності запиту протягом визначеного часу.</li>
<li> Таблицю контексту даних процедури вхідного запиту. Переважно має сенс лише при роботі за шаблоном та де можна контролювати цей процес обробки, включно з можливістю втручання через зміну значень даних.</li>
<li> Текст прямої процедури протоколу, відсутній у режимі роботи за шаблоном.</li>
<li> Зв'язки на дані підсистеми "Збір Даних", які видимі та доступні для визначення у режимі роботи за шаблоном та у ввімкненому стані об'єкту протоколу.</li></ul>
<p>Для прямої процедури обробки предвизначено, та обов'язкові або опціональні до створення у шаблоні, наступні атрибути обміну з вхідним транспортом:
</p>
<ul><li> <i><b>Вхідний результат (rez)</b></i> &lt;Логічний&gt; — результат обробки (false — повний запит; true — неповний, утримувати підключення); у режимі DAQ-шаблону Ви маєте писати сюди прямо, не оператором "return";</li>
<li> <i><b>Вхідний запит (request)</b></i> &lt;Рядок&gt; — повне-акумульоване повідомлення запиту, яке протокол має очищати щодо оброблених даних;</li>
<li> <i><b>Вхідна відповідь (answer)</b></i> &lt;Рядок&gt; — повідомлення відповіді;</li>
<li> <i>Вхідний відправник (sender)</i> &lt;Рядок&gt; — відправник запиту;</li>
<li> <i>Транспорт (tr)</i> &lt;Об'єкт&gt; — об'єкт вхідного транспорту.</li></ul>
<p>Загальний сценарій обробки вхідних запитів:
</p>
<ul><li> Запит формується віддаленою станцією та через мережу потрапляє на <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Documents/Program_manual#Communication" title="Special:MyLanguage/Documents/Program manual">транспорт OpenSCADA</a>.</li>
<li> OpenSCADA транспорт передає запит цьому модулю, обраному у полі протоколу, та об'єкту користувацького протоколу, у вигляді значень змінної "request" — для послідовності запиту та "sender" — для адреси відправника запиту.</li>
<li> Запускається виконання процедури протоколу вхідного запиту, у процесі якої аналізується вміст змінної "request" та формується відповідь у змінній "answer". По завершені виконання процедури формується змінна "rez", яка вказує транспорту на факт отримання повного запиту та формування коректної відповіді (false) або потребу транспорту очікувати залишку даних (true) — утримувати підключення.</li>
<li> Якщо результат обробки дорівнює "false", та відповідь ненульова, то транспорт надсилає відповідь, а сама процедура протоколу має видалити оброблену частину запиту "request", оскільки тільки вона може визначити цілісність посилки та потенційну наявність за нею початку наступної.</li>
<li> Якщо результат процедури обробки дорівнює "true" то транспорт продовжує очікувати дані. При отримані наступної порції даних вони додаються до змінної "request" та виконання процедури повторюється.</li></ul>
<p>У якості прикладу розглянемо реалізацію обробки запитів за протоколом DCON для деяких запитів до джерела даних з адресою "10":
</p>
<pre style="white-space: pre-wrap;">
var enCRC = true;
//SYS.messDebug("/DCON/in","REQ: "+request);
//Перевірка запиту на повноту
if(request.length &lt; 4 || request[request.length-1]&nbsp;!= "\r") {
  if(request.length &gt; 10) request = "";
  return true;
}
//Перевірка запиту на цілісність (CRC) та адресу
if(enCRC) {
  CRC = 0;
  for(i = 0; i &lt; (request.length-3); i++) CRC += request.charCodeAt(i);
  if(CRC&nbsp;!= request.slice(request.length-3,request.length-1).toInt(16) || request.slice(1,3).toInt(16)&nbsp;!= 10) return false;
}
//Аналіз запиту та підготовка відповіді
if(request[0] == "#") answer = "&gt;+05.123+04.153+07.234-02.356+10.000-05.133+02.345+08.234";
else if(request[0] == "@") answer = "&gt;AB3C";
else answer = "?";
//Завершення відповіді
if(enCRC) {
  CRC = 0;
  for(i=0; i &lt; answer.length; i++) CRC += answer.charCodeAt(i);
  answer += (CRC&amp;0xFF).toString(16,2)+"\r";
}
//SYS.messDebug("/DCON/in","ANSV: "+answer[0]);
return 0;
</pre>
<h2><span class="mw-headline" id=".D0.92.D0.B8.D1.85.D1.96.D0.B4.D0.BD.D0.B0_.D1.87.D0.B0.D1.81.D1.82.D0.B8.D0.BD.D0.B0_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.83"><span class="mw-headline-number">2</span> Вихідна частина протоколу</span></h2>
<p>Протокол вихідних запитів працює у кооперації з вихідним транспортом та окремим об'єктом "Користувацького протоколу". Джерелом запиту через протокол може виступати <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Documents/User_API#SYSTransport" title="Special:MyLanguage/Documents/User API">функція загальносистемного API користувацького програмування вихідного транспорту</a> "<b>int messIO( XMLNodeObj req, string prt );</b>", у параметрах якої вказується:
</p>
<ul><li> <i>req</i> — запит у вигляді дерева XML зі структурою, яка відповідає вхідному формату реалізованого протоколу;</li>
<li> <i>prt</i> — ім'я цього модуля — "UserProtocol".</li></ul>
<p>Запит, що надіслано вищенаведеним чином, спрямовується до прямої процедури обробки запиту протоколу (рис.3), або процедури шаблону, з ідентифікатором користувацького протоколу, який вказується у атрибуті <b>req.attr("ProtIt")</b>.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:842px;"><a class="image" href="http://oscada.org/wiki/File:UserProtocol_up_out_uk.png"><img class="thumbimage" height="687" src="../files/UserProtocol_up_out_uk.png" width="840" /></a>  <div class="thumbcaption">Рис.3. Вкладка прямої процедури обслуговування вихідних запитів.</div></div></div></div>
<p>Вкладка процедури обробки вихідних запитів містить лише поле тексту прямої процедури обробки на внутрішній мові програмування OpenSCADA, яку вказано у попередній вкладці. Ця вкладка відсутня для режиму роботи за шаблоном.
</p><p>Для прямої процедури обробки предвизначено, та обов'язкові або опціональні до створення у шаблоні, наступні атрибути обміну:
</p>
<ul><li> <i><b>Вихідний ВВ (io)</b></i> &lt;Об'єкт::XMLNode&gt; — XML вузол обміну з клієнтом, через який протокол приймає запити та до якого поміщається результат у форматі, який реалізується процедурою;</li>
<li> <i><b>Транспорт (tr)</b></i> &lt;Об'єкт&gt; — об'єкт транспорту, призначено для виклику функції транспорту <i>string messIO( string mess, real timeOut = 1000 );</i> — <b>tr.messIO(req)</b>.</li></ul>
<p>Загальний сценарій формування вихідного запиту:
</p>
<ul><li> Формування XML-дерева відповідно до структури, яка реалізується протоколом, та вказання ідентифікатору користувацького протоколу у атрибуті "ProtIt".</li>
<li> Відправка запиту до транспорту через цей протокол — "<b>SYS.Transport["{Modul}"]["out_{OutTransp}"].messIO(req, "UserProtocol");</b>".</li>
<li> Обрання користувацького протоколу відповідно до <b>req.attr("ProtIt")</b> та ініціалізація змінних вихідного транспорту: <i>io</i> — відповідно до першого аргументу <b>messIO()</b> та <i>tr</i> — об'єкт "OutTransp".</li>
<li> Виклик процедури на виконання, яка, здійснивши обробку структури <i>io</i>, формує прямий запит транспорту <i>tr.messIO(req);</i>, результат якого обробляється та поміщається назад до <i>io</i>.</li></ul>
<p>Сенс виокремлення протокольної частини коду до процедури користувацького протоколу, або шаблону, полягає у спрощенні та уніфікації інтерфейсу клієнтського обміну при багаторазовому використанні та передбачає формування структури XML-вузла обміну у вигляді атрибутів адрес віддалених станцій, адрес читаних та записаних змінних, а також значень самих змінних. При цьому весь вантаж безпосереднього кодування запиту та декодування відповіді покладається на процедуру користувацького протоколу. Якщо це одноразова реалізація, яка до того-ж не передбачає реалізації вхідної частини, то простіше це зробити одразу у початковому шаблоні до джерела даних, у вигляді вбудованої функції.
</p><p>У якості прикладу розглянемо реалізацію запитів за посередництвом протоколу DCON до обробнику, реалізованому у попередньому розділі. Почнемо з реалізації протокольної частини:
</p>
<pre style="white-space: pre-wrap;">
//Формування кінцевого запиту
request = io.name().slice(0,1) + io.attr("addr").toInt().toString(16,2) + io.text();
if(io.attr("CRC").toInt()) {
  CRC = 0;
  for(i = 0; i &lt; request.length; i++) CRC += request.charCodeAt(i);
    request += (CRC&amp;0xFF).toString(16,2) + "\r";
}
else request += "\r";
//Відправка запиту
resp = tr.messIO(request);
while(resp[resp.length-1]&nbsp;!= "\r") {
  tresp = tr.messIO("");
  if(!tresp.length) break;
  resp += tresp;
}
//Аналіз відповіді
if(io.attr("CRC").toInt()) {
  if(resp.length &lt; 4 || resp[resp.length-1]&nbsp;!= "\r") { io.setAttr("err","10:"+tr("Error or no response.")); return; }
  //Перевірка відповіді на цілісність (CRC)
  CRC = 0;
  for(i = 0; i &lt; (resp.length-3); i++) CRC += resp.charCodeAt(i);
    if(CRC&nbsp;!= resp.slice(resp.length-3,resp.length-1).toInt(16)) { io.setAttr("err","11:"+tr("CRC error.")); return; }
}
else if(resp.length &lt; 2 || resp[resp.length-1]&nbsp;!= "\r") { io.setAttr("err","10:"+tr("Error or no response.")); return; }
if(resp[0]&nbsp;!= "&gt;") { io.setAttr("err","12:"+resp[0]+":"+tr("DCON error.")); return; }
//Повернення результату
io.setAttr("err","");
io.setText(resp.slice(1,resp.length-3));
</pre>
<p>Та процедура безпосереднього надсилання DCON запиту, через попередню процедуру протоколу. Цю процедуру треба помістити у потрібне завдання або проміжну функцію OpenSCADA, наприклад, у процедуру об'єкту контролеру <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Modules/JavaLikeCalc#Examples" title="Special:MyLanguage/Modules/JavaLikeCalc">DAQ.JavaLikeCalc</a>:
</p>
<pre style="white-space: pre-wrap;">
//Приготування запиту
req = SYS.XMLNode("#").setAttr("ProtIt","DCON").setAttr("addr",10);
//Надсилання запиту
SYS.Transport["Serial"]["out_TestDCON"].messIO(req,"UserProtocol");
if(!req.attr("err").length) SYS.messDebug("TEST REQ","RES: "+req.text());

//Приготування другого запиту
req = SYS.XMLNode("@").setAttr("ProtIt","DCON").setAttr("addr",10);
//Відправка другого запиту
SYS.Transport["Serial"]["out_TestDCON"].messIO(req,"UserProtocol");
if(!req.attr("err").length) SYS.messDebug("TEST REQ","RES: "+req.text());
</pre>






</div></body>
</html>