<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<title>Модулі/Serial - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../files/doc.css" rel="stylesheet" /></head>
<body><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="uk">Модулі/Serial</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="uk"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Modules%2FSerial&amp;action=page&amp;filter=&amp;language=uk" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Modules/Serial" title="Modules/Serial">Modules/Serial</a> and the translation is 100% complete.</div><hr /><div class="mw-pt-languages noprint" dir="ltr" lang="en"><div class="mw-pt-languages-label">Other languages:</div><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="http://oscada.org/wiki/Modules/Serial" title="Modules/Serial (100% translated)">English</a>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--complete" href="http://oscada.org/wiki/Modules/Serial/ru" title="Модули/Serial (100% translated)">российский</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">українська</span></div></div>
<div class="noprint" style="float:right; border:1px solid gray; width:300px; background-color:ivory; padding:2px;">
<table cellspacing="0">
<tr>
<td> <a class="image" href="http://oscada.org/wiki/File:Constr.png"><img alt="Constr.png" height="32" src="../files/Constr.png" width="32" /></a>
</td>
<td style="padding-left:5px;"> The translation checking and actualizing
</td></tr></table>
</div>
<table class="wikitable">

<tr>
<th> Модуль </th>
<th> Ім'я </th>
<th> Версія </th>
<th> Ліцензія </th>
<th> Джерело </th>
<th> Мови </th>
<th> Платформи </th>
<th> Тип </th>
<th> Автор </th>
<th> Опис
</th></tr>

<tr>
<td> <a href="../Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> </td>
<td> Послідовні інтерфейси </td>
<td> 1.6 </td>
<td> GPL2 </td>
<td> tr_Serial.so </td>
<td> en,uk,ru,de </td>
<td> x86,x86_64,ARM
</td>
<td> Транспорт </td>
<td> Роман Савоченко, Максим Кочетков </td>
<td> Надає послідовний інтерфейс. Використовується для обміну даними через послідовні інтерфейси типу RS232, RS485, GSM та інші.
</td></tr></table>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.D0.92.D1.85.D1.96.D0.B4.D0.BD.D1.96_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D0.B8"><span class="tocnumber">1</span> <span class="toctext">Вхідні транспорти</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#.D0.92.D0.B8.D1.85.D1.96.D0.B4.D0.BD.D1.96_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D0.B8"><span class="tocnumber">2</span> <span class="toctext">Вихідні транспорти</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#API_.D0.BA.D0.BE.D1.80.D0.B8.D1.81.D1.82.D1.83.D0.B2.D0.B0.D1.86.D1.8C.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D1.83.D0.B2.D0.B0.D0.BD.D0.BD.D1.8F"><span class="tocnumber">3</span> <span class="toctext">API користувацького програмування</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#.D0.97.D0.B0.D1.83.D0.B2.D0.B0.D0.B6.D0.B5.D0.BD.D0.BD.D1.8F"><span class="tocnumber">4</span> <span class="toctext">Зауваження</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#.D0.92.D1.96.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.96.2F.D0.BB.D0.BE.D0.BA.D0.B0.D0.BB.D1.8C.D0.BD.D1.96_.D0.BF.D0.BE.D1.81.D0.BB.D1.96.D0.B4.D0.BE.D0.B2.D0.BD.D1.96_.D1.96.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.B8"><span class="tocnumber">4.1</span> <span class="toctext">Віртуальні/локальні послідовні інтерфейси</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#.D0.9F.D0.B5.D1.80.D0.B5.D0.BA.D0.B8.D0.B4.D0.B0.D0.BD.D0.BD.D1.8F_.D0.BF.D0.BE.D1.81.D0.BB.D1.96.D0.B4.D0.BE.D0.B2.D0.BD.D0.BE.D0.B3.D0.BE_.D1.96.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D1.83_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_.D0.BC.D0.B5.D1.80.D0.B5.D0.B6.D1.83_Ethernet"><span class="tocnumber">4.2</span> <span class="toctext">Перекидання послідовного інтерфейсу через мережу Ethernet</span></a></li>
</ul>
</li>
</ul>
</div>

<p>Модуль транспорту Serial надає в систему підтримку транспортів, основаних на послідовних інтерфейсах типу RS232, RS485, GSM та інше. Підтримуються вхідні та вихідні транспорти. Додати нові вхідні та вихідні інтерфейси можна за посередництвом конфігурації транспортної підсистеми у будь якому конфігураторі системи OpenSCADA.
</p><p>У режимі модему модулем підтримується змішаний режим роботи. Змішаний режим має на увазі наявність вхідного транспорту, який очікує зовнішніх підключень, а також вихідного транспорту на тому-ж пристрої. Тобто вхідний транспорт буде ігнорувати всі запити при наявності встановленого вихідним транспортом підключення, в той-же час вихідний транспорт не буде здійснювати спроб встановлення підключення при наявності підключення до вхідного транспорту або підключення іншого вихідного транспорту, наприклад, з іншим номером телефону.
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../files/At.png" width="22" /></a> У звичайному режимі послідовного інтерфейсу не допускається багаторазове використання одного й того-ж порту у вхідних та вихідних транспортах. Глобального блокування послідовного пристрою не здійснюється у зв'язку із неоднозначністю цього процесу на системному рівні, а багаторазове використання може привести до непередбачуваних проблем. При потребі у організації локального послідовного каналу з парою пов'язаних портів рекомендується використовувати команду "<b>$ socat -d -d pty,raw,echo=0,perm=0666 pty,raw,echo=0,perm=0666</b>".
</p>
<h2><span class="mw-headline" id=".D0.92.D1.85.D1.96.D0.B4.D0.BD.D1.96_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D0.B8"><span class="mw-headline-number">1</span> Вхідні транспорти</span></h2>
<p>Сконфігурований та запущений вхідний транспорт відкриває порт послідовного інтерфейсу для очікування запитів клієнтів. Кожний вхідний інтерфейс обов'язково пов'язується з одним із доступних транспортних протоколів, до якого передаються вхідні повідомлення.
</p><p>Діалог конфігурації вхідного послідовного інтерфейсу зображено на рисунку 1.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:676px;"><a class="image" href="http://oscada.org/wiki/File:Serial_in_uk.png"><img class="thumbimage" height="588" src="../files/Serial_in_uk.png" width="674" /></a>  <div class="thumbcaption">Рис.1. Діалог конфігурації вхідного послідовного інтерфейсу.</div></div></div></div>
<p>За допомогою цього діалогу можна встановити:
</p>
<ul><li> Стан транспорту, а саме: "Статус", "Виконується" та ім'я БД, яка містить конфігурацію.</li>
<li> Ідентифікатор, ім'я та опис транспорту.</li>
<li> Адреса інтерфейсу у форматі рядка: <i>"dev:spd:format[:fc[:mdm]]"</i>. Де:
<ul><li> <i>dev</i> — адреса послідовного пристрою (/dev/ttyS0);</li>
<li> <i>spd</i> — швидкість послідовного пристрою із ряду: 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000 або 921600;</li>
<li> <i>format</i> — формат асинхронних даних "{розмір}{парність}{стоп}" (8N1, 7E1, 5O2, ...);</li>
<li> <i>fc</i> — управління потоком:
<ul><li> "h" — апаратне (CRTSCTS);</li>
<li> "s" — програмне (IXON|IXOFF);</li>
<li> "rts" — використання RTS сигналу для передачі(false) та перевірки на луну, для сирого RS-485;</li>
<li> "rts1" — використання RTS сигналу для передачі(true) та перевірки на луну, для сирого RS-485;</li>
<li> "rtsne" — використання RTS сигналу для передачі(false) без перевірки на луну, для сирого RS-485;</li>
<li> "rts1ne" — використання RTS сигналу для передачі(true) без перевірки на луну, для сирого RS-485;     </li>
<li> "RS485" — використовувати RS-485 режим, за посередництвом TIOCSRS485.</li></ul></li>
<li> <i>mdm</i> — режим модему, очікування 'RING'.</li></ul></li>
<li> Вибір транспортного протоколу.</li>
<li> Стан, в який переводити транспорт при завантажені: "Запущено".</li>
<li> Інтервали часу інтерфейсу в форматі рядка: <i>"symbol:frm[::rtsDelay1:rtsDelay2]"</i>. Де:
<ul><li> <i>symbol</i> — час символу у мілісекундах. Використовується для контролю факту закінчення фрейму;</li>
<li> <i>frm</i> — максимальний час фрейму у мілісекундах. Використовується для обмеження максимального розміру пакету запиту (фрейму);</li>
<li> <i>rtsDelay1</i> — затримка, у мілісекундах, між включенням передавача сигналом RTS та початком передачі;</li>
<li> <i>rtsDelay2</i> — затримка, у мілісекундах, між закінченням передачі та відключенням передавача сигналом RTS.</li></ul></li>
<li> Пріоритет задачі вхідного потоку.</li></ul>
<p>Транспорт підтримує можливість роботи у режимі модему. Цей режим включається п'ятим параметром адреси та передбачає очікування дзвінка від віддаленого модему (запит "RING"), відповіді на дзвінок (команда "ATA") та наступної передачі запитів від віддаленої станції протоколу транспорту. Відключення сеансу зв'язку здійснюється ініціатором з'єднання та призводить до перепідключення модему приймача на очікування нових дзвінків.
</p><p>Для налаштування модему вхідного транспорту передбачено спеціальну вкладку "Модем" (рис.2).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:676px;"><a class="image" href="http://oscada.org/wiki/File:Serial_in_mod_uk.png"><img class="thumbimage" height="498" src="../files/Serial_in_mod_uk.png" width="674" /></a>  <div class="thumbcaption">Рис.2. Вкладка "Модем" конфігурації модему вхідного послідовного інтерфейсу.</div></div></div></div>
<p>За допомогою цього діалогу можна встановити наступні властивості роботи з модемом:
</p>
<ul><li> Час очікування, таймауту, модему на запит, у секундах.</li>
<li> Витримка часу перед ініціалізацією модему, в секундах.</li>
<li> Витримка часу після ініціалізації модема, в секундах.</li>
<li> Перший рядок ініціалізації, зазвичай містить команду скидання налаштувань модему "ATZ".</li>
<li> Другий рядок ініціалізації.</li>
<li> Рядок результату ініціалізації модему, зазвичай "OK", яким відповідає модем на ініціалізацію та якого треба очікувати.</li>
<li> Запит дзвінка, зазвичай "RING", який надсилає модем у випадку надходження вихідного виклику.</li>
<li> Відповідь на дзвоник, зазвичай "ATA", який надсилається модему для відповіді на дзвінок.</li>
<li> Рядок результату на відповідь на дзвінок, зазвичай "CONNECT", яким відповідає модем на команду відповіді та яку треба очікувати.</li></ul>
<h2><span class="mw-headline" id=".D0.92.D0.B8.D1.85.D1.96.D0.B4.D0.BD.D1.96_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D0.B8"><span class="mw-headline-number">2</span> Вихідні транспорти</span></h2>
<p>Сконфігурований та запущений вихідний транспорт відкриває порт послідовного інтерфейсу для відправки запитів через нього.
</p><p>Головна вкладка сторінки конфігурації вихідного послідовного інтерфейсу зображена на рис.3.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:693px;"><a class="image" href="http://oscada.org/wiki/File:Serial_out_uk.png"><img class="thumbimage" height="559" src="../files/Serial_out_uk.png" width="691" /></a>  <div class="thumbcaption">Рис.3. Головна вкладка сторінки конфігурації вихідного послідовного інтерфейсі.</div></div></div></div>
<p>За допомогою цього діалогу можна встановити:
</p>
<ul><li> Стан транспорту, а саме: "Статус", "Запущено" та ім'я БД, яка містить конфігурацію.</li>
<li> Ідентифікатор, ім'я та опис транспорту.</li>
<li> Адреса інтерфейсу у форматі рядка: <i>"dev:spd:format[:fc[:modTel]]"</i>. Де:
<ul><li> <i>dev</i> — адреса послідовного пристрою (/dev/ttyS0);</li>
<li> <i>spd</i> — швидкість послідовного пристрою із ряду: 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000 або 921600;</li>
<li> <i>format</i> — формат асинхронних даних "{розмір}{парність}{стоп}" (8N1, 7E1, 5O2, ...);</li>
<li> <i>fc</i> — управління потоком:
<ul><li> "h" — апаратне (CRTSCTS);</li>
<li> "s" — програмне (IXON|IXOFF);</li>
<li> "rts" — використання RTS сигналу для передачі(false) та перевірки на луну, для сирого RS-485;</li>
<li> "rts1" — використання RTS сигналу для передачі(true) та перевірки на луну, для сирого RS-485;</li>
<li> "rtsne" — використання RTS сигналу для передачі(false) без перевірки на луну, для сирого RS-485;</li>
<li> "rts1ne" — використання RTS сигналу для передачі(true) без перевірки на луну, для сирого RS-485;     </li>
<li> "RS485" — використовувати RS-485 режим, за посередництвом TIOCSRS485.</li></ul></li>
<li> <i>modTel</i> — телефон модему, присутність цього поля перемикає транспорт на роботу у режимі модему.</li></ul></li>
<li> Стан, в який переводити транспорт при завантажені: "Запущено".</li>
<li> Інтервали часу інтерфейсу у форматі рядка: <i>"conn:symbol[-NextReqMult][:KeepAliveTm[:rtsDelay1:rtsDelay2]]"</i>. Де:
<ul><li> <i>conn</i> — час очікування з'єднання тобто відповіді від віддаленого пристрою;</li>
<li> <i>symbol</i> — час символу у мілісекундах. Використовується для контролю факту закінчення фрейму та таймауту наступного запиту;</li>
<li> <i>NextReqMult</i> — множник часу наступного запиту до часу символу <i>symbol</i>, 4 по замовченню;</li>
<li> <i>KeepAliveTm</i> — таймаут життя в секундах для перезавантаження транспорту;</li>
<li> <i>rtsDelay1</i> — затримка, у мілісекундах, між включенням передавача сигналом RTS та початком передачі;</li>
<li> <i>rtsDelay2</i> — затримка, у мілісекундах, між закінченням передачі та відключенням передавача сигналом RTS.</li></ul></li>
<li> Не зупиняти при обробці. Інколи закриття відкритого пристрою може бути руйнівним, наприклад, на ПЛК LP від ICP-DAS, та Ви можете попередити це цією опцією.</li></ul>
<p>Транспорт підтримує можливість роботи у режимі модему. Цей режим включається наявністю п'ятого параметру адреси та передбачає здійснення дзвінка за телефоном, вказаним п'ятим параметром, в момент запуску транспорту. Після встановлення зв'язку з віддаленим модемом всі запити передачі спрямовуються станції за віддаленим модемом. Відключення сеансу зв'язку, із зупинкою транспорту, здійснюється за таймаутом активності.
</p><p>Транспорт може працювати з апаратною шиною I2С якщо у якості пристрою обрати "/dev/i2c-{N}" та шина дозволить встановити адресу підлеглого пристрою командою I2C_SLAVE, із <b>першого байту запиту</b>. Швидкість та формат не відіграють ролі в цьому режимі. Із таймаутів тут фактично працює тільки час символу і переважно для розрахунку очікування повтору запиту.
</p><p>Для налаштування модему вихідного транспорту передбачено спеціальну вкладку "Модем" (рис.4).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:691px;"><a class="image" href="http://oscada.org/wiki/File:Serial_out_mod_uk.png"><img class="thumbimage" height="583" src="../files/Serial_out_mod_uk.png" width="689" /></a>  <div class="thumbcaption">Рис.4. Вкладка "Модем" конфігурації модему вихідного послідовного інтерфейсу.</div></div></div></div>
<p>За допомогою цього діалогу можна встановити наступні властивості роботи з модемом:
</p>
<ul><li> Час очікування, таймаут, модема на запити, в секундах.</li>
<li> Час життя підключення, в секундах. Якщо протягом цього часу буде відсутня передача даних через транспорт то підключення буде розірвано.</li>
<li> Витримка часу перед ініціалізацією модема, в секундах.</li>
<li> Витримка часу після ініціалізації модему, в секундах.</li>
<li> Перший рядок ініціалізації, зазвичай містить команду скидання налаштувань модему "ATZ".</li>
<li> Другий рядок ініціалізації.</li>
<li> Рядок результату ініціалізації модему, зазвичай "OK", яким відповідає модем на ініціалізацію та якого треба очікувати.</li>
<li> Рядок додзвону до віддаленого модему, зазвичай "ATDT". При додзвоні номер телефону додається до даного префіксу.</li>
<li> Рядок результату вдалого підключення, зазвичай "CONNECT".</li>
<li> Рядок результату зайнятості лінії, зазвичай "BUSY".</li>
<li> Рядок результату відсутності несущої в лінії, зазвичай "NO CARRIER".</li>
<li> Рядок результату відсутності гудка лінії, зазвичай "NO DIALTONE".</li>
<li> Рядок виходу з режиму даних, зазвичай "+++" та "Час перед ініціалізацією модему" після неї використовується.</li>
<li> Команда повісити трубку, зазвичай "+++ATH". Ця команда викликається завжди, коли потрібно розірвати підключення.</li>
<li> Рядок результату команди повісити трубку, зазвичай "OK", яким відповідає модем на команду та який треба очікувати.</li></ul>
<h2><span class="mw-headline" id="API_.D0.BA.D0.BE.D1.80.D0.B8.D1.81.D1.82.D1.83.D0.B2.D0.B0.D1.86.D1.8C.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D1.83.D0.B2.D0.B0.D0.BD.D0.BD.D1.8F"><span class="mw-headline-number">3</span> API користувацького програмування</span></h2>
<p><b>Об'єкт "Вихідний транспорт" (SYS.Transport.Serial.out_{OutTransport})</b>
</p>
<ul><li> <i>bool TS( bool rts = EVAL )</i> — Керування відправкою за посередництвом встановлення запиту <i>rts</i> та повернення стану дозволу CTS.</li>
<li> <i>bool DR( bool dtr = EVAL )</i> — Керування готовністю пристрою за посередництвом встановлення готовності терміналу <i>dtr</i> та повернення стану готовності DSR.</li>
<li> <i>bool DCD()</i> — Повернення стану виявлення несущої даних.</li>
<li> <i>bool RI()</i> — Повернення індикатору дзвінка.</li>
<li> <i>int sendbreak( int duration = 0 )</i> — Надіслати в потік переривання нулями протягом <i>duration</i> (0 — деякий інтервал по замовченню).</li></ul>
<h2><span class="mw-headline" id=".D0.97.D0.B0.D1.83.D0.B2.D0.B0.D0.B6.D0.B5.D0.BD.D0.BD.D1.8F"><span class="mw-headline-number">4</span> Зауваження</span></h2>
<p>Комунікації через послідовні інтерфейси мають низку особливостей. Найбільш важливою особливістю є критерій закінчення повідомлення та час очікування цього критерію. У одних протоколах таким критерієм виступає ознака закінчення або вказаний розмір повідомлення. В інших протоколах таким критерієм є відсутність даних у вхідному потоці протягом вказаного часу — час символу. У обох випадках час очікування критерію або символу є ключовим та сильно впливає на загальний час обміну. Відповідно, чим менше цей час тим краще. Тут і виникає проблема латентності обладнання та його драйверів.
</p><p>Перевірити латентність каналу обміну та тим самим оптимально налаштувати час доочікування, символу можна за допомогою інтерфейсу вкладки "Запит" вихідного транспорту. Для цього потрібно вказати зразковий запит відповідного протоколу, вказати "Очікувати таймаут", надіслати запит та проконтролювати його цілісність. Для отримання більш репрезентативного результату треба запит повторити декілька разів. Якщо спостерігається отримання неповних відповідей, то час символу треба збільшити, інакше можна зменшити.
</p><p>На будованому обладнані послідовних інтерфейсів RS232/422/485 можна добитися низького рівня латентності, впритул до одиниць мілісекунд. Однак, на високо-навантажених системах з безліччю задач у пріоритеті реального часу латентність може стати недетермінованою у зв'язку з виконанням потоку обслуговування подій ядра Linux у низькому пріоритеті. Для вирішення цієї проблеми треба встановити високий пріоритет цим потокам, що можна здійснити за допомогою скрипту, помістивши його, наприклад, у "/etc/rc.local":
</p>
<pre style="white-space: pre-wrap;">
#!/bin/sh

# High priority set to kernel threads events for serial interfaces reaction rise
events=`ps -Ao pid,comm | sed -n '/[ ]*\([^ ]\)[ ]*events\/[0-9]/s//\1/p'`
for ie in $events; do
  chrt -pr 21 $ie
done
</pre>
<p>Цей скрипт не має сенсу для ядер Linux реального часу, з патчем PREEMPT_RT, скільки всі потоки переривань та повідомлень там вже запускаються у пріоритеті реального часу.
</p><p>На зовнішньому обладнані послідовних інтерфейсів, наприклад, у перетворювачах USB-&gt;RS232/422/485, може виникнути проблема високої латентності, пов'язана з особливістю апаратної реалізації або його драйверу. Вирішувати цю проблему треба шляхом вивчення налаштувань цього обладнання або встановленням більшого часу очікування, символу!
</p><p>Схожим чином визначається й оптимальний час підключення, а саме: встановити час підключення у значення по замовченню для даної швидкості (ставиться при зміні швидкості у адресі), зняти "Очікувати таймаут", відіслати запит. Якщо відповідь прийшла то беремо виміряний час відгуку пристрою, подвоюємо та встановлюємо отримане значення як час підключення. Необґрунтоване перевищення часу підключення призведе до великих очікувань у випадку відсутності пристрою, а також спрацьовуванню захисних таймаутів внутрішніх процедур!
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../files/At.png" width="22" /></a> На ринку зустрічаються USB-&gt;Serial перетворювачі, які працюють тільки з терміналами, тобто вони можуть передавати та опрацьовувати виключно ASCII символи та не можуть бути переключені у бінарний режим. Відомі екземпляри таких перетворювачів: PL2303TA (Y-105).
</p>
<h3><span class="mw-headline" id=".D0.92.D1.96.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.96.2F.D0.BB.D0.BE.D0.BA.D0.B0.D0.BB.D1.8C.D0.BD.D1.96_.D0.BF.D0.BE.D1.81.D0.BB.D1.96.D0.B4.D0.BE.D0.B2.D0.BD.D1.96_.D1.96.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.B8"><span class="mw-headline-number">4.1</span> Віртуальні/локальні послідовні інтерфейси</span></h3>
<p>Часто для локальної перевірки, без фізичного обладнання, потрібна пара портів підключених у одну мережу. Створення таких портів та виконання багатьох інших операцій над послідовним потоком дозволяє виконувати утиліта <b>socat</b>. Наприклад, для створення двох пов'язаних портів треба виконати команду, яка створить їх та повідомить адреси:
</p>
<pre style="white-space: pre-wrap;">
$ socat -d -d pty,raw,echo=0,perm=0666 pty,raw,echo=0,perm=0666
2013/07/02 16:37:29 socat[10402] N PTY is /dev/pts/6
2013/07/02 16:37:30 socat[10402] N PTY is /dev/pts/7
2013/07/02 16:37:30 socat[10402] N starting data transfer loop with FDs [3,3] and [5,5]
</pre>
<h3><span class="mw-headline" id=".D0.9F.D0.B5.D1.80.D0.B5.D0.BA.D0.B8.D0.B4.D0.B0.D0.BD.D0.BD.D1.8F_.D0.BF.D0.BE.D1.81.D0.BB.D1.96.D0.B4.D0.BE.D0.B2.D0.BD.D0.BE.D0.B3.D0.BE_.D1.96.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D1.83_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_.D0.BC.D0.B5.D1.80.D0.B5.D0.B6.D1.83_Ethernet"><span class="mw-headline-number">4.2</span> Перекидання послідовного інтерфейсу через мережу Ethernet</span></h3>
<p>У деяких випадках буває корисним перекинути порт послідовного інтерфейсу віддаленої машини на локальний порт, наприклад, для опитування пристроїв, підключених до послідовного інтерфейсу віддаленої машини. Звісно, якщо встановити на віддалену машину OpenSCADA у конфігурації ПЛК, то можна буде одразу виконувати обробку цих даних, попереднє буферування/архівування та інше, але інколи обладнання може бути складним для запуску OpenSCADA, де й рятує можливість перекидання послідовного потоку через мережу. Для вирішення цього завдання можна скористатися тією-ж утилітою <b>socat</b> або <b>remserial</b>, <b>ser2net</b>, яку вдасться зібрати та запустити на віддаленій машині. Приклади перекидання послідовного порту:
</p>
<pre style="white-space: pre-wrap;">
# Створення сокету на порту 5555 віддаленої машини, для порту /dev/ttyS0
$ socat tcp-l:5555,reuseaddr,fork file:/dev/ttyS0,raw
# Підключення до сокету відображеного порту віддаленої машини та формування файлу відображеного локального інтерфейсу
$ socat -d -d pty,raw,echo=0,perm=0666 tcp:192.168.2.4:5555,mss=1400
2013/07/04 10:09:09 socat[12947] N PTY is /dev/pts/4
2013/07/04 10:09:09 socat[12947] N opening connection to AF=2 192.168.2.4:5555
2013/07/04 10:09:09 socat[12947] N successfully connected from local address AF=2 192.168.2.61:33493
2013/07/04 10:09:09 socat[12947] N starting data transfer loop with FDs [3,3] and [5,5]
</pre>
<p>У випадку з "socat", а можливо й інших утиліт, можна на клієнтському боці опустити запуск драйверу EthernetTCP-&gt;Serial та підключатися із OpenSCADA прямо на TCP-порт віддаленого пристрою.
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../files/At.png" width="22" /></a> У роботі через драйвер EthernetTCP-&gt;Serial є особливість, яка пов'язана із наявністю двох таймаутів підключення, один у драйвері, інший у <a href="../Modules/Sockets.html" title="Special:MyLanguage/Modules/Sockets">Transport.Sockets</a>. Важливо щоб значення цього таймауту у <a href="../Modules/Sockets.html" title="Special:MyLanguage/Modules/Sockets">Transport.Sockets</a> було більше ніж у драйвері інакше можливий зсув та отримання на запит запізнілої відповіді від попереднього запиту.
</p><p>Багато виробників промислового комунікаційного обладнання випускають готові конвертери із Ethernet у RS-232/422/485, які можуть використовуватися з OpenSCADA таким-же чином. Коментарі та перелік перетворювачів з якими роботу OpenSCADA перевірено:
</p>
<ul><li> <a class="external text" href="http://www.icpdas.com" rel="nofollow noreferrer noopener" target="_blank">ICP DAS</a>: <a class="external text" href="http://www.icpdas.com/products/Industrial/pds/tds-700.htm" rel="nofollow noreferrer noopener" target="_blank">tDS-7xx</a> — налаштовується через WEB-інтерфейс та працює за прямим підключенням до TCP-порту;</li>
<li> <a class="external text" href="http://tibbo.com" rel="nofollow noreferrer noopener" target="_blank">Tibbo</a>: <a class="external text" href="http://tibbo.com/products/controllers/ds100.html" rel="nofollow noreferrer noopener" target="_blank">DS100</a> — <span style="color: red">налаштовується тільки через програму для MS Windows®</span>, надає власний драйвер для формування віртуальних послідовних інтерфейсів на Linux, працює за прямим підключенням до TCP-порту.</li></ul>






</div></body>
</html>