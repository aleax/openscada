<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="UTF-8" />
<title>Документація/Як зробити/Створити модуль - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../en/files/doc.css" rel="stylesheet" /></head>
<body><div class="floatright"><a href="http://oscada.org"><img alt="OpenSCADA" src="../en/files/Logo-big.png" /></a></div><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="uk">Документація/Як зробити/Створити модуль</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="uk"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Documents%2FHow+to%2FCreate+module&amp;action=page&amp;filter=&amp;language=uk" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Documents/How_to/Create_module" title="Documents/How to/Create module">Documents/How to/Create module</a> and the translation is 100% complete.</div><hr /><div class="mw-pt-languages" dir="ltr" lang="en"><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="../en/How_to_Create_module.html" title="Documents/How to/Create module (100% translated)">English</a>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--complete" href="../ru/How_to_Create_module.html" title="Документация/Как сделать/Создать модуль (100% translated)">российский</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">українська</span></div></div>
<div class="noprint" style="float:right; border:1px solid gray; width:300px; background-color:ivory; padding:2px;">
<table cellspacing="0">
<tr>
<td> <a class="image" href="http://oscada.org/wiki/File:Constr.png"><img alt="Constr.png" height="32" src="../en/files/Constr.png" width="32" /></a>
</td>
<td style="padding-left:5px;"> Generic revision and updating
</td></tr></table>
</div>
<div style="float:right; border:1px solid gray; width:300px; padding:2px; margin-left: 10pt; margin-bottom: 10pt;">
<ul><li> <b>Автор:</b> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Роман Савоченко</a> </li></ul>
</div>
<p>Цей керівний документ покликано допомогти у створені модулів для системи OpenSCADA. Створення модуля може знадобитися у випадку бажання додати підтримку нового джерела даних або іншого розширення до системи OpenSCADA. Оскільки OpenSCADA є гранично модульною то всі інтерфейси взаємодії з зовнішнім середовищем здійснюється за посередництвом розширення спеціалізованими модулями типів:
</p>
<ul><li> "Бази даних"</li>
<li> "Комунікаційні інтерфейси, транспорти"</li>
<li> "Протоколи комунікаційних інтерфейсів"</li>
<li> "Джерела даних та збір даних"</li>
<li> "Архіви (повідомлень та значень)"</li>
<li> "Інтерфейси користувача (GUI, TUI, WebGUI, speach, signal ...)"</li>
<li> "Додаткові модулі, спеціальні"</li></ul>
<p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../en/files/At.png" width="22" /></a> Для створення модулів OpenSCADA потрібні знання у програмуванні на мові C/C++, складальної системи <a class="external text" href="http://en.wikipedia.org/wiki/GNU_build_system" rel="nofollow noreferrer noopener" target="_blank">AutoTools</a>, а також базові знання у ОС Linux та використовуваного дистрибутиву Linux.
</p><p>Для розміщення розробленого модуля у основному репозиторії дерева вихідних текстів OpenSCADA Ви маєте виконати наступне та слідувати наведеним вимогам:
</p>
<ul><li> бути правовласником або автором коду цього модуля та розповсюджувати його за вільною ліцензією, віддаючи перевагу GPL;</li>
<li> приготувати та зберігати код модуля як архів окремої теки модуля будь-якої з підсистем OpenSCADA, слідувати вимогам до вмісту:
<ul><li> вихідні тексти модуля мають включати коректну інформацію прав копіювання, на початку кожного файлу, бути написаними та відформатованими згідно до якоїсь системи де перевагу треба віддавати стилю форматуванню основних модулів OpenSCADA;</li>
<li> файли локалізації модулів також мають бути коректними, актуальними та відповідно відформатованими.</li></ul></li>
<li> написати коротку інформаційну сторінку модуля для розташування її на <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Modules" title="Special:MyLanguage/Modules">OpenSCADA Wiki</a>, таким-же чином як і для інших модулів поряд;</li>
<li> для розташування цього модуля написати прямий запит у темі форуму "<a class="external text" href="http://oscada.org/ua/forum/topics/razrabotka_openscada/" rel="nofollow noreferrer noopener" target="_blank">Розробка OpenSCADA</a>", включаючи доказ працездатності від розробника OpenSCADA або коротке демонстраційним відео.</li></ul>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D0.BD.D0.BE.D0.B2.D0.BE.D0.B3.D0.BE_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="tocnumber">1</span> <span class="toctext">Створення нового модуля</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#.D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D1.83_.D0.B4.D0.B5.D1.80.D0.B5.D0.B2.D1.96_.D0.B2.D0.B8.D1.85.D1.96.D0.B4.D0.BD.D0.B8.D1.85_.D1.82.D0.B5.D0.BA.D1.81.D1.82.D1.96.D0.B2_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.83_OpenSCADA"><span class="tocnumber">1.1</span> <span class="toctext">Створення у дереві вихідних текстів проекту OpenSCADA</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#.D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D0.B7.D0.BE.D0.B2.D0.BD.D1.96.D1.88.D0.BD.D1.8C.D0.BE.D0.B3.D0.BE_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F_.D0.B4.D0.BE_OpenSCADA"><span class="tocnumber">1.2</span> <span class="toctext">Створення зовнішнього модуля до OpenSCADA</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#API_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="tocnumber">2</span> <span class="toctext">API модуля</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#.D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.91.D0.B0.D0.B7.D0.B8_.D0.94.D0.B0.D0.BD.D0.B8.D1.85_.28.D0.91.D0.94.29.22"><span class="tocnumber">2.1</span> <span class="toctext">Модуль підсистеми "Бази Даних (БД)"</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#.D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.A2.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D0.B8.22"><span class="tocnumber">2.2</span> <span class="toctext">Модуль підсистеми "Транспорти"</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#.D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.A2.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D0.BD.D1.96_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D0.B8.22"><span class="tocnumber">2.3</span> <span class="toctext">Модуль підсистеми "Транспортні протоколи"</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#.D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.97.D0.B1.D1.96.D1.80_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85_.28DAQ.29.22"><span class="tocnumber">2.4</span> <span class="toctext"><span>Модуль підсистеми "Збір даних (DAQ)"</span></span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#.D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.90.D1.80.D1.85.D1.96.D0.B2.D0.B8.22"><span class="tocnumber">2.5</span> <span class="toctext">Модуль підсистеми "Архіви"</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#.D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.9A.D0.BE.D1.80.D0.B8.D1.81.D1.82.D1.83.D0.B2.D0.B0.D1.86.D1.8C.D0.BA.D1.96_.D1.96.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.B8_.28UI.29.22"><span class="tocnumber">2.6</span> <span class="toctext">Модуль підсистеми "Користувацькі інтерфейси (UI)"</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#.D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.A1.D0.BF.D0.B5.D1.86.D1.96.D0.B0.D0.BB.D1.8C.D0.BD.D1.96.22"><span class="tocnumber">2.7</span> <span class="toctext">Модуль підсистеми "Спеціальні"</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id=".D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D0.BD.D0.BE.D0.B2.D0.BE.D0.B3.D0.BE_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="mw-headline-number">1</span> Створення нового модуля</span></h2>
<p>Модулі в OpenSCADA представляють із себе поділювані бібліотеки, які підключаються до ядра OpenSCADA динамічно, під час роботи програми. Багато модулів у процесі роботи можуть бути відключені, підключені та оновлені із <a href="Program_manual.html#CfgModSched" title="Special:MyLanguage/Documents/Program manual">менеджера модулів</a>. Модулі також можуть бути включені у ядро OpenSCADA під час збірки, за посередництвом аргументу <b>--enable-{ModName}=incl</b> до скрипту конфігурації "configure", про що можна дізнатися із <a href="How_to_Build_from_source.html" title="Special:MyLanguage/Documents/How to/Build from source">посібника по збірці</a>. Модулі OpenSCADA можуть бути семи типів, згідно присутнім <a href="Program_manual.html#Modularity" title="Special:MyLanguage/Documents/Program manual">модульним підсистемам</a>. Наразі модулі до системи OpenSCADA пишуться на мові програмування "<b>C++</b>", хоча у подальшому можлива поява біндінгів на інші мови.
</p><p>Для полегшення створення нових модулів у дереві вихідних текстів, у гілці кожної підсистеми, передбачено теку "<b>=Tmpl=</b>" з шаблоном модуля відповідної підсистеми. Розробник нового модуля може взяти цю теку та скопіювати її з ім'ям свого нового модуля. Передбачено можливість створення модулів у дереві вихідних текстів проекту OpenSCADA або як незалежного проекту зовнішнього модуля до OpenSCADA.
</p>
<h3><span class="mw-headline" id=".D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D1.83_.D0.B4.D0.B5.D1.80.D0.B5.D0.B2.D1.96_.D0.B2.D0.B8.D1.85.D1.96.D0.B4.D0.BD.D0.B8.D1.85_.D1.82.D0.B5.D0.BA.D1.81.D1.82.D1.96.D0.B2_.D0.BF.D1.80.D0.BE.D0.B5.D0.BA.D1.82.D1.83_OpenSCADA"><span class="mw-headline-number">1.1</span> Створення у дереві вихідних текстів проекту OpenSCADA</span></h3>
<p>Створювати нові модулі у дереві вихідних текстів проекту OpenSCADA має сенс у випадку подальших планів передачі нового модуля проекту OpenSCADA. Оскільки модуль не має суперечити духу відкритого проекту та ліцензії на основі якої <a class="external text" href="http://oscada.org/ua/golovna/pro-proekt/licenziji/" rel="nofollow noreferrer noopener" target="_blank">розробляється та розповсюджується OpenSCADA</a> то ліцензією нового модуля вочевидь має бути одна із вільних ліцензій.
</p><p>В цілому процедура створення нового модуля з включенням до дерева вихідних текстів, на основі шаблону, є простішою за процедуру для зовнішнього модуля та включає в себе кроки:
</p>
<dl><dd>1. Отримання дерева вихідних текстів проекту OpenSCADA.
<dl><dd><i>Для робочої гілки:</i>
<dl><dd>$ svn co svn://oscada.org/trunk/OpenSCADA</dd></dl></dd>
<dd><i>Для гілки стабільного релізу (небажано оскільки до стабільних LTS релізів приймаються тільки виправлення та ця інструкція потребує версії 0.9 або більше):</i>
<dl><dd>$ svn co svn://oscada.org/tags/openscada_0.8.0</dd></dl></dd></dl></dd>
<dd>2. Копіювання теки шаблону з ім'ям нового модуля "NewMod" (наприклад, для підсистеми "БД"):
<dl><dd>$ cd OpenSCADA/src/moduls/bd</dd>
<dd>$ cp -r =Tmpl= NewMod; cd NewMod</dd>
<dd>$ rm -f configure.ac</dd></dl></dd>
<dd>3. Редагування файлу "module.cpp".
<dl><dd><i>Змінити імена функцій включення модуля згідно імені нового модуля</i>:
<dl><dd>"<b>TModule::SAt bd_Tmpl_module( int n_mod )</b>" — bd_NewMod_module</dd>
<dd>"<b>TModule *bd_Tmpl_attach( const TModule::SAt &amp;AtMod, const string &amp;source )</b>" — bd_NewMod_attach</dd></dl></dd>
<dd><i>Інформація про модуль у файлі "module.cpp", а саме ділянка:</i></dd></dl></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
//************************************************
//* Modul info!                                  *
#define MOD_ID          "NewMod"
#define MOD_NAME        _("DB NewMod")
#define MOD_TYPE        SDB_ID
#define VER_TYPE        SDB_VER
#define MOD_VER         "0.0.1"
#define AUTHORS         _("MyName MyFamily")
#define DESCRIPTION     _("BD NewMod description.")
#define MOD_LICENSE     "GPL2"
</pre>
<dl><dd>4. Редагування конфігурації збірки модуля у файлі "Makefile.am", до такого вигляду:</dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
EXTRA_DIST = *.h po/*

if NewModIncl
noinst_LTLIBRARIES = db_NewMod.la
db_NewMod_la_CXXFLAGS = -DMOD_INCL -fpic
db_NewMod_la_LIBTOOLFLAGS = --tag=disable-shared
db_NewMod_la_LDFLAGS = -module
else
oscd_modul_LTLIBRARIES = db_NewMod.la
db_NewMod_la_CXXFLAGS =
db_NewMod_la_LIBTOOLFLAGS = --tag=disable-static
db_NewMod_la_LDFLAGS = -module -avoid-version $(top_builddir)/src/liboscada.la
endif

db_NewMod_la_CXXFLAGS += $(NewMod_CFLAGS)
db_NewMod_la_LDFLAGS += $(NewMod_LDLAGS)
db_NewMod_la_SOURCES = module.cpp

I18N_mod = $(oscd_modulpref)NewMod
include ../../../../I18N.mk
</pre>
<dl><dd>5. Додання запису нового модуля в кінець секції підсистеми (у нас "&gt; DB modules"), конфігураційного файлу (OpenSCADA/configure.ac) складальної системи OpenSCADA:</dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
AX_MOD_DB_EN(NewMod,[disable or enable[=incl] build module DB.NewMod],disable,incl,
[
    # Код перевірки зовнішніх бібліотек модуля
])
</pre>
<dl><dd>6. Тепер новий модуль можна скласти у складі OpenSCADA, після переформування складальної системи:
<dl><dd>$ autoreconf -if</dd>
<dd>$ ./configure --enable-NewMod</dd>
<dd>$ make</dd></dl></dd>
<dd>7. Публікація. Формування патча з вашим модулем та відправка його розробникам OpenSCADA:
<dl><dd>$ cd OpenSCADA; make distclean; rm -f src/moduls/bd/NewMod/Makefile.in</dd>
<dd>$ svn add src/moduls/bd/NewMod</dd>
<dd>$ svn diff &gt; NewMod.patch</dd></dl></dd></dl>
<h3><span class="mw-headline" id=".D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D0.B7.D0.BE.D0.B2.D0.BD.D1.96.D1.88.D0.BD.D1.8C.D0.BE.D0.B3.D0.BE_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F_.D0.B4.D0.BE_OpenSCADA"><span class="mw-headline-number">1.2</span> Створення зовнішнього модуля до OpenSCADA</span></h3>
<p>Створення зовнішнього модуля до OpenSCADA може мати сенс у випадку розробки інтерфейсу інтеграції з комерційними системами, які вимагають закриття коду взаємодії, а також у випадку інших реалізацій комерційних інтерфейсів при яких модуль до OpenSCADA отримує статус окремого проекту, розповсюджується та підтримується незалежно, часто у вигляді бінарних збірок під конкретну платформу та версію OpenSCADA. Ліцензія таких модулів відповідно може бути будь-якою.
</p><p>Процедура створення нового зовнішнього модуля, на основі шаблону, багато в чому схожа на попередню процедуру та включає в себе кроки:
</p>
<dl><dd>1. Отримання вихідних текстів проекту OpenSCADA. Для зовнішнього модуля у якості джерела шаблону можна використати будь-які файли OpenSCADA версії більш 0.9 оскільки із них потрібно скопіювати тільки теку "=Tmpl=" та декілька файлів для збірки.</dd>
<dd>2. Копіювання теки шаблону з ім'ям нового модуля "NewMod" (наприклад, для підсистеми "БД"). Створення та копіювання потрібних файлів для зовнішнього модуля. В подальшому інформаційні файли проекту "COPYING", "NEWS", "README", "AUTHORS" та "ChangeLog" потрібно заповнити згідно сутності нового модуля.
<dl><dd>$ cp -r OpenSCADA/src/moduls/bd/=Tmpl= NewMod</dd>
<dd>$ touch NewMod/{NEWS,README,AUTHORS,ChangeLog}</dd>
<dd>$ cp OpenSCADA/I18N.mk NewMod/</dd></dl></dd>
<dd>3. Редагування інформації про модуль у файлі "module.cpp", аналогічно цьому пункту попереднього розділу.</dd>
<dd>4. Редагування конфігурації збірки модуля у файлі "Makefile.am", аналогічно цьому пункту попереднього розділу, окрім:</dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
# Замість "db_NewMod_la_LDFLAGS = -module -avoid-version $(top_builddir)/src/liboscada.la"
db_NewMod_la_LDFLAGS = -module -avoid-version
# Замість "include ../../../../I18N.mk"
include I18N.mk</pre>
<dl><dd>5. Редагування файлу конфігурації складальної системи "configure.ac":
<dl><dd>"<b>AC_INIT([DB.Tmpl],[0.0.1],[my@email.org])</b>" — інформація про модуль: ім'я, версія та email проекту.</dd>
<dd>"<b>AM_CONDITIONAL([TmplIncl],[test])</b>" — <b>AM_CONDITIONAL([NewModIncl],[test])</b></dd></dl></dd>
<dd>6. Встановлення пакету розробки OpenSCADA. У зв'язку з ти що модуль зовнішній та вихідні файли OpenSCADA потрібні тільки на першому етапі створення модуля то потрібно встановити пакет розробки OpenSCADA (openscada-devel), який містить заголовні файли та бібліотеки.</dd>
<dd>7. Тепер новий модуль можна скласти, після формування складальної системи:
<dl><dd>$ autoreconf -if</dd>
<dd>$ ./configure</dd>
<dd>$ make</dd></dl></dd></dl>
<h2><span class="mw-headline" id="API_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="mw-headline-number">2</span> API модуля</span></h2>
<p>API системи OpenSCADA для розробника OpenSCADA та модулів до неї вичерпно, у формальній формі, описано у відповідному документі <a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API" rel="nofollow noreferrer noopener" target="_blank">API системи OpenSCADA</a>, який має бути завжди під рукою при розробці для OpenSCADA. В цьому ж документі ухил зроблено на детальне роз'яснення основних моментів модульного API.
</p><p>Загальним для всіх модулів є наслідування кореневого об'єкта-класу модуля від класу <i>TModule</i>, за посередництвом класу модульної підсистеми, а це означає що є загальна частина інтерфейсу модуля який розглянемо нижче. В цілому, для представлення собі архітектури модулів у контексті загальної архітектури OpenSCADA, наполегливо рекомендується мати перед очима <a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API/part1/files?get=oscd_uml_classdep.png" rel="nofollow noreferrer noopener" target="_blank">загальну діаграму класів OpenSCADA</a>
</p><p>Точкою входу будь-якого модуля є функції:
</p>
<ul><li> <i>TModule::SAt module( int n_mod )</i>, <i>TModule::SAt bd_DBF_module( int n_mod )</i> — використовуються для сканування переліку та інформації про всі модулі у бібліотеці. Перша функція використовується під час реалізації модулів у зовнішній поділюваній бібліотеці, а друга під час лінкування їх у ядро OpenSCADA.</li>
<li> <i>TModule *attach( const TModule::SAt &amp;AtMod, const string &amp;source )</i>, <i>TModule *bd_Tmpl_attach( const TModule::SAt &amp;AtMod, const string &amp;source )</i> — використовується для безпосереднього підключення-відкриття обраного модуля, шляхом створення кореневого об'єкта модуля, успадкованого від <i>TModule</i>. Перша функція використовується під час реалізації модулів у зовнішній поділюваній бібліотеці, а друга під час лінкування їх у ядро OpenSCADA.</li></ul>
<p>Для зручності прямої адресації до кореневого об'єкта модуля із будь-якого об'єкта модуля нижче за ієрархією рекомендується визначити глобальну змінну "mod", у області імен модуля, з ініціалізацією її у конструкторі кореневого об'єкта модуля. Також, для прозорого перекладу текстових повідомлень модуля, рекомендується визначити шаблон функції виклику перекладу повідомлень модуля "<b>_({Повідомлення})</b>", як:
</p>
<pre style="white-space: pre-wrap;">
#undef _
#define _(mess) mod-&gt;I18N(mess)</pre>
<p>У конструкторі кореневого об'єкту модуля, успадкованого від <i>TModule</i>, потрібно встановити основну інформацію модуля викликом функції <i>void modInfoMainSet({Ім'я}, {Тип}, {Версія}, {Автори}, {Опис}, {Ліцензія}, {Джерело})</i>, після ініціалізації швидкого посилання "mod" на кореневий об'єкт цього модуля.
</p><p>А також ініціювати оточення модуля за допомогою функцій:
</p>
<ul><li> <i>void modFuncReg( ExpFunc *func );</i> — Реєстрація експортованої функції модуля. Ця функція частина механізму виклику міжмодульної взаємодії, яка реєструє внутрішню функцію модуля для зовнішнього виклику за назвою функції та її вказівником відносно об'єкта модуля.</li></ul>
<p>Подальше отримання файлу шаблону перекладів "po/NewMod.pot" текстових повідомлень "<b>_({Повідомлення})</b>", а також обновлення-актуалізація файлів вже існуючих перекладів "po/{en|ru|uk|de|...}.po" здійснюється командою у теці модуля "<b>$ make messages</b>".
</p><p>З метою загального управління модулем у класі <i>TModule</i> передбачено низку віртуальних функцій, які можуть бути визначені у кореневому об'єкту модуля з реалізацією потрібної реакції на команди ядра OpenSCADA до модуля:
</p>
<ul><li> <i>void load_( );</i> — Завантаження модуля. Викликається на стадії завантаження конфігурації модуля із конфігураційного файлу або БД.</li>
<li> <i>void save_( );</i> — Збереження модуля. Викликається на стадії збереження конфігурації модуля у конфігураційному файлі або БД, зазвичай за ініціативою користувача.</li>
<li> <i>void modStart( );</i> — Запуск модуля. Викликається на стадії запуску задачі виконання фонових функцій модуля, якщо такі модулем надаються.</li>
<li> <i>void modStop( );</i> — Зупинка модуля. Викликається на стадії зупинки задач виконання фонових функцій модуля, якщо такі модулем надаються.</li>
<li> <i>void modInfo( vector&lt;string&gt; &amp;list );</i> — Запит переліку інформаційних властивостей модуля. Цією функцією класу <i>TModule</i> надається стандартний набір властивостей модуля ("Module", "Name", "Type", "Source", "Version", "Author", "Description", "License"), який може бути розширено додатковими властивостями цього модуля.</li>
<li> <i>string modInfo( const string &amp;name );</i> — Запит вказаного елементу інформації. Здійснюється обробка запитів по додатковим властивостям даного модуля.</li>
<li> <i>void postEnable( int flag );</i> — Підключення модуля до динамічного дерева об'єктів. Викликається фактично після включення модуля.</li>
<li> <i>void perSYSCall( unsigned int cnt );</i> — Виклик із системного потоку, з періодичністю 10 секунд та секундним лічильником <i>cnt</i>. Може використовуватися для виконання періодичних-рідких сервісних процедур.</li></ul>
<p>Всі інтерфейсні об'єкти модулів успадковують клас вузла <i>TCntrNode</i>, який надає механізм <a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API#h919-1" rel="nofollow noreferrer noopener" target="_blank">інтерфейсу управління</a>, однієї із задач якого є надання інтерфейсу конфігурації об'єкту в будь-якому конфігураторі OpenSCADA. Для вирішення задач нового модуля може знадобитися розширення параметрів конфігурації, що робиться у віртуальній функції <i>void cntrCmdProc( XMLNode *opt );</i>. Вміст цієї функції, який додає властивість, у найпростішому випадку має вигляд:
</p>
<pre style="white-space: pre-wrap;">
void MBD::cntrCmdProc( XMLNode *opt )
{
    //&gt; Get page info
    if(opt-&gt;name() == "info")
    {
        TBD::cntrCmdProc(opt);
        ctrMkNode("comm",opt,-1,"/prm/st/end_tr",_("Close opened transaction"),RWRWRW,"root",SDB_ID);
        return;
    }
    //&gt; Process command to page
    string a_path = opt-&gt;attr("path");
    if(a_path == "/prm/st/end_tr" &amp;&amp; ctrChkNode(opt,"set",RWRWRW,"root",SDB_ID,SEC_WR)) transCommit();
    else TBD::cntrCmdProc(opt);
}
</pre>
<p>Перша половина цієї функції обслуговує інформаційні запити "info", з переліком та властивостями полів конфігурації. Друга половина обслуговує всі інші команди, на отримання, встановлення значення та інше. Виклик <i>TBD::cntrCmdProc(opt);</i> використовується для отримання успадкованого інтерфейсу. Детальніше про призначення використаних функцій дивіться у <a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API#h919-1" rel="nofollow noreferrer noopener" target="_blank">інтерфейсі управління</a>, а також у вихідних текстах існуючих модулей.
</p><p>Крім функції інтерфейсу управління об'єкт <i>TCntrNode</i> надає уніфіковані механізми контролю за модифікацією конфігурації об'єкта, завантаження та збереження конфігурації у сховищі. Для здійснення встановлення прапорця модифікації даних об'єкта можна використовувати функції <i>modif()</i> та <i>modifG()</i>, а специфічні для модуля дії по завантаженню та збереженню можна розташовувати у віртуальні функції:
</p>
<ul><li> <i>void load_( );</i> — Завантаження об'єкта із сховища.</li>
<li> <i>void save_( );</i> — Збереження об'єкта у сховищі.</li></ul>
<p>Типово, робота з конфігурацією здійснюється за посередництвом об'єкта <i><a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API#h917-2" rel="nofollow noreferrer noopener" target="_blank">TConfig</a></i>, яких містить набір вказаних властивостей. Для прямого відображення властивостей об'єкта модуля він успадковується від <i>TConfig</i>, а нові властивості додаються командою:
</p>
<pre style="white-space: pre-wrap;">
fldAdd(new TFld("PRM_BD",_("Parameters cache table"),TFld::String,TFld::NoFlag,"30",""));</pre>
<p>Завантаження та збереження властивостей, вказаних у об'єкті <i>TConfig</i>, із/у сховище здійснюється командами:
</p>
<pre style="white-space: pre-wrap;">
SYS-&gt;db().at().dataGet(fullDB(),owner().nodePath()+"DAQ",*this);
SYS-&gt;db().at().dataSet(fullDB(),owner().nodePath()+"DAQ",*this);</pre>
<p>Де:
</p>
<ul><li> <i>fullDB()</i> — повне ім'я БД-сховища, у вигляді "<b>{DBMod}.{DBName}.{Table}</b>";</li>
<li> <i>owner().nodePath()+"DAQ"</i> — сумарний шлях до вузла об'єкта — представника таблиці у конфігураційному файлі;</li>
<li> <i>*this</i> — цей об'єкт, успадковується від <i>TConfig</i>.</li></ul>
<p>Для розміщення налагоджувальних повідомлень, <a href="Program_manual.html#Config" title="Special:MyLanguage/Documents/Program manual">у контексті загальної концепції налаштувань</a>, потрібно використовувати функцію <i>mess_debug()</i> з умовою виклику по ділянці вихідного тексту програми:
</p>
<ul><li> <i>рідко викликувана ділянка:</i> прямий виклик функції <i>mess_debug(...)</i>;</li>
<li> <i>часто викликувана ділянка:</i> умовний виклик: <i>if(mess_lev() == TMess::Debug) mess_debug(...);</i></li>
<li> <i>критичні до продуктивності ділянки коду:</i> огортання у визначення OSC_DEBUG:</li></ul>
<pre style="white-space: pre-wrap;">
#ifdef OSC_DEBUG
  mess_debug(...);
#endif
</pre>
<h3><span class="mw-headline" id=".D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.91.D0.B0.D0.B7.D0.B8_.D0.94.D0.B0.D0.BD.D0.B8.D1.85_.28.D0.91.D0.94.29.22"><span class="mw-headline-number">2.1</span> Модуль підсистеми "Бази Даних (БД)"</span></h3>
<p>Модуль даного типа призначено для інтеграції OpenSCADA зі СУБД, яку реалізується модулем.
</p><p>Інтерфейс OpenSCADA для обслуговування запитів до БД представлено об'єктами та віртуальними функціями викликів із ядра OpenSCADA:
</p>
<ul><li> <i>TTypeBD-&gt;TModule</i> — Кореневий об'єкт модуля підсистеми "БД":
<ul><li> <i>TBD *openBD( const string &amp;id );</i> — Викликається при відкритті або створені нового об'єкта БД з ідентифікатором <i>id</i> даним модулем.</li></ul></li>
<li> <i>TBD</i> — Об'єкт бази даних:
<ul><li> <i>void enable( );</i> — Включення БД.</li>
<li> <i>void disable( );</i> — Відключення БД.</li>
<li> <i>void load_( );</i> — Завантаження БД із загального сховища конфігурації.</li>
<li> <i>void save_( );</i> — Збереження БД у загальному сховищі конфігурації.</li>
<li> <i>void allowList( vector&lt;string&gt; &amp;list );</i> — Запит переліку <i>list</i> таблиць у БД.</li>
<li> <i>void sqlReq( const string &amp;req, vector&lt; vector&lt;string&gt; &gt; *tbl = NULL, char intoTrans = EVAL_BOOL );</i> — Обробка SQL-запиту <i>req</i> до БД та отримання результату у вигляді таблиці <i>tbl</i>, якщо запит вибірки та вказівник ненульовий. При встановлені <i>intoTrans</i> у "true" для запиту мусить бути відкрита транзакція, у "false" закрита. Ця функція має реалізовуватися для СУБД, які підтримують SQL-запити.</li>
<li> <i>void transCloseCheck( );</i> — Періодично викликається функція для перевірки транзакцій та закриття старих або які містять багато запитів.</li>
<li> <i>TTable *openTable( const string &amp;table, bool create );</i> — Викликається при відкритті або створені нового об'єкта таблиці.</li></ul></li>
<li> <i>TTable</i> — Об'єкт таблиці у базі даних:
<ul><li> <i>void fieldStruct( TConfig &amp;cfg );</i> — Отримання поточної структури таблиці у об'єкті <i>TConfig</i>.</li>
<li> <i>bool fieldSeek( int row, TConfig &amp;cfg, vector&lt; vector&lt;string&gt; &gt; *full = NULL );</i> — Послідовне сканування записів таблиці, перебором <i>row</i> та повернення "false" по закінченню, з адресацією по активним, <i><a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API#h917-2" rel="nofollow noreferrer noopener" target="_blank">keyUse()</a></i>, ключовим полям. <i>full</i> визначається перед запитом, для предзавантаженням повної відповіді, із витягненням наступних записів звідти.</li>
<li> <i>void fieldGet( TConfig &amp;cfg );</i> — Запит вказаного у об'єкті <i>TConfig</i> запису, з адресацією по ключовим полям.</li>
<li> <i>void fieldSet( TConfig &amp;cfg );</i> — Передача вказаного у об'єкті <i>TConfig</i> запису, з адресацією по ключовим полям.</li>
<li> <i>void fieldDel( TConfig &amp;cfg );</i> — Видалення вказаного запису по ключовим полям об'єкта <i>TConfig</i>.</li></ul></li></ul>
<h3><span class="mw-headline" id=".D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.A2.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D0.B8.22"><span class="mw-headline-number">2.2</span> Модуль підсистеми "Транспорти"</span></h3>
<p>Модуль даного типу призначено для забезпечення комунікації OpenSCADA за посередництвом інтерфейсу, часто мережевого, який реалізується модулем.
</p><p>Програмний інтерфейс OpenSCADA, для обслуговування вхідних та вихідних запитів через мережевий інтерфейс, представлено об'єктами та віртуальними функціями викликів із ядра OpenSCADA:
</p>
<ul><li> <i>TTypeTransport-&gt;TModule</i> — Кореневий об'єкт модуля підсистеми "Транспорти":
<ul><li> <i>TTransportIn *In( const string &amp;name, const string &amp;db );</i> — Викликаються при відкритті або створені нового об'єкта вхідного транспорту <i>name</i>, даним модулем, зі сховищем у <i>db</i>.</li>
<li> <i>TTransportOut *Out( const string &amp;name, const string &amp;db );</i> — Викликаються при відкритті або створені нового об'єкта вихідного транспорту <i>name</i>, даним модулем, зі сховищем у <i>db</i>.</li></ul></li>
<li> <i>TTransportIn</i> — Об'єкт транспорту обробки вхідних запитів, функція серверу. Вхідні запити, отримані модулем через реалізацію мережевого інтерфейсу повинні направлятися до вказаного у конфігурації вхідного протоколу <i>protocol()</i>, за посередництвом функції <i><a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API#h911-4" rel="nofollow noreferrer noopener" target="_blank">mess()</a></i>:
<ul><li> <i>string getStatus( );</i> — Виклики для отримання специфічного статусу інтерфейсу.</li>
<li> <i>void setAddr( const string &amp;addr );</i> — Встановлення адреси транспорту. Може перевизначатися для обробки та перевірки специфічного для модуля формату адреси транспорту.</li>
<li> <i>void start();</i> — Запуск транспорту. При запуску вхідного транспорту зазвичай створюється задача, яка очікує запитів ззовні.</li>
<li> <i>void stop();</i> — Зупинка транспорту.</li></ul></li>
<li> <i>TTransportOut</i> — Об'єкт транспорту обробки вихідних запитів, функція клієнта:
<ul><li> <i>string getStatus( );</i> — Виклик для отримання специфічного статусу інтерфейсу.</li>
<li> <i>void setAddr( const string &amp;addr );</i> — Встановлення адреси транспорту. Може перевизначатися для обробки та перевірки специфічного для модуля формату адреси транспорту.</li>
<li> <i>void start( );</i> — Запуск транспорту. Під час запуску вихідного транспорту здійснюється фактичне підключення до віддаленої станції, для інтерфейсів які працюють по підключенню. У цей час можливі помилки, якщо підключення не можливе, та транспорт мусить повернутися у зупинений стан.</li>
<li> <i>void stop( );</i> — Зупинка транспорту.</li>
<li> <i>int messIO( const char *obuf, int len_ob, char *ibuf = NULL, int len_ib = 0, int time = 0, bool noRes = false );</i> — Обслуговування запитів із ядра OpenSCADA на відправку даних через транспорт. Час очікування <i>time</i> з'єднання визначається у мілісекундах, при ненульовому значенні має заміщувати однойменний таймаут транспорту в його загальних налаштуваннях. <i>noRes</i> використовується протоколами для монопольного блокування транспорту на час роботи з ним та попередження власного блокування функцією. Пакет для відправки указується у буфері <i>obuf</i> довжиною <i>len_ob</i>, а у <i>ibuf</i> та <i>len_ib</i> указується буфер та його розмір для відповіді. Вихідний буфер <i>obuf</i> може бути порожнім (NULL) якщо потрібно перевірити наявність продовження відповіді або відповідей, які надходять без запитів, режим віщання. Якщо не вказано буфер для відповіді (NULL) то очікування відповіді не буде здійснюватися.</li></ul></li></ul>
<h3><span class="mw-headline" id=".D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.A2.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D0.BD.D1.96_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D0.B8.22"><span class="mw-headline-number">2.3</span> Модуль підсистеми "Транспортні протоколи"</span></h3>
<p>Модуль даного типу призначено для забезпечення протокольного шару комунікацій OpenSCADA, який реалізується модулем, як для доступу к даним зовнішніх систем, так і даних OpenSCADA, із зовнішніх систем.
</p><p>Програмний інтерфейс OpenSCADA, для реалізації протокольного шару, представлено об'єктами та віртуальними функціями викликів із ядра OpenSCADA:
</p>
<ul><li> <i>TProtocol-&gt;TModule</i> — Кореневий об'єкт модуля підсистеми "Протоколи":
<ul><li> <i>void itemListIn( vector&lt;string&gt; &amp;ls, const string &amp;curIt = "" );</i> — Перелік піделементів у вхідному протоколу, якщо протокол їх передбачає. Використовується при обранні у конфігурації об'єкту вхідного транспорту.</li>
<li> <i>void outMess( XMLNode &amp;io, TTransportOut &amp;tro );</i> — Реалізована передача даних об'єктами ядра OpenSCADA у дереві XML <i>in</i> віддаленій системі за посередництвом транспорту <i>tro</i> и поточного вихідного протоколу. Надання даних у дереві XML <i>in</i> не уніфіковано та специфічно до логічної структури протоколу. Ці дані серіалізуються (переводяться у послідовність байтів згідно протоколу) та надсилаються через вказаний вихідний транспорт <i>tro</i>, функцією <i><a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API#h910-5" rel="nofollow noreferrer noopener" target="_blank">messIO()</a></i>, вище.</li>
<li> <i>TProtocolIn *in_open( const string &amp;name )</i> — Викликається при відкритті або створені нового об'єкта вхідного транспортного протоколу <i>name</i>, цим модулем.</li></ul></li>
<li> <i>TProtocolIn</i> — Об'єкт протоколу обробки вхідних запитів із об'єкта вхідного транспорту <i><a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API#h910-4" rel="nofollow noreferrer noopener" target="_blank">TTransportIn</a></i>, вище. На кожний сеанс вхідного запиту створюється об'єкт пов'язаного вхідного протоколу, який залишається живим до моменту завершення повного сеансу "Запит-&gt;Відповідь". Адреса транспорту, який відкрив екземпляр протоколу, вказано у <i>srcTr()</i>:
<ul><li> <i>bool mess( const string &amp;request, string &amp;answer, const string &amp;sender );</i> — Передача послідовності даних <i>request</i> об'єкту протоколу для їх розбору згідно з реалізацією протоколу, з вказанням адреси того хто запитав у <i>sender</i>. Ця функція протоколу мусить обробити запит, сформувати відповідь у <i>answer</i> та повернути "false" у випадку повноти запиту. У випадку якщо запит поступив не весь потрібно повертати "true" для індикації транспорту "очікувати завершення", при цьому першу частину запиту потрібно зберігати у контексті об'єкта протоколу.</li></ul></li></ul>
<h3><span class="mw-headline" id=".D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.97.D0.B1.D1.96.D1.80_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85_.28DAQ.29.22"><span class="mw-headline-number">2.4</span> <span id="DAQ" title="#DAQ">Модуль підсистеми "Збір даних (DAQ)"</span></span></h3>
<p>Модуль цього типу призначено для отримання даних реального часу зовнішніх систем або їх формування, у обчислювачах, які реалізуються модулем.
</p><p>Програмний інтерфейс OpenSCADA для реалізації доступу до даних реального часу представлено об'єктами та віртуальними функціями викликів із ядра OpenSCADA:
</p>
<ul><li> <i>TTypeDAQ-&gt;TModule</i> — Кореневий об'єкт модуля підсистеми "Збір даних":
<ul><li> <i>void compileFuncLangs( vector&lt;string&gt; &amp;ls );</i> — Запит переліку мов користувацького програмування, які підтримуються модулем в <i>ls</i>.</li>
<li> <i>void compileFuncSynthHighl( const string &amp;lang, XMLNode &amp;shgl );</i> — Запит правил підсвічення синтаксису <i>shgl</i> вказаної мови користувацького програмування <i>lang</i>.</li>
<li> <i>string compileFunc( const string &amp;lang, TFunction &amp;fnc_cfg, const string &amp;prog_text );</i> — Виклик компіляції користувацької процедури у <i>prog_text</i> та створення об'єкту виконання функції на основі <i>fnc_cfg</i> для вказаної мови користувацького програмування <i>lang</i> цього модуля. Повертається адреса до скомпільованого об'єкту функції, готового для виконання.</li>
<li> <i>bool redntAllow( );</i> — Ознака підтримки механізмів резервування модулів. Повинен перевизначатися та повертати "true" у випадку підтримки, інакше "false".</li>
<li> <i>TController *ContrAttach( const string &amp;name, const string &amp;daq_db );</i> — Викликається при відкритті або створені нового об'єкта контролера <i>name</i> цим модулем зі сховищем у <i>db</i>.</li></ul></li>
<li> <i>TController</i> — Об'єкт контролера джерела даних. У контексті даного об'єкту за звичай запускається задача періодичного або за розкладом опиту даних реального часу одного фізичного контролера або фізично відокремленого блоку даних. У випадку отримання даних пакетами вони поміщаються безпосередньо до архіву, пов'язаного з атрибутом параметра <i><a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API#h903-8" rel="nofollow noreferrer noopener" target="_blank">TVAl::arch()</a></i>, а поточне значення встановлюється функцією <i><a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API#h903-8" rel="nofollow noreferrer noopener" target="_blank">TVAl::set()</a></i>, с атрибутом "sys"=true:
<ul><li> <i>string getStatus( );</i> — Виклик для отримання специфічного стану контролера.</li>
<li> <i>void enable_( );</i> — Включення контролеру. Зазвичай тут здійснюється ініціалізація об'єктів параметрів та їх інтерфейсу, в особі атрибутів, які інколи можуть запитуватися у асоційованого віддаленого джерела.</li>
<li> <i>void disable_( );</i> — Відключення контролеру.</li>
<li> <i>void start_( );</i> — Запуск контролеру. Зазвичай тут створюється та запускається задача періодичного або за розкладом опитування.</li>
<li> <i>void stop_( );</i> — Зупинка контролеру.</li>
<li> <i>void redntDataUpdate( bool firstArchiveSync = false );</i> — Виконання операції отримання даних із резервної станції. Викликається автоматично завданням обслуговування схеми резервування та перед запуском для синхронізації архівів зі встановленим параметром <i>firstArchiveSync</i>.</li>
<li> <i>TParamContr *ParamAttach( const string &amp;name, int type );</i> — Викликається при відкритті або створені нового об'єкту параметра <i>name</i>, з типом <i>type</i>.</li></ul></li>
<li> <i>TParamContr-&gt;TValue</i> — Об'єкт параметра контролера джерела даних. Містить атрибути з реальними даними у наборі визначеному фізично доступними даними. Значення у атрибути попадають із задачі опитування контролера, при асинхронному режимі, або запитуються під час звернення, при синхронному режимі, за посередництвом методів успадкованого типу <i><a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API#h903-7" rel="nofollow noreferrer noopener" target="_blank">TValue</a></i>, даного об'єкта:
<ul><li> <i>void enable( );</i> — Включити параметр. Здійснюється формування набору атрибутів та заповнення їх значенням недостовірності.</li>
<li> <i>void disable( );</i> — Відключити параметр.</li>
<li> <i>void setType( const string &amp;tpId );</i> — Викликається для зміни типу параметра <i>tpId</i> та може бути оброблено у об'єкті модуля, для зміни власних даних.</li>
<li> <i>TVal* vlNew( );</i> — Викликається при створені нового атрибута. Може бути перевизначено для реалізації особливої поведінки у межах свого, успадкованого від <i>TVal</i>, класу при доступі до атрибуту.</li>
<li> <i>void vlSet( TVal &amp;val, const TVariant &amp;pvl );</i> — Викликається для атрибуту з прямим режимом запису <i>TVal::DirWrite</i> (синхронний режим або запис до внутрішнього буфера об'єкта) при встановленні значення з метою безпосереднього запису значення до фізичного контролера або буфера об'єкта.</li>
<li> <i>void vlGet( TVal &amp;val );</i> — Викликається для атрибута з прямим режимом читання <i>TVal::DirRead</i> (синхронний режим або читання із внутрішнього буфера об'єкта) при читанні значень з метою безпосереднього читання значення із фізичного контролера або буфера об'єкта.</li>
<li> <i>void vlArchMake( TVal &amp;val );</i> — Викликається при створені архіву значень з атрибутом <i>val</i> у якості джерела з метою ініціалізації якісних характеристик буфера архіву згідно особливостям джерела даних та їх опитування.</li></ul></li></ul>
<p>Для спеціалізованої діагностики можна поміщати налагоджувальні повідомлення для умови <a class="external" href="http://oscada.org/wiki/File:QTCfg_subsys_daq_mod_cntr_diagn_uk.png" title="File:QTCfg subsys daq mod cntr diagn uk.png">вибору рівня діагностики "Налаштування (0)" (RU)</a>: <i>if(messLev() == TMess::Debug) mess_debug_(...);</i>.
</p>
<h3><span class="mw-headline" id=".D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.90.D1.80.D1.85.D1.96.D0.B2.D0.B8.22"><span class="mw-headline-number">2.5</span> Модуль підсистеми "Архіви"</span></h3>
<p>Модуль цього типу призначено для архівування та ведення історії, повідомлень OpenSCADA та даних реального часу, отриманих у підсистемі "Збір даних", засобом який реалізується модулем.
</p><p>Програмний інтерфейс OpenSCADA, для реалізації доступу до архівних даних, представлено об'єктами та віртуальними функціями викликів із ядра OpenSCADA:
</p>
<ul><li> <i>TTypeArchivator-&gt;TModule</i> — Кореневий об'єкт модуля підсистеми "Архіви":
<ul><li> <i>TMArchivator *AMess(const string &amp;id, const string &amp;db );</i> — Викликається при відкритті або створені нового об'єкта архіватору повідомлень <i>id</i> даним модулем зі сховищем у <i>db</i>.</li>
<li> <i>TVArchivator *AVal(const string &amp;id, const string &amp;db );</i> — Викликається при відкритті або створені нового об'єкта архіватору значень <i>id</i> даним модулем зі сховищем у <i>db</i>.</li></ul></li>
<li> <i>TMArchivator</i> — Об'єкт архіватору повідомлень з реалізованим засобом архівування та розташуванням сховища:
<ul><li> <i>void start( );</i> — Запуск архіватора. Архіватор починає приймати повідомлення та розташовувати їх у сховищі.</li>
<li> <i>void stop( );</i> — Зупинка архіватору.</li>
<li> <i>time_t begin( );</i> — Початок даних у архіваторі, згідно поточного стану сховища.</li>
<li> <i>time_t end( );</i> — Кінець даних у архіваторі, згідно поточному стану сховища.</li>
<li> <i>void put( vector&lt;TMess::SRec&gt; &amp;mess );</i> — Виклик на розташування повідомлень <i>mess</i> у сховищі.</li>
<li> <i>void get( time_t b_tm, time_t e_tm, vector&lt;TMess::SRec&gt; &amp;mess, const string &amp;category = "", char level = 0, time_t upTo = 0 );</i> — Запит повідомлень <i>mess</i> у архіві за проміжок часу <i>b_tm</i> ... <i>e_tm</i>, згідно шаблону категорії <i>category</i> та рівню з обмеженням на час запиту до <i>upTo</i>.</li></ul></li>
<li> <i>TVArchivator</i> — Об'єкт архіватора значень з реалізованим способом архівування та розташуванням сховища:
<ul><li> <i>void setValPeriod( double per );</i> — Викликається при зміні періодичності значень архіватора.</li>
<li> <i>void setArchPeriod( int per );</i> — Викликається при зміні періодичності архівування.</li>
<li> <i>void start( );</i> — Запуск архіватору. Архіватор починає приймати повідомлення та розташовувати їх у сховищі.</li>
<li> <i>void stop( bool full_del = false );</i> — Зупинка архіватору з можливістю повного видалення його даних у сховищі, якщо встановлено <i>full_del</i>.</li>
<li> <i>TVArchEl *getArchEl( TVArchive &amp;arch );</i> — Запит об'єкта-представника архіву <i>arch</i>, який обслуговується архіватором.</li></ul></li>
<li> <i>TVArchEl</i> — Об'єкт представника архіву значень у сховищі архіватору:
<ul><li> <i>void fullErase( );</i> — Викликається для повного видалення частини архіву у архіваторі.</li>
<li> <i>int64_t end( );</i> — Час закінчення архіву у архіваторі.</li>
<li> <i>int64_t begin( );</i> — Час початку архіву в архіваторі.</li>
<li> <i>TVariant getValProc( int64_t *tm, bool up_ord );</i> — Запит на обробку отримання одного значення із архіву, за час <i>tm</i> та доведенням до верхнього значення у ґратці дискретизації <i>up_ord</i>.</li>
<li> <i>void getValsProc( TValBuf &amp;buf, int64_t beg, int64_t end );</i> — Запит на обробку модулем отримання даних групи значень <i>buf</i> за визначений проміжок часу.</li>
<li> <i>void setValsProc( TValBuf &amp;buf, int64_t beg, int64_t end );</i> — Запит на обробку модулем розташування даних групи значень <i>buf</i> за визначений проміжок часу.</li></ul></li></ul>
<h3><span class="mw-headline" id=".D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.9A.D0.BE.D1.80.D0.B8.D1.81.D1.82.D1.83.D0.B2.D0.B0.D1.86.D1.8C.D0.BA.D1.96_.D1.96.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.B8_.28UI.29.22"><span class="mw-headline-number">2.6</span> Модуль підсистеми "Користувацькі інтерфейси (UI)"</span></h3>
<p>Модуль цього типу призначено для надання користувацького інтерфейсу, засобом який реалізується модулем. Кореневим об'єктом модуля даної підсистеми є <i>TUI-&gt;TModule</i>, який не містить специфічних інтерфейсів, а користувацький інтерфейс формується згідно із реалізованої концепції та механізмами, наприклад, бібліотеки графічних примітивів.
</p>
<h3><span class="mw-headline" id=".D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D0.BF.D1.96.D0.B4.D1.81.D0.B8.D1.81.D1.82.D0.B5.D0.BC.D0.B8_.22.D0.A1.D0.BF.D0.B5.D1.86.D1.96.D0.B0.D0.BB.D1.8C.D0.BD.D1.96.22"><span class="mw-headline-number">2.7</span> Модуль підсистеми "Спеціальні"</span></h3>
<p>Модуль цього типу призначено для реалізації специфічних функцій, які не увійшли до жодної з вищеперелічених підсистем, реалізованим модулем засобом. Кореневим об'єктом модуля даної підсистеми є <i>TSpecial-&gt;TModule</i>, який не містить специфічних інтерфейсів, а специфічні функції формуються згідно їх вимогами з використанням всіх можливостей API OpenSCADA.
</p>





</div><table style="border-top: dotted 2px #999999; margin-top: 20pt; color: gray;" width="100%"><tr><td style="text-align: left;" width="40%"><a href="http://oscada.org/wiki/Documents/How_to/Create_module/uk">Documents/How_to/Create_module/uk</a> - <a href="http://oscada.org/en/main/about-the-project/licenses/">GFDL</a></td><td style="text-align: center;">January 2021</td><td style="text-align: right;" width="40%">OpenSCADA 1+r2728</td></tr></table></body>
</html>