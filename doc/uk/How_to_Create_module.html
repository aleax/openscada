<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="UTF-8" />
<title>Документація/Як зробити/Створити модуль - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../en/files/doc.css" rel="stylesheet" /></head>
<body><div class="floatright"><a href="index.html"><img src="../en/files/index.png" /></a></div><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="uk">Документація/Як зробити/Створити модуль</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="uk"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Documents%2FHow+to%2FCreate+module&amp;action=page&amp;filter=&amp;language=uk" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Documents/How_to/Create_module" title="Documents/How to/Create module">Documents/How to/Create module</a> and the translation is 100% complete.</div><hr /><div class="mw-pt-languages" dir="ltr" lang="en"><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="../en/How_to_Create_module.html" title="Documents/How to/Create module (100% translated)">English</a>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--stub" href="../ru/How_to_Create_module.html" title="Документация/Как сделать/Создать модуль (8% translated)">mRussian</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">Українська</span></div></div>
<div style="float:right; border:1px solid gray; width:300px; padding:2px; margin-left: 10pt; margin-bottom: 10pt;">
<ul><li> <b>Автор:</b> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Роман Савоченко</a></li>
<li> <b>Спонсорування, повної ревізії на 1.8 <span title="людино-днів, 1ЛД — 10 годин">ЛД<sup style="color: blue">[!]</sup></span>:</b> SINGE SOFTWARE</li>
<li> <b>Початково створено:</b> у <a class="external text" href="http://wiki.oscada.org/HomePageUk/Doc/ModuleBuild" rel="nofollow noreferrer noopener" target="_blank">старій Wiki</a> </li></ul>
</div>
<p>Цей посібник покликано допомогти у створені модулів для OpenSCADA. Створення модуля може знадобитися у випадку бажання додати підтримку нового джерела даних або іншого розширення до OpenSCADA. Оскільки OpenSCADA є гранично модульною то всі інтерфейси взаємодії із зовнішнім середовищем здійснюється за посередництвом розширення модулями типів:
</p>
<ul><li> бази даних;</li>
<li> комунікаційні інтерфейси, транспорти;</li>
<li> протоколи комунікаційних інтерфейсів;</li>
<li> джерела даних та збір даних;</li>
<li> архіви-історія (повідомлень та значень);</li>
<li> інтерфейси користувача (GUI, TUI, WebGUI, speach, signal ...);</li>
<li> додаткові модулі, спеціальні.</li></ul>
<p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../en/files/At.png" width="22" /></a> Для створення модулів до OpenSCADA необхідні знання програмування на мові C/C++, складальної системи <a class="external text" href="http://en.wikipedia.org/wiki/GNU_build_system" rel="nofollow noreferrer noopener" target="_blank">AutoTools</a>, а також базові знання ОС Linux та використовуваного дистрибутиву Linux.
</p><p>Для подальшого розміщення розробленого модуля до <a class="external text" href="http://oscada.org/websvn/listing.php?repname=OpenSCADA" rel="nofollow noreferrer noopener" target="_blank">репозиторію дерева вихідних текстів OpenSCADA</a> ви маєте виконати наступне та дотримуватися наступних вимог:
</p>
<ul><li> бути правовласником або автором коду цього модуля та розповсюджувати його за вільною ліцензією, віддаючи перевагу GPL;</li>
<li> приготувати та зберігати код модуля як архів окремої теки модуля будь якої з підсистем OpenSCADA із вимогам до вмісту:
<ul><li> вихідні тексти модуля на початку кожного файлу мають включати коректну інформацію прав копіювання, бути написаними та відформатованими згідно до якоїсь системи де перевагу треба надавати <a href="../en/API.html#CodeDesign" title="Special:MyLanguage/Documents/API">стилю форматуванню основних модулів OpenSCADA</a>;</li>
<li> файли локалізації модулів також мають бути коректними, актуальними та відповідно відформатованими.</li></ul></li>
<li> написати коротку інформаційну сторінку модуля для розташування її на <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Modules" title="Special:MyLanguage/Modules">OpenSCADA Wiki</a> таким-же чином, як і інші модулів поряд;</li>
<li> для розташування цього модуля написати прямий запит у темі форуму "<a class="external text" href="http://oscada.org/ua/forum/topics/rozrobka_openscada/" rel="nofollow noreferrer noopener" target="_blank">Розробка OpenSCADA</a>", включаючи доказ працездатності від розробника OpenSCADA або коротке демонстраційним відео.</li></ul>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D0.9D.D0.BE.D0.B2.D0.BE.D0.B3.D0.BE_.D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="tocnumber">1</span> <span class="toctext">Створення Нового Модуля</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#.D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D1.83_.D0.B4.D0.B5.D1.80.D0.B5.D0.B2.D1.96_.D0.B2.D0.B8.D1.85.D1.96.D0.B4.D0.BD.D0.B8.D1.85_.D1.82.D0.B5.D0.BA.D1.81.D1.82.D1.96.D0.B2_.D0.BF.D1.80.D0.BE.D1.94.D0.BA.D1.82.D1.83_OpenSCADA"><span class="tocnumber">1.1</span> <span class="toctext">Створення у дереві вихідних текстів проєкту OpenSCADA</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#.D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D0.B7.D0.BE.D0.B2.D0.BD.D1.96.D1.88.D0.BD.D1.8C.D0.BE.D0.B3.D0.BE_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F_.D0.B4.D0.BE_OpenSCADA"><span class="tocnumber">1.2</span> <span class="toctext">Створення зовнішнього модуля до OpenSCADA</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#API_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="tocnumber">2</span> <span class="toctext">API модуля</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id=".D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D0.9D.D0.BE.D0.B2.D0.BE.D0.B3.D0.BE_.D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="mw-headline-number">1</span> Створення Нового Модуля</span></h2>
<p>Модулі в OpenSCADA представляють із себе поділювані бібліотеки, які підключаються до ядра OpenSCADA динамічно при запуску або під час функціювання програми. Багато модулів у процесі функціювання можуть бути відключені, підключені та оновлені із <a href="Program_manual.html#CfgModSched" title="Special:MyLanguage/Documents/Program manual">менеджера модулів</a>. Модулі також можуть бути вбудовані-включені до ядра OpenSCADA під час складання за посередництвом аргументу <b>--enable-{ModName}=incl</b> до скрипту конфігурації <b>configure</b>, про що можна дізнатися із <a href="How_to_Build_from_source.html" title="Special:MyLanguage/Documents/How to/Build from source">посібника по збірці</a>. Модулі OpenSCADA можуть бути семи типів згідно присутнім <a href="Program_manual.html#Modularity" title="Special:MyLanguage/Documents/Program manual">модульним підсистемам</a>. Наразі модулі до OpenSCADA пишуться на мові програмування "<b>C++</b>", хоча у подальшому можлива поява біндінгів на інші мови.
</p><p>У дереві вихідних текстів, у гілці кожної підсистеми, для спрощення створення нових модулів передбачено теку "=Tmpl=" із шаблоном модуля відповідної підсистеми. Розробник нового модуля може взяти цю теку та скопіювати її з ім'ям свого нового модуля, хоча він також завжди може використати у якості зразка будь який реальний функціонуючий модуль якщо його новий близький за структурою. Передбачено можливість створення модулів у дереві вихідних текстів проєкту OpenSCADA або як незалежного проєкту зовнішнього модуля до OpenSCADA.
</p>
<h3><span class="mw-headline" id=".D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D1.83_.D0.B4.D0.B5.D1.80.D0.B5.D0.B2.D1.96_.D0.B2.D0.B8.D1.85.D1.96.D0.B4.D0.BD.D0.B8.D1.85_.D1.82.D0.B5.D0.BA.D1.81.D1.82.D1.96.D0.B2_.D0.BF.D1.80.D0.BE.D1.94.D0.BA.D1.82.D1.83_OpenSCADA"><span class="mw-headline-number">1.1</span> Створення у дереві вихідних текстів проєкту OpenSCADA</span></h3>
<p>Створювати нові модулі у дереві вихідних текстів проєкту OpenSCADA має сенс у випадку подальших планів передачі нового модуля проєкту OpenSCADA. Оскільки модуль не має суперечити духу відкритого проєкту та ліцензії на основі якої <a class="external text" href="http://oscada.org/ua/golovna/pro-proekt/licenziji/" rel="nofollow noreferrer noopener" target="_blank">розробляється та розповсюджується OpenSCADA</a> то ліцензією нового модуля вочевидь має бути одна із вільних ліцензій.
</p><p>Процедура створення нового модуля з включенням до дерева вихідних текстів на основі шаблону в цілому є простішою за процедуру для зовнішнього модуля та включає в себе кроки:
</p>
<dl><dd>1. Отримати дерево вихідних текстів проєкту OpenSCADA для:
<ul><li> <i>Робочої (Work) гілки:</i></li></ul>
<dl><dd> <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">svn co svn://oscada.org/trunk/OpenSCADA</span></dd></dl>
<ul><li> <i>гілки стабільного релізу — НЕБАЖАНО, оскільки до стабільних LTS релізів приймаються лише виправлення та ця інструкція потребує версії 0.9 або вище:</i></li></ul>
<dl><dd> <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">svn co svn://oscada.org/tags/openscada_0.9</span></dd></dl></dd>
<dd>2. Скопіювати теку шаблону з назвою нового модуля "NewMod", наприклад, для підсистеми "БД":
<dl><dd> <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">cd OpenSCADA/src/moduls/bd; cp -r =Tmpl= NewMod; cd NewMod; rm -f configure.ac</span>
<dl><dd> <i>для підсистеми "Збір Даних" шлях наступний</i> — "OpenSCADA/src/moduls/<b>daq</b>"</dd>
<dd> <i>для підсистеми "Архіви-Історія" шлях наступний</i> — "OpenSCADA/src/moduls/<b>arhiv</b>"</dd>
<dd> <i>для підсистеми "Транспорти" шлях наступний</i> — "OpenSCADA/src/moduls/<b>transport</b>"</dd>
<dd> <i>для підсистеми "Транспортні Протоколи" шлях наступний</i> — "OpenSCADA/src/moduls/<b>protocol</b>"</dd>
<dd> <i>для підсистеми "Користувацькі Інтерфейси" шлях наступний</i> — "OpenSCADA/src/moduls/<b>ui</b>"</dd>
<dd> <i>для підсистеми "Спеціальні" шлях наступний</i> — "OpenSCADA/src/moduls/<b>special</b>"</dd></dl></dd></dl></dd>
<dd>3. Редагувати файл "module.cpp" щодо:
<dl><dd><dl><dd> <i>також може здійснюватися автоматично за допомогою:</i> <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">sed -i "s/Tmpl/NewMod/g" *.{cpp,h}</span></dd></dl></dd></dl>
<ul><li> <i>зміни назви функцій вбудування-включення модуля згідно назви нового модуля</i>:</li></ul>
<dl><dd> "TModule::SAt <b>bd_Tmpl_module</b>( int n_mod )" —&gt; "TModule::SAt <b>bd_NewMod_module</b>( int n_mod )"</dd>
<dd> "TModule *<b>bd_Tmpl_attach</b>( const TModule::SAt &amp;AtMod, const string &amp;source )" —&gt; "TModule *<b>bd_NewMod_attach</b>( const TModule::SAt &amp;AtMod, const string &amp;source )"</dd></dl>
<ul><li> <i>інформації про модуль у файлі "module.cpp", а саме ділянка:</i></li></ul></dd></dl>
<div class="mw-highlight mw-content-ltr" dir="ltr" style="margin-left: 45px"><pre><span class="c1">//************************************************</span>
<span class="c1">//* Modul info!                                  *</span>
<span class="cp">#define MOD_ID          "NewMod"</span>
<span class="cp">#define MOD_NAME        _("DB NewMod")</span>
<span class="cp">#define MOD_TYPE        SDB_ID</span>
<span class="cp">#define VER_TYPE        SDB_VER</span>
<span class="cp">#define MOD_VER         "0.0.1"</span>
<span class="cp">#define AUTHORS         _("MyName MyFamily")</span>
<span class="cp">#define DESCRIPTION     _("BD NewMod description.")</span>
<span class="cp">#define MOD_LICENSE     "GPL2"</span>
</pre></div>
<dl><dd>4. Відредагувати конфігурацію складання модуля у файлі "Makefile.am" щодо:
<dl><dd><dl><dd> <i>також може здійснюватися автоматично за допомогою:</i> <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">sed -i "s/Tmpl/NewMod/g" Makefile.am</span></dd></dl></dd></dl></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
EXTRA_DIST = *.h po/*

if NewModIncl
noinst_LTLIBRARIES = db_NewMod.la
db_NewMod_la_CXXFLAGS = -DMOD_INCL -fpic
db_NewMod_la_LIBTOOLFLAGS = --tag=disable-shared
db_NewMod_la_LDFLAGS = -module
else
oscd_modul_LTLIBRARIES = db_NewMod.la
db_NewMod_la_CXXFLAGS =
db_NewMod_la_LIBTOOLFLAGS = --tag=disable-static
db_NewMod_la_LDFLAGS = -module -avoid-version $(top_builddir)/src/liboscada.la
endif

db_NewMod_la_CXXFLAGS += $(NewMod_CFLAGS)
db_NewMod_la_LDFLAGS += $(NewMod_LDLAGS)
db_NewMod_la_SOURCES = module.cpp

I18N_mod = $(oscd_modulpref)NewMod
include ../../../../I18N.mk
</pre>
<dl><dd>5. Додати запис нового модуля в кінець секції підсистеми конфігураційного файлу "OpenSCADA/configure.ac" складальної системи OpenSCADA:
<ul><li> <i>в кінець секції "DB modules" для підсистеми "БД":</i></li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
AX_MOD_DB_EN(NewMod, [disable or enable[=incl] compilation module DB.NewMod], disable, incl, [
    # Код перевірки зовнішніх бібліотек модуля
])
</pre>
<dl><dd><ul><li> <i>в кінець секції "DAQ modules" для підсистеми "Збір Даних":</i></li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
AX_MOD_DAQ_EN(NewMod, [disable or enable[=incl] compilation module DAQ.NewMod], disable, incl, [
    # Код перевірки зовнішніх бібліотек модуля
])
</pre>
<dl><dd><ul><li> <i>в кінець секції "Archive modules" для підсистеми "Архіви-Історія":</i></li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
AX_MOD_Archive_EN(NewMod, [disable or enable[=incl] compilation module Archive.NewMod], disable, incl, [
    # Код перевірки зовнішніх бібліотек модуля
])
</pre>
<dl><dd><ul><li> <i>в кінець секції "Transport modules" для підсистеми "Транспорти":</i></li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
AX_MOD_Transport_EN(NewMod, [disable or enable[=incl] compilation module Transport.NewMod], disable, incl, [
    # Код перевірки зовнішніх бібліотек модуля
])
</pre>
<dl><dd><ul><li> <i>в кінець секції "Transport protocol modules" для підсистеми "Транспортні Протоколи":</i></li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
AX_MOD_TrProt_EN(NewMod, [disable or enable[=incl] compilation module Protocol.NewMod], disable, incl, [
    # Код перевірки зовнішніх бібліотек модуля
])
</pre>
<dl><dd><ul><li> <i>в кінець секції "UI modules" для підсистеми "Користувацькі Інтерфейси":</i></li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
AX_MOD_UI_EN(NewMod, [disable or enable[=incl] compilation module UI.NewMod], disable, incl, [
    # Код перевірки зовнішніх бібліотек модуля
])
</pre>
<dl><dd><ul><li> <i>в кінець секції "Special modules" для підсистеми "Спеціальні":</i></li></ul></dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
AX_MOD_Special_EN(NewMod, [disable or enable[=incl] compilation module Special.NewMod], disable, incl, [
    # Код перевірки зовнішніх бібліотек модуля
])
</pre>
<dl><dd>6. Тепер новий модуль можна скласти у складі OpenSCADA після переформування складальної системи:
<dl><dd> <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">autoreconf -if; ./configure --enable-NewMod; make</span></dd></dl></dd>
<dd>7. Опублікувати — сформувати латку із вашим модулем та надіслати її розробникам OpenSCADA:
<dl><dd> <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">cd OpenSCADA; make distclean; rm -rf src/moduls/bd/NewMod/{Makefile.in,.deps}</span></dd>
<dd> <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">svn add src/moduls/bd/NewMod; svn diff &gt; NewMod.patch</span></dd></dl></dd></dl>
<h3><span class="mw-headline" id=".D0.A1.D1.82.D0.B2.D0.BE.D1.80.D0.B5.D0.BD.D0.BD.D1.8F_.D0.B7.D0.BE.D0.B2.D0.BD.D1.96.D1.88.D0.BD.D1.8C.D0.BE.D0.B3.D0.BE_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F_.D0.B4.D0.BE_OpenSCADA"><span class="mw-headline-number">1.2</span> Створення зовнішнього модуля до OpenSCADA</span></h3>
<p>Створення зовнішнього модуля до OpenSCADA може мати сенс у випадку розробки інтерфейсу інтеграції з комерційними системами, які вимагають закриття коду взаємодії, а також у випадку інших реалізацій комерційних інтерфейсів при яких модуль до OpenSCADA отримує статус окремого проєкту, розповсюджується та підтримується незалежно, часто у вигляді бінарних збірок під конкретну платформу та версію OpenSCADA. Ліцензія таких модулів відповідно може бути будь якою.
</p><p>Процедура створення нового зовнішнього модуля на основі шаблону багато в чому схожа на попередню процедуру та включає в себе кроки:
</p>
<dl><dd>1. Отримати вихідні текстів проєкту OpenSCADA — для зовнішнього модуля у якості джерела шаблону можна використати будь які файли OpenSCADA версії більш 0.9, оскільки із них потрібно скопіювати лише теку "=Tmpl=" та декілька файлів для збірки.</dd>
<dd>2. Скопіювати теку шаблону з ім'ям нового модуля "NewMod", наприклад, для підсистеми "БД"; та вже в ній створити та скопіювати потрібні файли зовнішнього модуля. В подальшому інформаційні файли проєкту "COPYING", "NEWS", "README", "AUTHORS" та "ChangeLog" потрібно заповнити згідно сутності нового модуля:
<dl><dd> <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">cp -r OpenSCADA/src/moduls/bd/=Tmpl= NewMod; touch NewMod/{NEWS,README,AUTHORS,ChangeLog}; cp OpenSCADA/I18N.mk NewMod/</span>
<dl><dd> <i>для підсистеми "Збір Даних" шлях наступний</i> — "OpenSCADA/src/moduls/<b>daq</b>/=Tmpl="</dd>
<dd> <i>для підсистеми "Архіви-Історія" шлях наступний</i> — "OpenSCADA/src/moduls/<b>arhiv</b>/=Tmpl="</dd>
<dd> <i>для підсистеми "Транспорти" шлях наступний</i> — "OpenSCADA/src/moduls/<b>transport</b>/=Tmpl="</dd>
<dd> <i>для підсистеми "Транспортні Протоколи" шлях наступний</i> — "OpenSCADA/src/moduls/<b>protocol</b>/=Tmpl="</dd>
<dd> <i>для підсистеми "Користувацькі Інтерфейси" шлях наступний</i> — "OpenSCADA/src/moduls/<b>ui</b>/=Tmpl="</dd>
<dd> <i>для підсистеми "Спеціальні" шлях наступний</i> — "OpenSCADA/src/moduls/<b>special</b>/=Tmpl="</dd></dl></dd></dl></dd>
<dd>3. Відредагувати інформацію модуля у файлі "module.cpp" аналогічно цьому пункту попереднього розділу.</dd>
<dd>4. Відредагувати конфігурацію збірки модуля у файлі "Makefile.am" аналогічно цьому пункту попереднього розділу, окрім:
<ul><li> замість "db_NewMod_la_LDFLAGS = -module -avoid-version <b>$(top_builddir)/src/liboscada.la</b>" записати "db_NewMod_la_LDFLAGS = -module -avoid-version", тобто видалити "$(top_builddir)/src/liboscada.la"</li>
<li> замість "include <b>../../../../</b>I18N.mk" записати "include I18N.mk", тобто видалити шлях "../../../../"</li></ul></dd>
<dd>5. Відредагувати файл конфігурації складальної системи "configure.ac" щодо:
<dl><dd><dl><dd> <i>також може здійснюватися автоматично за допомогою:</i> <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">sed -i "s/Tmpl/NewMod/g" configure.ac</span></dd></dl></dd></dl>
<ul><li> "AC_INIT([<b>Tmpl</b>],[<b>0.0.1</b>],[<b>my@email.org</b>])" — інформація про модуль: ім'я, версія та Ел.Пошта проєкту</li>
<li> "AM_CONDITIONAL([<b>TmplIncl</b>],[test])" — "AM_CONDITIONAL([<b>NewModIncl</b>],[test])"</li></ul></dd>
<dd>6. Встановити пакет розробки OpenSCADA "openscada-dev" або "openscada-devel" — у зв'язку з тим, що модуль зовнішній та вихідні файли OpenSCADA потрібні лише на першому етапі його створення, то необхідно встановлювати пакет розробки OpenSCADA, який містить заголовні файли та бібліотеки.</dd>
<dd>7. Тепер новий модуль можна скласти, після формування складальної системи:
<dl><dd> <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">autoreconf -if; ./configure; make</span></dd></dl></dd></dl>
<h2><span class="mw-headline" id="API_.D0.BC.D0.BE.D0.B4.D1.83.D0.BB.D1.8F"><span class="mw-headline-number">2</span> API модуля</span></h2>
<p>API OpenSCADA для розробника OpenSCADA та модулів до неї описано у відповідному документі "<a href="../en/API.html" title="Special:MyLanguage/Documents/API">API OpenSCADA</a>", який завжди має бути під рукою при розробці для OpenSCADA. В цьому ж документі наголос здійснено на детальному роз'яснені основних моментів модульного API.
</p><p>Модулі в OpenSCADA реалізуються як поділювані бібліотеки та одна така бібліотека може містити багато модулів підсистем OpenSCADA, фактично виступаючи як контейнер. Такі контейнери також можуть бути включені-вбудовані до Бібліотеки Ядра OpenSCADA якщо ви будуєте дуже компактні рішення.
</p><p>Першим кроком підключення поділюваних бібліотек (SO — Поділювані Об'єкти) є підключення функцій ініціалізації. Такі функції мають бути визначені як звичайні "C" функції для запобігання спотворенню їх назв. Зазвичай це здійснюється наступним чином:
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span class="c1">//================== CUT =========================</span>
<span class="k">extern</span> <span class="s">"C"</span>
<span class="p">{</span>
<span class="cp">#ifdef MOD_INCL</span>
    <span class="n">TModule</span><span class="o">::</span><span class="n">SAt</span> <span class="n">bd_Tmpl_module</span><span class="p">(</span> <span class="kt">int</span> <span class="n">n_mod</span> <span class="p">)</span>
<span class="cp">#else</span>
    <span class="n">TModule</span><span class="o">::</span><span class="n">SAt</span> <span class="n">module</span><span class="p">(</span> <span class="kt">int</span> <span class="n">n_mod</span> <span class="p">)</span>
<span class="cp">#endif</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n_mod</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">TModule</span><span class="o">::</span><span class="n">SAt</span><span class="p">(</span><span class="n">MOD_ID</span><span class="p">,</span> <span class="n">MOD_TYPE</span><span class="p">,</span> <span class="n">VER_TYPE</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">TModule</span><span class="o">::</span><span class="n">SAt</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
    <span class="p">}</span>

<span class="o">&lt;!--</span><span class="nl">T</span><span class="p">:</span><span class="mi">348</span><span class="o">--&gt;</span>
<span class="cp">#ifdef MOD_INCL</span>
    <span class="n">TModule</span> <span class="o">*</span><span class="n">bd_Tmpl_attach</span><span class="p">(</span> <span class="k">const</span> <span class="n">TModule</span><span class="o">::</span><span class="n">SAt</span> <span class="o">&amp;</span><span class="n">AtMod</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">source</span> <span class="p">)</span>
<span class="cp">#else</span>
    <span class="n">TModule</span> <span class="o">*</span><span class="n">attach</span><span class="p">(</span> <span class="k">const</span> <span class="n">TModule</span><span class="o">::</span><span class="n">SAt</span> <span class="o">&amp;</span><span class="n">AtMod</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">source</span> <span class="p">)</span>
<span class="cp">#endif</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">AtMod</span> <span class="o">==</span> <span class="n">TModule</span><span class="o">::</span><span class="n">SAt</span><span class="p">(</span><span class="n">MOD_ID</span><span class="p">,</span><span class="n">MOD_TYPE</span><span class="p">,</span><span class="n">VER_TYPE</span><span class="p">))</span> <span class="k">return</span> <span class="k">new</span> <span class="n">BDTmpl</span><span class="o">::</span><span class="n">BDMod</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//================== CUT =========================</span>
</pre></div>
<p>Точкою входу будь якого модуля є функції:
</p>
<ul><li> <i>TModule::SAt module( int n_mod )</i>, <i>TModule::SAt {modTp}_{modNm}_module( int n_mod )</i> — використовуються для сканування переліку та інформації з усіх модулів у бібліотеці. Перша функція використовується під час реалізації модулів у зовнішній поділюваній бібліотеці, а друга під час включення-вбудування їх до ядра OpenSCADA, де <i>modTp</i> відповідає типу модуля, а <i>modNm</i> його ІД.</li>
<li> <i>TModule *attach( const TModule::SAt &amp;AtMod, const string &amp;source )</i>, <i>TModule *{modTp}_{modNm}_attach( const TModule::SAt &amp;AtMod, const string &amp;source )</i> — використовується для безпосереднього підключення-відкриття обраного модуля шляхом створення кореневого об'єкта модуля успадкованого від <b>TModule</b>. Перша функція використовується під час реалізації модулів у зовнішній поділюваній бібліотеці, а друга під час включення-вбудування їх до ядра OpenSCADA, де <i>modTp</i> та <i>modNm</i> відповідають попередній функції.</li></ul>
<p>Загальним для всіх модулів є наслідування кореневого об'єкта-класу модуля від класу модульної підсистеми <a href="../en/API.html#TModule" title="Special:MyLanguage/Documents/API">TModule</a>, що вказує на наявність спільної частини інтерфейсу модуля який розглянемо далі. Для отримання уявлення про архітектуру модулів у контексті загальної архітектури OpenSCADA наполегливо рекомендується мати перед очима <a class="external" href="http://oscada.org/wiki/File:API_uml_classdep.png" title="File:API uml classdep.png">загальну діаграму класів OpenSCADA</a>!
</p><p>Всі інтерфейсні об'єкти модулів успадковують клас вузла <a href="../en/API.html#TCntrNode" title="Special:MyLanguage/Documents/API">TCntrNode</a>, який надає механізм <a href="../en/API.html#CntrNode" title="Special:MyLanguage/Documents/API">інтерфейсу управління</a>. Одним із завдань цього механізму є надання інтерфейсу конфігурації об'єкту у будь якому конфігураторі OpenSCADA.
</p>
<table class="wikitable">

<tr>
<th> Загальне API
</th></tr>
<tr>
<td><b><a href="../en/API.html#TCntrNode" title="Special:MyLanguage/Documents/API">TCntrNode</a></b> — Вузол OpenSCADA:
<ul><li> <i>void preEnable( int flag );</i>, <i>void postEnable( int flag );</i> — підключення модуля до динамічного дерева об'єктів, викликається перед та після фактичного увімкнення модуля відповідно.</li>
<li> <i>void preDisable( int flag );</i>, <i>void postDisable( int flag );</i> — виключення модуля із динамічного дерева об'єктів перед звільненням об'єкту, викликається перед та після фактичного виключення модуля відповідно.</li>
<li> <i>void load_( TConfig *cfg );</i>, <i>void load_( );</i> — завантаження модуля із контексту сховища <i>cfg</i> та загалом, викликається на стадії завантаження конфігурації модуля зі сховку.</li>
<li> <i>void save_( );</i> — збереження модуля, викликається на стадії збереження конфігурації модуля до сховку, зазвичай за ініціативою користувача.</li></ul>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TModule" title="Special:MyLanguage/Documents/API">TModule</a></b> — Модуль OpenSCADA:<br />
<ul><li> <i>void modStart( );</i> — запуск модуля, викликається на стадії запуску завдань виконання фонових функцій модуля, якщо такі модулем надаються.</li>
<li> <i>void modStop( );</i> — зупинка модуля, викликається на стадії зупинки завдань виконання фонових функцій модуля, якщо такі модулем надаються.</li>
<li> <i>void modInfo( vector&lt;string&gt; &amp;list );</i> — запит переліку інформаційних властивостей модуля, яким надається стандартний набір властивостей "Module", "Name", "Type", "Source", "Version", "Author", "Description", "License", та що може бути розширено власними-специфічними властивостями.</li>
<li> <i>string modInfo( const string &amp;name );</i> — запит елементу інформації <i>name</i> за якого здійснюється обробка запитів і до власних-специфічних властивостей модуля.</li>
<li> <i>void modFuncReg( ExpFunc *func );</i> — реєстрація експортованої функції модуля, яка є частиною механізму міжмодульної взаємодії що реєструє внутрішню функцію модуля для зовнішнього виклику за назвою-символом функції та її вказівником відносно об'єкта модуля. Наразі цей механізм мало якими модулями використовується!</li>
<li> <i>void perSYSCall( unsigned int cnt );</i> — виклик із системного-сервісного потоку-завдання з періодичністю 10 секунд та секундним лічильником <i>cnt</i>, може використовуватися для виконання періодичних-рідких сервісних процедур.</li></ul>
</td></tr>
<tr>
<th> API модулів підсистеми "Бази Даних (БД)"
</th></tr>
<tr>
<td> Призначено для інтеграції OpenSCADA із БД чи СУБД, яка реалізується модулем. Надає два загальних підходи до реалізації модулів:
<ol><li> Режим ANSI SQL — є найпростішим шляхом який передбачає безпосереднє використання функцій ядра <a href="../en/API.html#TTable" title="Special:MyLanguage/Documents/API">fieldSQLSeek(), fieldSQLGet(), fieldSQLSet(), fieldSQLDel()</a> у fieldSeek(), fieldGet(), fieldSet(), fieldDel() відповідно; всі SQL-модулі використовують наразі цей підхід.</li>
<li> Повна Реалізація — є найскладнішим шляхом який передбачає повну реалізацію; модулі, що використовують такий підхід є або старими або специфічними: <a href="Modules/DBF.html" title="Special:MyLanguage/Modules/DBF">DBF</a>, <a href="Modules/LDAP.html" title="Special:MyLanguage/Modules/LDAP">LDAP</a>.</li></ol>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TTypeBD" title="Special:MyLanguage/Documents/API">TTypeBD</a>-&gt;<a href="../en/API.html#TModule" title="Special:MyLanguage/Documents/API">TModule</a></b> — кореневий об'єкт модуля підсистеми "БД":
<ul><li> <i>string features( );</i> — перелік ключових слів <a href="Program_manual.html#DBFeat" title="Special:MyLanguage/Documents/Program manual">підтримуваних властивостей БД</a>.</li>
<li> <i>int lsPr( );</i> — базовий приорітет БД [0...9] у загальному переліку сховків.</li>
<li> <i>TBD *openBD( const string &amp;id );</i> — викликається при відкритті або створені нового об'єкта БД даним модулем з ідентифікатором <i>id</i>.</li></ul>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TBD" title="Special:MyLanguage/Documents/API">TBD</a></b> — об'єкт бази даних:
<ul><li> <i>void enable( );</i> — включення БД.</li>
<li> <i>void disable( );</i> — відключення БД.</li>
<li> <i>void allowList( vector&lt;string&gt; &amp;list ) const;</i> — запит переліку <i>list</i> таблиць у БД.</li>
<li> <i>void sqlReq( const string &amp;req, vector&lt; vector&lt;string&gt; &gt; *tbl = NULL, char intoTrans = EVAL_BOOL );</i> — обробка SQL-запиту <i>req</i> до БД та отримання результату у вигляді таблиці <i>tbl</i>, якщо запит вибірки та вказівник ненульовий. При встановлені <i>intoTrans</i> у TRUE для запиту мусить бути відкрита транзакція, у FALSE закрита. Ця функція має реалізовуватися для СУБД, які підтримують SQL-запити.</li>
<li> <i>void transCloseCheck( );</i> — періодично викликається для перевірки транзакцій та закриття старих або які містять багато запитів.</li>
<li> <i>TTable *openTable( const string &amp;name, bool create );</i> — викликається при відкритті або створені нового об'єкта таблиці.</li></ul>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TTable" title="Special:MyLanguage/Documents/API">TTable</a></b> — об'єкт таблиці у базі даних:
<ul><li> <i>void fieldStruct( TConfig &amp;cfg );</i> — отримання поточної структури таблиці у об'єкті <i>cfg</i>.</li>
<li> <i>bool fieldSeek( int row, TConfig &amp;cfg, const string &amp;cacheKey = "" );</i> — послідовне сканування записів таблиці перебором <i>row</i> за об'єктом <i>cfg</i> та повернення FALSE по закінченню, з адресацією за активними <a href="../en/API.html#TCfg" title="Special:MyLanguage/Documents/API">keyUse()</a> ключовими полями. Ключ кешу <i>cacheKey</i> вказується для предзавантаженням повної відповіді до кешу, із витягненням наступних записів звідти.</li>
<li> <i>void fieldGet( TConfig &amp;cfg );</i> — запит вказаного у об'єкті <i>cfg</i> запису із адресацією за ключовими полями.</li>
<li> <i>void fieldSet( TConfig &amp;cfg );</i> — передача вказаного у об'єкті <i>cfg</i> запису з адресацією за ключовими полями.</li>
<li> <i>void fieldDel( TConfig &amp;cfg );</i> — видалення вказаного запису за ключовими полями об'єкту <i>cfg</i>.</li></ul>
<dl><dd> <i><b>Специфічне для SQL Баз Даних</b></i></dd></dl>
<ul><li> <i>void fieldFix( TConfig &amp;cfg, const string &amp;langLs = "" );</i> — виправлення структури таблиці БД до <i>cfg</i> та для мов перекладу <i>langLs</i>, зазвичай після невдалого запису.</li>
<li> <i>string getSQLVal( TCfg &amp;cf, uint8_t RqFlg = 0 );</i> — повернення специфічно до SQL обгорненого значення <i>cf</i> для <a href="../en/API.html#TCfg" title="Special:MyLanguage/Documents/API">прапорців ReqFlg</a> звернення <i>RqFlg</i>.</li>
<li> <i>void setSQLVal( TCfg &amp;cf, const string &amp;vl, bool tr = false );</i> — розбір SQL-значення <i>vl</i> для перекладу <i>tr</i> та із записом до <i>cf</i>.</li></ul>
</td></tr>
<tr>
<th> API модулів підсистеми "Транспорти"
</th></tr>
<tr>
<td> Забезпечує OpenSCADA комунікаціями через інтерфейс, часто це мережі які реалізуються цим модулем.
</td></tr>
<tr>
<td> <b><a href="../en/API.html#TTypeTransport" title="Special:MyLanguage/Documents/API">TTypeTransport</a>-&gt;<a href="../en/API.html#TModule" title="Special:MyLanguage/Documents/API">TModule</a></b> — кореневий об'єкт модуля підсистеми "Транспорти":
<ul><li> <i>virtual bool isNetwork( );</i> — ознака реалізації мережі цим модулем.</li>
<li> <i>virtual string outAddrHelp( );</i> — допомога із формату адреси вихідного транспорту.</li>
<li> <i>virtual TTransportIn *In( const string &amp;id, const string &amp;stor );</i> — викликається модулем за відкриття або створення нового об'єкту вхідного транспорту із ідентифікатором <i>id</i> та сховком <i>stor</i>.</li>
<li> <i>virtual TTransportOut *Out( const string &amp;name, const string &amp;stor );</i> — викликається модулем за відкриття або створення нового об'єкту вихідного транспорту із ідентифікатором <i>id</i> та сховком <i>stor</i>.</li></ul>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TTransportIn" title="Special:MyLanguage/Documents/API">TTransportIn</a></b> — об'єкт вхідного транспорту:
<ul><li> <i>virtual unsigned keepAliveReqs( );</i> — максимум запитів "Збереження Життя".</li>
<li> <i>virtual unsigned keepAliveTm( );</i> — час "Збереження Життя".</li>
<li> <i>virtual string getStatus( );</i> — отримання статусу транспорту.</li>
<li> <i>virtual void start( );</i> — запуск транспорту.</li>
<li> <i>virtual void stop( );</i> — зупинка транспорту.</li>
<li> <i>virtual int writeTo( const string &amp;sender, const string &amp;data );</i> — надсилання даних <i>data</i> назад відправнику <i>sender</i>. <a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../en/files/At.png" width="22" /></a> Переважно застаріле та заміщене режимом опитування <a href="../en/API.html#TProtocolIn" title="Special:MyLanguage/Documents/API">вхідного транспортного протоколу</a>, Початково реалізується у транспортах із підтримкою ініціативного відправлення, не лише за запитом.</li></ul>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TTransportOut" title="Special:MyLanguage/Documents/API">TTransportOut</a></b> — об'єкт вихідного транспорту:
<ul><li> <i>virtual string timings( );</i> — таймаути транспорту.</li>
<li> <i>virtual unsigned short attempts( );</i> — спроб підключення.</li>
<li> <i>virtual string getStatus( );</i> — отримання статусу транспорту.</li>
<li> <i>virtual void setTimings( const string &amp;vl, bool isDef = false );</i> — встановлення таймаутів транспорту, як типове за <i>isDef</i>.</li>
<li> <i>virtual void setAttempts( unsigned short vl );</i> — встановлення спроб підключення.</li>
<li> <i>virtual void start( int time = 0 );</i> — запуск транспорту із таймаутом підключення <i>time</i>. Із запуском вихідного транспорту встановлюється підключення до віддаленої станції для інтерфейсів які передбачають підключення. На цей час можуть виникати помилки якщо підключення неможливе та транспорт має повернутися до стану зупинки.</li>
<li> <i>virtual void stop( );</i> — зупинка транспорту.</li>
<li> <i>virtual int messIO( const char *oBuf, int oLen, char *iBuf = NULL, int iLen = 0, int time = 0 );</i> — відправка даних через транспорт. Таймаут очікування <i>time</i> підключення в мілісекундах. Негативне значення <i>time</i> вимикає режим транспорту запит/відповідь для незалежного читання/запису до буферу ВВ, із таймаутом читання <i>time</i> у абсолютному значені.</li></ul>
</td></tr>
<tr>
<th> API модулів підсистеми "Транспортні протоколи"
</th></tr>
<tr>
<td> Забезпечує OpenSCADA комунікаціями рівня протоколу, які реалізуються модулем, щодо доступу до даних із зовнішніх систем та надання даних OpenSCADA для зовнішніх систем.
</td></tr>
<tr>
<td><b><a href="../en/API.html#TProtocol" title="Special:MyLanguage/Documents/API">TProtocol</a>-&gt;<a href="../en/API.html#TModule" title="Special:MyLanguage/Documents/API">TModule</a></b> — кореневий об'єкт модуля підсистеми "Транспортні протоколи":
<ul><li> <i>virtual void itemListIn( vector&lt;string&gt; &amp;ls, const string &amp;curIt = "" );</i> — перелік <i>ls</i> під'елементів вхідного протоколу від поточного елементу <i>curIt</i>, якщо протокол їх надає. Використовується при обранні об'єкта у конфігурації вхідного транспорту.</li>
<li> <i>virtual void outMess( XMLNode &amp;io, TTransportOut &amp;tro );</i> — передавання даних об'єктами ядра OpenSCADA у дереві XML <i>io</i> до віддаленої системи через транспорт <i>tro</i> та поточний вихідний протокол. Представлення даних у дереві XML не стандартизоване та специфічне до логічної структури протоколу. Ці дані серіалізуються — перетворюються у послідовність байтів відповідно до протоколу, та надсилаються через визначений вихідний транспорт <i>tro</i> <a href="../en/API.html#TTransportOut" title="Special:MyLanguage/Documents/API">функцією messIO()</a>.</li>
<li> <i>virtual TProtocolIn *in_open( const string &amp;id );</i> — викликається модулем за відкриття або створення нового об'єкту транспортного протоколу із ідентифікатором <i>id</i>.</li></ul>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TProtocolIn" title="Special:MyLanguage/Documents/API">TProtocolIn</a></b> — вхідний об'єкт транспортного протоколу з опрацювання вхідних запитів від <a href="../en/API.html#TTransportIn" title="Special:MyLanguage/Documents/API">вхідного транспортного об'єкту TTransportIn</a>. Для кожного сеансу вхідного запиту створюється асоційований об'єкт вхідного протоколу, який залишається живим до завершення повного сеансу "запит-&gt;відповідь". Адреса транспорту, який відкриває входження протоколу, визначається у <a href="../en/API.html#TProtocolIn" title="Special:MyLanguage/Documents/API">srcTr()</a>:
<ul><li> <i>virtual unsigned waitReqTm( )</i> — час очікування запиту на вхідному транспорті у мілісекундах, після якого звертається до протоколу із порожнім повідомленням — режим опитування. Встановлення його у нуль вимикає режим опитування.</li>
<li> <i>virtual void setSrcTr( TTransportIn *vl )</i> — встановлення транспорту-джерела відкритого сеансу вхідного протоколу.</li>
<li> <i>virtual void setSrcAddr( const string &amp;vl );</i> — встановлення адреси відправника.</li>
<li> <i>virtual bool mess( const string &amp;request, string &amp;answer );</i> — передавання послідовності даних запиту <i>request</i> до об'єкту протоколу для її розбору відповідно до реалізації протоколу. Ця функція протоколу має опрацювати запит <i>request</i>, згенерувати відповідь у <i>answer</i> та повернути FALSE у випадку повноти запиту. Якщо запит <i>request</i> не повний, необхідно повернути транспорту TRUE для індикації "очікування завершення", попередні частини запиту повинні зберігатися у контексті об'єкту протоколу.</li></ul>
</td></tr>
<tr>
<th> API модулів підсистеми "Збір Даних"
</th></tr>
<tr>
<td> Надає збір даних реального часу із зовнішніх систем або їх формування у обчислювачах, які реалізуються модулем. Це основна підсистема, оскільки SCADA це первинно про Збір Даних. Як основна підсистема, вона забезпечує декілька підходів до реалізації модулів, які здебільшого стосуються формування та зберігання структури атрибутів:
<ol><li> Статичне формування через визначення набору типів параметрів, успадкованих від <a href="../en/API.html#TTypeParam" title="Special:MyLanguage/Documents/API">TTypeParam</a>, тобто застосування структур виконується як набір атрибутів зі зміною типу параметра. Цей метод є найменш гнучким і його використовують такі модулі: <a href="Modules/GPIO.html" title="Special:MyLanguage/Modules/GPIO">GPIO</a>, <a href="Modules/SMH2Gi.html" title="Special:MyLanguage/Modules/SMH2Gi">SMH2Gi</a>, <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Modules/AMRDevs" title="Special:MyLanguage/Modules/AMRDevs">AMRDevs</a>.</li>
<li> Динамічне формування з керуванням структури контейнеру  <a href="../en/API.html#TElem" title="Special:MyLanguage/Documents/API">TElem</a> в об’єкті параметра <a href="../en/API.html#TParamContr" title="Special:MyLanguage/Documents/API">TParamContr</a>. Цей метод є найбільш гнучким і використовується в більшості модулів, структуру яких можна конфігурувати.</li>
<li> Як розширення динамічного формування існує <a href="DAQ.html#LogicLev" title="Special:MyLanguage/Documents/DAQ">тип параметра Логічного Рівня</a>, який можна додати до будь-якого модуля, але він використовується переважно в універсальних джерелах даних: <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">LogicLev</a>, <a href="Modules/ModBus.html" title="Special:MyLanguage/Modules/ModBus">ModBus</a>, <a href="Modules/Siemens.html" title="Special:MyLanguage/Modules/Siemens">Siemens</a>, <a href="Modules/Siemens.html" title="Special:MyLanguage/Modules/Siemens">LogicLev</a>.</li></ol>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TTypeDAQ" title="Special:MyLanguage/Documents/API">TTypeDAQ</a>-&gt;<a href="../en/API.html#TModule" title="Special:MyLanguage/Documents/API">TModule</a></b> — кореневий об'єкт модуля підсистеми "Збір Даних":
<ul><li> <i>virtual bool compileFuncLangs( vector&lt;string&gt; *ls = NULL );</i> — запитує перелік мов <i>ls</i> для яких реалізується можливість формування користувацьких процедур у цьому модулі, та перевірка факту підтримки цього.</li>
<li> <i>virtual void compileFuncSnthHgl( const string &amp;lang, XMLNode &amp;shgl );</i> — запит прав підсвітлення синтаксису <i>shgl</i> щодо визначеної мови <i>lang</i>.</li>
<li> <i>virtual string compileFunc( const string &amp;lang, TFunction &amp;fnc_cfg, const string &amp;prog_text, const string &amp;usings = "", int maxCalcTm = 0 );</i> — компіляція-реєстрація користувацької функції на підтримуваній мові програмування <i>lang</i> та на вихідному коді процедури <i>prog_text</i>, заснованій на параметрах процедури <i>fnc_cfg</i>. Повертає адресу об'єкту скомпільованої функції, готового до виконання.</li>
<li> <i>virtual bool redntAllow( );</i> — стан підтримки механізму резервування цим модулем. Має бути перевизначено та повертати TRUE за підтримки, інакше FALSE.</li>
<li> <i>virtual TController *ContrAttach( const string &amp;id, const string &amp;daq_db );</i> — викликається модулем за відкриття або створення нового об'єкту контролеру із ідентифікатором <i>id</i>.</li></ul>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TController" title="Special:MyLanguage/Documents/API">TController</a></b> — об'єкт контролеру джерела даних. У контексті об'єкту зазвичай виконується завдання періодичного або планового опитування даних реального часу фізичного контролеру або фізично відокремленого блоку даних. У випадку отримання даних пакетами, вони розташовуються безпосередньо у архіві, пов'язаному із атрибутом параметра <a href="../en/API.html#TVAl" title="Special:MyLanguage/Documents/API">TVAl::arch()</a>, та поточне значення встановлюється <a href="../en/API.html#TVAl" title="Special:MyLanguage/Documents/API">функцією TVAl::set()</a> із атрибутом "sys"=TRUE:
<ul><li> <i>virtual string getStatus( );</i> — функція запиту статусу контролеру.</li>
<li> <i>virtual void enable_(  );</i> — увімкнення об'єкту контролеру. На цій стадії зазвичай відбувається ініціалізація об'єктів параметрів та їх інтерфейсів у формі атрибутів, атрибути інколи можуть запитуватися у пов'язаного віддаленого джерела.</li>
<li> <i>virtual void disable_(  );</i> — вимкнення об'єкту контролеру.</li>
<li> <i>virtual void start_( );</i> — запуск об'єкту контролеру. На цій стадії зазвичай створюється та запускається завдання опитування.</li>
<li> <i>virtual void stop_( );</i> — зупинка об'єкту контролеру.</li>
<li> <i>virtual void redntDataUpdate( );</i> — операція отримання даних із резервної станції, автоматично викликається сервісною процедурою схеми резервування підсистеми.</li>
<li> <i>virtual string catsPat( );</i> — перелік правил регулярних виразів, поділених '|', для виокремлення за категорією щодо повідомлень згенерованих об'єктом.</li>
<li> <i>virtual void messSet( const string &amp;mess, int lev, const string &amp;type2Code = "OP", const string &amp;prm = "", const string &amp;cat = "" );</i> — формування повідомлення Джерела Даних від об'єкту параметру <i>prm</i> (PrmId) або об'єкту контролеру взагалі якщо об'єкту параметру не визначено, для повідомлення <i>mess</i>, рівня <i>lev</i> та коду типу <i>type2Code</i>. Ця функція генерує повідомлення із уніфікованою категорією прозорості Джерела Даних "<b>{type2Code}{ModId}:{CntrId}[.{prm}][:{cat}]</b>".</li>
<li> <i>virtual TParamContr *ParamAttach( const string &amp;id, int type );</i> — викликається модулем за відкриття або створення нового об'єкту параметру контролера із ідентифікатором <i>id</i>.</li></ul>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TParamContr" title="Special:MyLanguage/Documents/API">TParamContr</a>-&gt;<a href="../en/API.html#TValue" title="Special:MyLanguage/Documents/API">TValue</a></b> — об'єкт параметру контролера джерела даних. Містить атрибути з реальними даними у наборі визначеному фізично доступними даними. Значення до атрибутів потрапляють із завдання опитування контролера, при асинхронному режимі, або запитуються під час звернення, при синхронному режимі, та за посередництвом методів успадкованого типу <a href="../en/API.html#TValue" title="Special:MyLanguage/Documents/API">TValue</a>:
<ul><li> <i>virtual TElem *dynElCntr( );</i> — контейнер динамічних елементів атрибутів Збору Даних. Переважно визначається джерелами логічного рівня які і надають контейнери такого характеру.</li>
<li> <i>virtual void enable( );</i> — увімкнення об'єкту параметру, здійснюється формування набору атрибутів та заповнення їх значеннями недостовірності.</li>
<li> <i>virtual void disable( );</i> — вимкнення об'єкту параметру.</li>
<li> <i>virtual void setType( const string &amp;tpId );</i> — викликається для зміни типу параметру у <i>tpId</i> та може бути опрацьований у об'єкті модуля для зміни власних даних.</li>
<li> <i>virtual TVal* vlNew( );</i> — викликається на стадії створення нового атрибуту. Може бути перевизначено для реалізації особливої поведінки у межах свого об'єкту, успадкованого від <i>TVal</i>, при доступі до атрибуту.</li>
<li> <i>virtual void vlGet( TVal &amp;vo );</i> — викликається для атрибуту <i>vo</i> із режимом прямого читання <b>TVal::DirRead</b> при читанні значення задля прямого-синхронного читання із фізичного джерела або буферу об'єкта.</li>
<li> <i>virtual void vlSet( TVal &amp;vo, const TVariant &amp;vl, const TVariant &amp;pvl );</i> — викликається для атрибуту <i>vo</i> із режимом прямого запису <b>TVal::DirWrite</b> при запису значення <i>vl</i> задля прямого-синхронного запису до фізичного джерела або буферу об'єкта, із попереднім значенням <i>pvl</i>.</li>
<li> <i>virtual void vlArchMake( TVal &amp;val );</i> — викликається на стадії створення архіву значень із атрибутом <i>val</i> як джерело щодо ініціалізації характеристик якості буферу архіву у відповідності до характеристик джерела даних та опитування.</li></ul>
</td></tr>
<tr>
<th> API модулів підсистеми "Архіви-Історія"
</th></tr>
<tr>
<td> Використовується для архівування та ведення історії повідомлень і значень реального часу отриманих у підсистемі "Збір Даних", та у засіб реалізований модулем.
</td></tr>
<tr>
<td><b><a href="../en/API.html#TTypeArchivator" title="Special:MyLanguage/Documents/API">TTypeArchivator</a>-&gt;<a href="../en/API.html#TModule" title="Special:MyLanguage/Documents/API">TModule</a></b> — кореневий об'єкт модуля підсистеми "Архіви-Історія":
<ul><li> <i>virtual TMArchivator *AMess( const string &amp;id, const string &amp;stor );</i> — викликається модулем за відкриття або створення нового об'єкту архіватору повідомлень із ідентифікатором <i>id</i> та у сховку <i>stor</i>.</li>
<li> <i>virtual TVArchivator *AVal( const string &amp;id, const string &amp;stor );</i> — викликається модулем за відкриття або створення нового об'єкту архіватору значень із ідентифікатором <i>id</i> та у сховку <i>stor</i>.</li></ul>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TMArchivator" title="Special:MyLanguage/Documents/API">TMArchivator</a></b> — об'єкт архіватору повідомлень.
<ul><li> <i>virtual void redntDataUpdate( );</i> — операція отримання даних із резервної станції, автоматично викликається сервісною процедурою схеми резервування підсистеми.</li>
<li> <i>virtual void start( );</i> — запуск об'єкту архіватору, архіватор запускається для отримання повідомлень та розміщення їх до сховку.</li>
<li> <i>virtual void stop( );</i> — зупинка об'єкту архіватору.</li>
<li> <i>virtual time_t begin( );</i> — час початку даних архіватору у відповідності до поточного стану сховку.</li>
<li> <i>virtual time_t end( );</i> — час закінчення даних архіватору у відповідності до поточного стану сховку.</li>
<li> <i>virtual bool put( vector&lt;TMess::SRec&gt; &amp;mess, bool force = false );</i> — розташування групи повідомлень <i>mess</i> до архіватору. Повертає TRUE за успішної операції. Встановити <i>force</i> для прямого запису до архіву оминаючи резервування.</li>
<li> <i>virtual time_t get( time_t bTm, time_t eTm, vector&lt;TMess::SRec&gt; &amp;mess, const string &amp;category = "", char level = 0, time_t upTo = 0 );</i> — отримання повідомлень до <i>mess</i> із архіватору для визначених параметрів фільтрації. Повертає час зупинки запиту, корисно для продовження від цієї позиції як часу закінчення, тобто ітераційно заглиблюючись в історію. Фільтр визначається діапазоном часу [<i>bTm</i>...<i>eTm</i>], правилами категорії <i>category</i>, рівнем <i>level</i> та обмежено до часу <i>upTo</i>. За відсутності прямого визначення обмежувального часу <i>upTo</i>, це обмеження встановлюється у <i>prmInterf_TM</i> — 7 секунд.</li></ul>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TVArchivator" title="Special:MyLanguage/Documents/API">TVArchivator</a></b> — об'єкт архіватору значень.
<ul><li> <i>virtual void start( );</i> — запуск об'єкту архіватору, архіватор запускається для отримання значень та розміщення їх у сховок.</li>
<li> <i>virtual void stop( bool full_del = false );</i> — зупинка об'єкту архіватору із можливістю повного видалення його даних зі сховку за <i>full_del</i>.</li>
<li> <i>virtual TVArchEl *getArchEl( TVArchive &amp;arch );</i> — отримання об'єкту елемента архіву значень для визначеного архіву <i>arch</i>.</li>
<li> <i>virtual void pushAccumVals( );</i> — виштовхування накопичених завданням архівації значень, для акумулювальних архіваторів.</li></ul>
</td></tr>
<tr>
<td><b><a href="../en/API.html#TVArchEl" title="Special:MyLanguage/Documents/API">TVArchEl</a></b> — об'єкт елементу архіватору значень.
<ul><li> <i>virtual void fullErase( );</i> — викликається для цілковитого видалення архівної частини архіватору.</li>
<li> <i>virtual int64_t end( );</i> — час завершення у мікросекундах щодо наявних значень у архіві архіватору.</li>
<li> <i>virtual int64_t begin( );</i> — час початку у мікросекундах щодо наявних значень у архіві архіватору.</li>
<li> <i>virtual TVariant getValProc( int64_t *tm, bool up_ord );</i> — запит одного значення із архіву на час <i>tm</i> та із підтягненням до верхнього значення у ґратці вимірювання <i>up_ord</i>.</li>
<li> <i>virtual void getValsProc( TValBuf &amp;buf, int64_t beg, int64_t end );</i> — запит групи значень до <i>buf</i> із архіву та для діапазону часу [<i>beg</i>...<i>end</i>].</li>
<li> <i>virtual void setValsProc( TValBuf &amp;buf, int64_t beg, int64_t end, bool toAccum );</i> — встановлення групи значень <i>buf</i> до архіву, для діапазону часу [<i>beg</i>...<i>end</i>] та через акумуляцію <i>toAccum</i>.</li></ul>
</td></tr>
<tr>
<th> API модулів підсистеми "Користувацькі Інтерфейси"
</th></tr>
<tr>
<td> Користувацький інтерфейс формується згідно до концепції та механізмів зовнішніх розповсюджених стандартів та бібліотек.
</td></tr>
<tr>
<td><b><a href="../en/API.html#TUI" title="Special:MyLanguage/Documents/API">TUI</a>-&gt;<a href="../en/API.html#TModule" title="Special:MyLanguage/Documents/API">TModule</a></b> — кореневий об'єкт модуля підсистеми "Користувацькі Інтерфейси":<br />
<p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../en/files/At.png" width="22" /></a> Не містить специфічних функцій!
</p>
</td></tr>
<tr>
<th> API модулів підсистеми "Спеціальне"
</th></tr>
<tr>
<td> Реалізує специфічні функції, які не увійшли до жодної з вищеперелічених підсистем. Специфічні функції формуються згідно їх власних вимог та із використанням всіх можливостей API OpenSCADA.
</td></tr>
<tr>
<td><b><a href="../en/API.html#TSpecial" title="Special:MyLanguage/Documents/API">TSpecial</a>-&gt;<a href="../en/API.html#TModule" title="Special:MyLanguage/Documents/API">TModule</a></b> — кореневий об'єкт модуля підсистеми "Спеціальне":<br />
<p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../en/files/At.png" width="22" /></a> Не містить специфічних функцій!
</p>
</td></tr></table>
<p><br />
Для зручності прямої адресації до кореневого об'єкта модуля із будь якого об'єкта нижче за ієрархією, рекомендується визначити глобальну змінну "mod" у області імен модуля, з ініціалізацією її у конструкторі кореневого об'єкта. Також, для прозорого перекладу текстових повідомлень модуля рекомендується визначити шаблони функцій виклику перекладу повідомлень модуля "<b>_({Повідомлення})</b>" та "<b>trS({Повідомлення})</b>" як:
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span class="cp">#undef _</span>
<span class="cp">#define _(mess) mod-&gt;I18N(mess).c_str()</span>
<span class="cp">#undef trS</span>
<span class="cp">#define trS(mess) mod-&gt;I18N(mess,mess_PreSave)</span>
</pre></div>
<p>У конструкторі кореневого об'єкту модуля успадкованого від <b>TModule</b> необхідно встановити основну інформацію модуля викликом функції <b>void modInfoMainSet({Ім'я}, {Тип}, {Версія}, {Автори}, {Опис}, {Ліцензія}, {Джерело})</b> після ініціалізації швидкого посилання "mod" на кореневий об'єкт цього модуля.
</p><p>Подальше отримання файлу шаблону перекладів "po/oscd_NewMod.pot" текстових повідомлень "<b>_({Повідомлення})</b>" та "<b>trS({Повідомлення})</b>", а також оновлення-актуалізація файлів вже існуючих перекладів "po/{uk|de|ru|...}.po" здійснюється командою у теці модуля <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">make messages</span>.
</p><p>При вирішенні завдань нового модуля може знадобитися розширення параметрів конфігурації, що здійснюється у віртуальній функції <b>void cntrCmdProc( XMLNode *req );</b>. Вміст цієї функції, який додає властивості, у <a href="Modules/SQLite.html" title="Special:MyLanguage/Modules/SQLite">модулі SQLite</a> має вигляд:
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span class="kt">void</span> <span class="n">MBD</span><span class="o">::</span><span class="n">cntrCmdProc</span><span class="p">(</span> <span class="n">XMLNode</span> <span class="o">*</span><span class="n">opt</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//Getting the page info</span>
    <span class="k">if</span><span class="p">(</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="s">"info"</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">TBD</span><span class="o">::</span><span class="n">cntrCmdProc</span><span class="p">(</span><span class="n">opt</span><span class="p">);</span>
        <span class="n">ctrMkNode</span><span class="p">(</span><span class="s">"fld"</span><span class="p">,</span><span class="n">opt</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">"/prm/cfg/ADDR"</span><span class="p">,</span><span class="n">EVAL_STR</span><span class="p">,</span><span class="n">enableStat</span><span class="p">()</span><span class="o">?</span><span class="nl">R_R___</span><span class="p">:</span><span class="n">RWRW__</span><span class="p">,</span><span class="s">"root"</span><span class="p">,</span><span class="n">SDB_ID</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span>
            <span class="s">"dest"</span><span class="p">,</span><span class="s">"sel_ed"</span><span class="p">,</span><span class="s">"select"</span><span class="p">,</span><span class="s">"/prm/cfg/dbFsList"</span><span class="p">,</span><span class="s">"help"</span><span class="p">,</span>
                    <span class="n">_</span><span class="p">(</span><span class="s">"SQLite DB address must be written as: </span><span class="se">\"</span><span class="s">{FileDBPath}</span><span class="se">\"</span><span class="s">.</span><span class="se">\n</span><span class="s">"</span>
                      <span class="s">"Where:</span><span class="se">\n</span><span class="s">"</span>
                      <span class="s">"  FileDBPath - full path to DB file (./oscada/Main.db).</span><span class="se">\n</span><span class="s">"</span>
                      <span class="s">"               Use the empty path to create a temporary database on the disk.</span><span class="se">\n</span><span class="s">"</span>
                      <span class="s">"               Use </span><span class="se">\"</span><span class="s">:memory:</span><span class="se">\"</span><span class="s"> to create a temporary database in memory."</span><span class="p">));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">reqCnt</span><span class="p">)</span>
            <span class="n">ctrMkNode</span><span class="p">(</span><span class="s">"comm"</span><span class="p">,</span><span class="n">opt</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">"/prm/st/end_tr"</span><span class="p">,</span><span class="n">_</span><span class="p">(</span><span class="s">"Close opened transaction"</span><span class="p">),</span><span class="n">RWRW__</span><span class="p">,</span><span class="s">"root"</span><span class="p">,</span><span class="n">SDB_ID</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//Processing for commands to the page</span>
    <span class="n">string</span> <span class="n">a_path</span> <span class="o">=</span> <span class="n">opt</span><span class="o">-&gt;</span><span class="n">attr</span><span class="p">(</span><span class="s">"path"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a_path</span> <span class="o">==</span> <span class="s">"/prm/cfg/dbFsList"</span> <span class="o">&amp;&amp;</span> <span class="n">ctrChkNode</span><span class="p">(</span><span class="n">opt</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">opt</span><span class="o">-&gt;</span><span class="n">childAdd</span><span class="p">(</span><span class="s">"el"</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span><span class="s">":memory:"</span><span class="p">);</span>
        <span class="n">TSYS</span><span class="o">::</span><span class="n">ctrListFS</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="n">addr</span><span class="p">(),</span> <span class="s">"db;"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">a_path</span> <span class="o">==</span> <span class="s">"/prm/st/end_tr"</span> <span class="o">&amp;&amp;</span> <span class="n">ctrChkNode</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span><span class="s">"set"</span><span class="p">,</span><span class="n">RWRW__</span><span class="p">,</span><span class="s">"root"</span><span class="p">,</span><span class="n">SDB_ID</span><span class="p">,</span><span class="n">SEC_WR</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">reqCnt</span><span class="p">)</span> <span class="n">transCommit</span><span class="p">();</span>
    <span class="k">else</span> <span class="n">TBD</span><span class="o">::</span><span class="n">cntrCmdProc</span><span class="p">(</span><span class="n">opt</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Перша половина цієї функції обслуговує інформаційні запити "info" з переліком та властивостями полів конфігурації. Друга половина обслуговує решту команд на отримання, встановлення значення та інше. Виклик <b>TBD::cntrCmdProc(opt);</b> використовується для отримання успадкованого інтерфейсу. Детальніше про призначення використаних функцій дивіться у <a href="../en/API.html#CntrNode" title="Special:MyLanguage/Documents/API">інтерфейсі управління</a>, а також у вихідних текстах існуючих модулів.
</p><p>Об'єкт <b>TCntrNode</b> окрім функції інтерфейсу управління надає уніфіковані механізми контролю за модифікацією конфігурації об'єкта, завантаження, збереження та видалення дублікатів конфігурації у сховищі. Для встановлення прапорця модифікації даних об'єкта можна використовувати функції <b>modif()</b> та <b>modifG()</b>, а специфічні до модуля дії із завантаження та збереження можна розташовувати у віртуальні функції:
</p>
<ul><li> <i>void load_( TConfig *cfg );</i>, <i>void load_( );</i> — завантаження об'єкта зі сховища.</li>
<li> <i>void save_( );</i> — збереження об'єкта у сховищі.</li></ul>
<p>Дії із конфігурацією типово відбуваються за посередництвом об'єкта <a href="../en/API.html#TConfig" title="Special:MyLanguage/Documents/API">TConfig</a>, яких містить набір визначених властивостей зі структурою та значеннями. Для прямого відображення властивостей об'єкта модуля він успадковується від <b>TConfig</b>, а нові властивості додаються командою:
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span class="n">fldAdd</span><span class="p">(</span><span class="k">new</span> <span class="n">TFld</span><span class="p">(</span><span class="s">"MOD_PRMS"</span><span class="p">,</span><span class="n">trS</span><span class="p">(</span><span class="s">"Module addition parameters"</span><span class="p">),</span><span class="n">TFld</span><span class="o">::</span><span class="n">String</span><span class="p">,</span><span class="n">TFld</span><span class="o">::</span><span class="n">FullText</span><span class="o">|</span><span class="n">TCfg</span><span class="o">::</span><span class="n">NoVal</span><span class="p">,</span><span class="s">"100000"</span><span class="p">));</span>
</pre></div>
<p>Завантаження/збереження/видалення властивостей, вказаних у об'єкті <i>TConfig</i>, із/у/в сховище здійснюється командами:
</p>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span class="n">TBDS</span><span class="o">::</span><span class="n">dataGet</span><span class="p">(</span><span class="n">fullDB</span><span class="p">(),</span> <span class="n">owner</span><span class="p">().</span><span class="n">nodePath</span><span class="p">()</span><span class="o">+</span><span class="n">tbl</span><span class="p">(),</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="n">TBDS</span><span class="o">::</span><span class="n">dataSet</span><span class="p">(</span><span class="n">fullDB</span><span class="p">(),</span> <span class="n">owner</span><span class="p">().</span><span class="n">nodePath</span><span class="p">()</span><span class="o">+</span><span class="n">tbl</span><span class="p">(),</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="n">TBDS</span><span class="o">::</span><span class="n">dataDel</span><span class="p">(</span><span class="n">fullDB</span><span class="p">(</span><span class="n">flag</span><span class="o">&amp;</span><span class="n">NodeRemoveOnlyStor</span><span class="p">),</span> <span class="n">owner</span><span class="p">().</span><span class="n">nodePath</span><span class="p">()</span><span class="o">+</span><span class="n">tbl</span><span class="p">(),</span> <span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">TBDS</span><span class="o">::</span><span class="n">UseAllKeys</span><span class="p">);</span>
</pre></div>
<p>Де:
</p>
<ul><li> <i>fullDB()</i> — повна назва сховища у <a href="../en/API.html#DataConcept" title="Special:MyLanguage/Documents/API">загальній формі</a>;</li>
<li> <i>owner().nodePath()+tbl()</i> — загальний шлях до вузла об'єкта у конфігураційному файлі, представлений таблицею;</li>
<li> <i>*this</i> — цей об'єкт, успадкований від <b>TConfig</b>.</li></ul>
<p>Для генерації налагоджувальних повідомлень <a href="Program_manual.html#Config" title="Special:MyLanguage/Documents/Program manual">відповідно до загальної концепції налаштувань</a> необхідно використовувати функцію <b>mess_debug()</b> з умовою виклику залежно від ділянки вихідного тексту програми:
</p>
<ul><li> рідко викликувана ділянка — прямий виклик функції <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">mess_debug(...);</span>;</li>
<li> часто викликувана ділянка — умовний виклик <span style="border: solid gray 1px; padding: 1px; font-family: monospace; font-size: 1.2em;">if(mess_lev() == TMess::Debug) mess_debug(...);</span>;</li>
<li> критична до продуктивності ділянка коду — обгортання у визначення <b>OSC_DEBUG</b>:</li></ul>
<div class="mw-highlight mw-content-ltr" dir="ltr"><pre><span class="cp">#ifdef OSC_DEBUG</span>
  <span class="n">mess_debug</span><span class="p">(...);</span>
<span class="cp">#endif</span>
</pre></div>






</div><table style="border-top: dotted 2px #999999; margin-top: 20pt; color: gray;" width="100%"><tr><td style="text-align: left;" width="40%"><a href="http://oscada.org/wiki/Documents/How_to/Create_module/uk">Documents/How_to/Create_module/uk</a> - <a href="http://oscada.org/en/main/about-the-project/licenses/">GFDL</a></td><td style="text-align: center;">December 2022</td><td style="text-align: right;" width="40%"> 1+r2862</td></tr></table></body>
</html>