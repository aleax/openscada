<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="UTF-8" />
<title>Бібліотеки/НизькоРівневіПристрої - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../en/files/doc.css" rel="stylesheet" /></head>
<body><div class="floatright"><a href="http://oscada.org"><img alt="OpenSCADA" src="../en/files/Logo-big.png" /></a></div><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="uk">Бібліотеки/НизькоРівневіПристрої</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="uk"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Libs%2FLowLevelDevices&amp;action=page&amp;filter=&amp;language=uk" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Libs/LowLevelDevices" title="Libs/LowLevelDevices">Libs/LowLevelDevices</a> and the translation is 17% complete.</div><hr /><div class="mw-pt-languages" dir="ltr" lang="en"><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="../en/Libs_LowLevelDevices.html" title="Libs/LowLevelDevices (100% translated)">English</a>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--stub" href="../ru/Libs_LowLevelDevices.html" title="Библиотеки/НизкоУровневыеУстройства (17% translated)">российский</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--stub">українська</span></div></div>
<table class="wikitable">

<tr>
<th> Назва </th>
<th> Версія </th>
<th> Ліцензія </th>
<th> Джерело </th>
<th> Мови </th>
<th> Автор </th>
<th> Опис
</th></tr>

<tr>
<td> <a href="Libs_LowLevelDevices.html" title="Special:MyLanguage/Libs/LowLevelDevices">Бібліотека низькорівневих сенсорів та чипів</a>
</td>
<td> 1.4 </td>
<td> GPLv2 </td>
<td> OscadaLibs.db (<a class="external text" href="http://oscada.org/svn/trunk/OpenSCADA/data/LibsDB/OscadaLibs.sql" rel="nofollow noreferrer noopener" target="_blank">SQL</a>, <a class="external" href="http://oscada.org/wiki/File:OscadaLibs.db.gz" title="File:OscadaLibs.db.gz">GZip</a>) &gt; DAQ.tmplb_LowDevLib </td>
<td> en, uk, ru
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Роман Савоченко</a><br />&nbsp;&nbsp;<font size="-2"><i>Аркадій Кисіль (2017)</i></font>
</td>
<td> Бібліотека шаблонів надання доступу до даних пристроїв низькорівневих шин.
<ul><li> <b>Засновано</b>: Липень 2016</li>
<li> <b>Початково створено:</b> у <a class="external text" href="http://wiki.oscada.org/HomePageEn/Using/APIFunctionLibs/LibUserPrtDevs" rel="nofollow noreferrer noopener" target="_blank">старій Wiki</a></li>
<li> <b>Використано:</b> <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Sub-projects/Server" title="Special:MyLanguage/Sub-projects/Server">проектами розумних будинків</a></li>
<li> <b>Зробити (To Do):</b></li></ul>
<dl><dd>- комбінувати <a href="Libs_LowLevelDevices.html#1W_DS9097" title="Special:MyLanguage/Libs/LowLevelDevices">1W шаблони</a> у один складний та доповнити 1W роботою безпосередньо через GPIO.</dd></dl>
</td></tr></table>
<p>Бібліотеку пристроїв користувацьких протоколів створено для надання доступу до даних пристроїв низькорівневих шин, із протоколом достатньо простим до реалізації у <a href="Modules/UserProtocol.html" title="Special:MyLanguage/Modules/UserProtocol">модулі користувацького протоколу</a> або безпосередньо на <a href="Modules/JavaLikeCalc.html" title="Special:MyLanguage/Modules/JavaLikeCalc">внутрішній мові подібній до Java</a>.
</p><p>Назви елементів та їх параметрів доступні на мовах: Англійська, Українська та Російська. Їх вихідний код написано у мово(людська)-незалежному режимі з викликом функції перекладу <i>tr()</i> та переклад цих повідомлень також доступний Англійською, Українською та Російською.
</p><p>Для підключення бібліотеки до проекту станції OpenSCADA ви можете отримати файл БД як:
</p>
<ul><li> такий що постачається з готовим та відповідним пакетом дистрибутиву Linux на кшталт "openscada-libdb-main", "openscada-LibDB.Main";</li>
<li> найбільш актуальний та безпосередньо отриманий з <a class="external text" href="http://oscada.org/svn/trunk/OpenSCADA/data/LibsDB/OscadaLibs.sql" rel="nofollow noreferrer noopener" target="_blank">репозиторію subversion</a>, перетворений у файл БД SQLite шляхом:</li></ul>
<pre style="white-space: pre-wrap; margin-left: 15px">
$ wget http://oscada.org/svn/trunk/OpenSCADA/data/LibsDB/OscadaLibs.sql
$ sqlite3 -init OscadaLibs.sql OscadaLibs.db .exit
</pre>
<ul><li> завантаження <a class="external" href="http://oscada.org/wiki/File:OscadaLibs.db.gz" title="File:OscadaLibs.db.gz">прикріпленого тут</a>.</li></ul>
<p>Цей отриманий файл ви надалі можете розмістити у теці проекту станції та створити об'єкт бази даних модуля БД "SQLite", зареєструвавши файл бази даних у конфігурації.
</p>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1"><a href="#One_Wire_by_DS9097_.281W_DS9097.29"><span class="tocnumber">1</span> <span class="toctext">One Wire by DS9097 (1W_DS9097)</span></a></li>
<li class="toclevel-1"><a href="#One_Wire_by_DS9097U_.281W_DS9097U.29"><span class="tocnumber">2</span> <span class="toctext">One Wire by DS9097U (1W_DS9097U)</span></a></li>
<li class="toclevel-1"><a href="#I2C:_PCF8591_.28PCF8591.29"><span class="tocnumber">3</span> <span class="toctext">I2C: PCF8591 (PCF8591)</span></a></li>
<li class="toclevel-1"><a href="#I2C:_PCF8574_.28PCF8574.29"><span class="tocnumber">4</span> <span class="toctext">I2C: PCF8574 (PCF8574)</span></a></li>
<li class="toclevel-1"><a href="#I2C:_ADS101x.2C_ADS111x_.28ADS111x.29"><span class="tocnumber">5</span> <span class="toctext">I2C: ADS101x, ADS111x (ADS111x)</span></a></li>
<li class="toclevel-1"><a href="#I2C:_MCP4725_.28MCP4725.29"><span class="tocnumber">6</span> <span class="toctext">I2C: MCP4725 (MCP4725)</span></a></li>
<li class="toclevel-1"><a href="#I2C:_BMP180_.28BMP180.29"><span class="tocnumber">7</span> <span class="toctext">I2C: BMP180 (BMP180)</span></a></li>
<li class="toclevel-1"><a href="#I2C:_BME280_.28BME280.29"><span class="tocnumber">8</span> <span class="toctext">I2C: BME280 (BME280)</span></a></li>
<li class="toclevel-1"><a href="#I2C:_SHT3x_.28SHT3x.29"><span class="tocnumber">9</span> <span class="toctext">I2C: SHT3x (SHT3x)</span></a></li>
<li class="toclevel-1"><a href="#I2C:_DS1307.2CDS3231_.28DS3231.29"><span class="tocnumber">10</span> <span class="toctext">I2C: DS1307,DS3231 (DS3231)</span></a></li>
<li class="toclevel-1"><a href="#I2C:_AT24C.7B32.7C64.7D_.28AT24CXX.29"><span class="tocnumber">11</span> <span class="toctext">I2C: AT24C{32|64} (AT24CXX)</span></a></li>
<li class="toclevel-1"><a href="#GPIO:_DHT11.2C22_.28DHT.29"><span class="tocnumber">12</span> <span class="toctext">GPIO: DHT11,22 (DHT)</span></a></li>
<li class="toclevel-1"><a href="#GPIO:_MAX6675_.28MAX6675.29"><span class="tocnumber">13</span> <span class="toctext">GPIO: MAX6675 (MAX6675)</span></a></li>
<li class="toclevel-1"><a href="#GPIO.7CI2C:_1602A.28HD44780.29_.281602A.29"><span class="tocnumber">14</span> <span class="toctext">GPIO|I2C: 1602A(HD44780) (1602A)</span></a></li>
</ul>
</div>

<p>Для DAQ-шаблонів, загалом, вам треба створити представницький об'єкт пристрою у <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">модулі Логічного контролеру</a> та обрати відповідний шаблон із бібліотеки шаблонів. Далі, для коректної конфігурації, дотримуйтесь специфіки шаблону у його особистому описі.
Концепцію доступу до даних через користувацький протокол можна зобразити як на рисунку 1.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:324px;"><a class="image" href="http://oscada.org/wiki/File:UserPrtDevs_concept_uk.png"><img class="thumbimage" height="275" src="files/UserPrtDevs_concept_uk.png" width="322" /></a>  <div class="thumbcaption">Рис.1. Концепція доступу до даних через користувацький протокол.</div></div></div></div>
<p>Як можна бачити з рисунку 1, взаємодія з пристроєм відбувається через деякий транспорт на якому вони фізично базуються. Запит до транспорту Ви можете надіслати:
</p>
<ol><li> Безпосередньо за допомогою функції системного API OpenSCADA об'єкту транспорту <i><a href="User_API.html#SYSTransport" title="Special:MyLanguage/Documents/User API">string messIO( string mess, real timeOut = 0 );</a></i>, якщо протоколоспецифічна частина дуже проста та дані вам потрібно лише вилучити.</li>
<li> Загорнутий запит даних <i>req</i>, функцією <i><a href="User_API.html#SYSTransport" title="Special:MyLanguage/Documents/User API">int messIO( XMLNodeObj req, string prt );</a></i> та для протоколу <i>prt</i>, якщо протокольна частина достатньо складна та вже представлена у OpenSCADA.</li>
<li> Загорнутий запит даних специфічний до користувача за допомогою функції <i><a href="User_API.html#SYSTransport" title="Special:MyLanguage/Documents/User API">int messIO( XMLNodeObj req, "UserProtocol" );</a></i> та реалізації <a href="Modules/UserProtocol.html" title="Special:MyLanguage/Modules/UserProtocol">користувацького протоколу</a>, якщо протокольна частина достатньо складна та ще відсутня у OpenSCADA. Користувач реалізує тут саму протоколоспецифічну частину у <a href="Modules/UserProtocol.html" title="Special:MyLanguage/Modules/UserProtocol">модулі UserProtocol</a> та частину специфічну до даних у шаблоні для <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">модуля Логічного Рівня</a> або безпосередньо у процедурі контролеру на внутрішній мові програмування <a href="Modules/JavaLikeCalc.html" title="Special:MyLanguage/Modules/JavaLikeCalc">модуля JavaLikeCalc</a>. </li></ol>
<dl><dd><dl><dd> <a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../en/files/At.png" width="22" /></a> Цей останній метод наразі розвинено до можливості формування протокольної частини коду безпосередньо у тому-ж коді шаблону, як окрема вбудована функція через виклик функції запиту першого методу, якщо немає потреби повторного використання, або навіть якщо така потреба є та тут має сенс створення комплексного шаблону, який зможе поєднувати роль й вихідного протоколу, через його підключення також до модуля користувацького протоколу. Та воно буде повністю зберігатися у одній бібліотеці шаблонів. </dd></dl></dd></dl>
<p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../en/files/At.png" width="22" /></a> Пряма робота із вихідним транспортом функції <a href="User_API.html#SYSTransport" title="Special:MyLanguage/Documents/User API">string messIO( string mess, real timeOut = 0 );</a> не передбачає блокування транспорту поза викликом цієї функції, а відтак, для складних протоколів із посилками відповіді більш ніж у одному пакеті, що передбачає процес "доочікування", не можна використовувати спільний транспорт, за яким можливе надсилання пакетів різних протоколів або навіть один, але з різних завдань (об'єктів контролерів). Відтак, якщо є потреба використання спільного транспорту, то розташовуйте параметри опитування за протоколом у одному об'єкті контролеру (завдані) або використовуйте <a href="Modules/UserProtocol.html" title="Special:MyLanguage/Modules/UserProtocol">модуль користувацького протоколу</a>, до якого це зауваження не має стосунку, оскільки він здійснює таке блокування на час виклику процедури обробки, як і решта модульних протоколів OpenSCADA. 
Для розташування реалізації протоколу тут ви маєте виконати та дотримуватися наведених вимог:
</p>
<ul><li> бути власником прав або автором коду та розповсюджувати його під будь-якою вільною ліцензією, перевага надається GPL;</li>
<li> приготувати та зберегти у окремому файлі БД SQLite, або як текстовий файл, щодо: опису параметрів (ВВ), коду процедури написаному та відформатованому за якоюсь системою;</li>
<li> написати короткий опис та інструкцію підключення пристрою за протоколом у спосіб схожий на інші тут;</li>
<li> написати прямий запит до теми форуму "<a class="external text" href="http://oscada.org/ua/forum/topics/rozrobka_openscada/" rel="nofollow noreferrer noopener" target="_blank">Розробка OpenSCADA</a>" щодо розташування протоколу тут, включити докази його працездатності від будь-якого розробника OpenSCADA або коротке демонстраційне відео.</li></ul>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="1W_DS9097" title="#1W_DS9097"><h3><span class="mw-headline" id="One_Wire_by_DS9097_.281W_DS9097.29"><span class="mw-headline-number">1</span> One Wire by DS9097 (<a href="Libs_LowLevelDevices.html#1W_DS9097" title="Special:MyLanguage/Libs/LowLevelDevices">1W_DS9097</a>)</span></h3></span> </td>
<td> 1.2 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en
</td></tr>
<tr>
<td> <span id="1W_DS9097U" title="#1W_DS9097U"><h3><span class="mw-headline" id="One_Wire_by_DS9097U_.281W_DS9097U.29"><span class="mw-headline-number">2</span> One Wire by DS9097U (<a href="Libs_LowLevelDevices.html#1W_DS9097U" title="Special:MyLanguage/Libs/LowLevelDevices">1W_DS9097U</a>)</span></h3></span> </td>
<td> 1.2 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<div class="floatright"><a class="image" href="http://oscada.org/wiki/File:LibsLowLevDevs1WOp.png" title="Result and the operative setup."><img alt="Result and the operative setup." height="655" src="../en/files/LibsLowLevDevs1WOp.png" width="386" /></a></div>
<p><span id="1W" title="#1W">One Wire</span> sensors bus implementing by 1Wire-adapter {DS9097,DS9097U}. Supported direct and parasite powering for the temperature sensors.<br />
Supported 1Wire-devices: DS1820, DS1820/DS18S20/DS1920 (not tested), DS1822 (not tested), DS2413, DS2408, DS2450, DS2438.<br />
<a class="image" href="http://oscada.org/wiki/File:Ds9097.png"><img alt="Ds9097.png" height="265" src="../en/files/Ds9097.png" width="800" /></a>
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> transport </td>
<td> Transport of the One Wire bus, Serial </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> oneWire
</td></tr>
<tr>
<td> tmResc </td>
<td> Rescan period, s </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 60
</td></tr>
<tr>
<td> power </td>
<td> Power, for temperature </td>
<td> Boolean </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> this </td>
<td> Object </td>
<td> Object </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<div class="floatright"><a class="image" href="http://oscada.org/wiki/File:LibsLowLevDevs1WCfg.png" title="Configuration."><img alt="Configuration." height="240" src="../en/files/LibsLowLevDevs1WCfg.png" width="384" /></a></div>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output transport of the type "<a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a>" and set its Identifier like to "oneWire", one for each the One Wire bus.</dd>
<dd>2. Set proper address of the <a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> device, only for the adapter's serial device like "/dev/ttyS{N}". The serial port speed, asynchronous data format and timeouts will adjust by the template.</dd>
<dd>3. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties.</dd>
<dd>4. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter object</a> and select the template for that, one for each the devices. Enable the parameter.</dd>
<dd>5. Into the tab "Template configuration" of the logical parameter object you need to set:
<ul><li> <i>Transport of the One Wire bus, Serial</i> — to the address of the transport into step 1. Tracing for the address changing is supported.</li>
<li> <i>Rescan period, s</i> — periodicity of rescaning for new and removed devices search.</li></ul></dd>
<dd>6. <i>Result</i>: The logical parameter object will perform at first searching to 1Wire devices on the bus and create included parameters to the each found one. Next the logical parameter object will perform gather data of the found devices and trace to modify of the writable device's properties.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="PCF8591" title="#PCF8591"><h3><span class="mw-headline" id="I2C:_PCF8591_.28PCF8591.29"><span class="mw-headline-number">3</span> I2C: PCF8591 (<a href="Libs_LowLevelDevices.html#PCF8591" title="Special:MyLanguage/Libs/LowLevelDevices">PCF8591</a>)</span></h3></span> </td>
<td> 1.0 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<p>I2C 8-bit 4xA/D and D/A converter. Connects through a Serial output transport into the I2C mode.
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> transport </td>
<td> Transport of the I2C, Serial </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> i2c
</td></tr>
<tr>
<td> addr </td>
<td> Device address [0...119] </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 72
</td></tr>
<tr>
<td> vRef </td>
<td> Reference voltage, V </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 3.2
</td></tr>
<tr>
<td> ai0 </td>
<td> AI0 </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> ai1 </td>
<td> AI1 </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> ai2 </td>
<td> AI2 </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> ai3 </td>
<td> AI3 </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> ao </td>
<td> AO </td>
<td> Real </td>
<td> Input </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output transport of the type "<a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a>" and set its Identifier like to "i2c", one for each the I2C bus.</dd>
<dd>2. Set proper address of the <a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> device, only the I2C bus address like "/dev/i2c-{N}". Set the symbol's time into the timeouts field to the minimum value.</dd>
<dd>3. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties.</dd>
<dd>4. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter object</a> and select the template for that, one for each I2C slave devices. Enable the parameter.</dd>
<dd>5. Into the tab "Template configuration" of the logical parameter object you need to set:
<ul><li> <i>transport</i> — to the address of the transport into step 1. Tracing for the address changing is supported.</li>
<li> <i>addr</i> — the I2C slave device's address [0...119].</li>
<li> <i>vRef</i> — reference voltage of the AIs and AO.</li></ul></dd>
<dd>6. <i>Result</i>: The logical parameter object will perform interaction and placing of gathered data to the AI attributes and also will take the AO and write to the chip.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="PCF8574" title="#PCF8574"><h3><span class="mw-headline" id="I2C:_PCF8574_.28PCF8574.29"><span class="mw-headline-number">4</span> I2C: PCF8574 (<a href="Libs_LowLevelDevices.html#PCF8574" title="Special:MyLanguage/Libs/LowLevelDevices">PCF8574</a>)</span></h3></span> </td>
<td> 1.0 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<p>I2C 8-bit 8DIO. Connects through a Serial output transport into the I2C mode.
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> transport </td>
<td> Transport I2C </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> i2c
</td></tr>
<tr>
<td> addr </td>
<td> Device address (0, 119) </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 39
</td></tr>
<tr>
<td> di0 </td>
<td> DI0 </td>
<td> Boolean </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> di1 </td>
<td> DI1 </td>
<td> Boolean </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> di2 </td>
<td> DI2 </td>
<td> Boolean </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> di3 </td>
<td> DI3 </td>
<td> Boolean </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> di4 </td>
<td> DI4 </td>
<td> Boolean </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> di5 </td>
<td> DI5 </td>
<td> Boolean </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> di6 </td>
<td> DI6 </td>
<td> Boolean </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> di7 </td>
<td> DI7 </td>
<td> Boolean </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> do0 </td>
<td> DO0 </td>
<td> Boolean </td>
<td> Output </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> do1 </td>
<td> DO1 </td>
<td> Boolean </td>
<td> Output </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> do2 </td>
<td> DO2 </td>
<td> Boolean </td>
<td> Output </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> do3 </td>
<td> DO3 </td>
<td> Boolean </td>
<td> Output </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> do4 </td>
<td> DO4 </td>
<td> Boolean </td>
<td> Output </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> do5 </td>
<td> DO5 </td>
<td> Boolean </td>
<td> Output </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> do6 </td>
<td> DO6 </td>
<td> Boolean </td>
<td> Output </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> do7 </td>
<td> DO7 </td>
<td> Boolean </td>
<td> Output </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output transport of the type "<a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a>" and set its Identifier like to "i2c", one for each the I2C bus.</dd>
<dd>2. Set proper address of the <a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> device, only the I2C bus address like "/dev/i2c-{N}". Set the symbol's time into the timeouts field to the minimum value.</dd>
<dd>3. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties.</dd>
<dd>4. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter object</a> and select the template for that, one for each I2C slave devices. Enable the parameter.</dd>
<dd>5. Into the tab "Template configuration" of the logical parameter object you need to set:
<ul><li> <i>transport</i> — to the address of the transport into step 1. Tracing for the address changing is supported.</li>
<li> <i>addr</i> — the I2C slave device's address [0...119].</li></ul></dd>
<dd>6. <i>Result</i>: The logical parameter object will perform interaction and placing of gathered data to the DI attributes and also will take the DO and write to the chip.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="ADS111x" title="#ADS111x"><h3><span class="mw-headline" id="I2C:_ADS101x.2C_ADS111x_.28ADS111x.29"><span class="mw-headline-number">5</span> I2C: ADS101x, ADS111x (<a href="Libs_LowLevelDevices.html#ADS111x" title="Special:MyLanguage/Libs/LowLevelDevices">ADS111x</a>)</span></h3></span> </td>
<td> 1.0 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<p>I2C 12/16-bit 4xA/D converter. Connect through a Serial output transport into the I2C mode.
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> transport </td>
<td> Transport of the I2C, Serial </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> i2c
</td></tr>
<tr>
<td> addr </td>
<td> Device address [0...119] </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 72
</td></tr>
<tr>
<td> range </td>
<td> Range, ±V </td>
<td> Integer numbers selection </td>
<td> Input </td>
<td> Full access </td>
<td> Variable </td>
<td> 2<br />
<p>0;1;2;3;4;5<br />
6.144;4.096;2.048;1.024;0.512;0.256
</p>
</td></tr>
<tr>
<td> ai0 </td>
<td> AI0 </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> ai1 </td>
<td> AI1 </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> ai2 </td>
<td> AI2 </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> ai3 </td>
<td> AI3 </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output transport of the type "<a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a>" and set its Identifier like to "i2c", one for each the I2C bus.</dd>
<dd>2. Set proper address of the <a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> device, only the I2C bus address like "/dev/i2c-{N}". Set the symbol's time into the timeouts field to the minimum value.</dd>
<dd>3. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties.</dd>
<dd>4. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter object</a> and select the template for that, one for each I2C slave devices. Enable the parameter.</dd>
<dd>5. Into the tab "Template configuration" of the logical parameter object you need to set:
<ul><li> <i>transport</i> — to the address of the transport into step 1. Tracing for the address changing is supported.</li>
<li> <i>addr</i> — the I2C slave device's address [0...119].</li>
<li> <i>range</i> — range of voltage of the AIs.</li></ul></dd>
<dd>6. <i>Result</i>: The logical parameter object will perform interaction and placing of gathered data to the AI attributes.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="MCP4725" title="#MCP4725"><h3><span class="mw-headline" id="I2C:_MCP4725_.28MCP4725.29"><span class="mw-headline-number">6</span> I2C: MCP4725 (<a href="Libs_LowLevelDevices.html#MCP4725" title="Special:MyLanguage/Libs/LowLevelDevices">MCP4725</a>)</span></h3></span> </td>
<td> 1.0 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<p>I2C 12-bit D/A converter. Connect through a Serial output transport into the I2C mode.
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> transport </td>
<td> Transport of the I2C, Serial </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> i2c
</td></tr>
<tr>
<td> addr </td>
<td> Device address [0...119] </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 96
</td></tr>
<tr>
<td> vRef </td>
<td> Reference voltage, V </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 3.2
</td></tr>
<tr>
<td> ao </td>
<td> AO </td>
<td> Real </td>
<td> Input </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output transport of the type "<a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a>" and set its Identifier like to "i2c", one for each the I2C bus.</dd>
<dd>2. Set proper address of the <a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> device, only the I2C bus address like "/dev/i2c-{N}". Set the symbol's time into the timeouts field to the minimum value.</dd>
<dd>3. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties.</dd>
<dd>4. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter object</a> and select the template for that, one for each I2C slave devices. Enable the parameter.</dd>
<dd>5. Into the tab "Template configuration" of the logical parameter object you need to set:
<ul><li> <i>transport</i> — to the address of the transport into step 1. Tracing for the address changing is supported.</li>
<li> <i>addr</i> — the I2C slave device's address [0...119].</li>
<li> <i>vRef</i> — reference voltage of the AO.</li></ul></dd>
<dd>6. <i>Result</i>: The logical parameter object will perform interaction and take the AO and write to the chip.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="BMP180" title="#BMP180"><h3><span class="mw-headline" id="I2C:_BMP180_.28BMP180.29"><span class="mw-headline-number">7</span> I2C: BMP180 (<a href="Libs_LowLevelDevices.html#BMP180" title="Special:MyLanguage/Libs/LowLevelDevices">BMP180</a>)</span></h3></span> </td>
<td> 1.0 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<p>I2C Pressure and Temperature sensor. Connecting through a Serial output transport into the I2C mode.
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> transport </td>
<td> Transport of the I2C, Serial </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> i2c
</td></tr>
<tr>
<td> addr </td>
<td> Device address [0...119] </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 119
</td></tr>
<tr>
<td> oss </td>
<td> Oversampling setting (0...3) </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 0
</td></tr>
<tr>
<td> t </td>
<td> T, °С </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable	 </td>
<td>
</td></tr>
<tr>
<td> p </td>
<td> P, Pa </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output transport of the type "<a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a>" and set its Identifier like to "i2c", one for each the I2C bus.</dd>
<dd>2. Set proper address of the <a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> device, only the I2C bus address like "/dev/i2c-{N}". Set the symbol's time into the timeouts field to the minimum value.</dd>
<dd>3. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties.</dd>
<dd>4. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter object</a> and select the template for that, one for each I2C slave devices. Enable the parameter.</dd>
<dd>5. Into the tab "Template configuration" of the logical parameter object you need to set:
<ul><li> <i>transport</i> — to the address of the transport into step 1. Tracing for the address changing is supported.</li>
<li> <i>addr</i> — the I2C slave device's address [0...119].</li>
<li> <i>oss</i> — oversampling setting of pressure measurement [0...3].</li></ul></dd>
<dd>6. <i>Result</i>: The logical parameter object will perform interaction and placing of gathered data to the Pressure and Temperature attributes.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="BME280" title="#BME280"><h3><span class="mw-headline" id="I2C:_BME280_.28BME280.29"><span class="mw-headline-number">8</span> I2C: BME280 (<a href="Libs_LowLevelDevices.html#BME280" title="Special:MyLanguage/Libs/LowLevelDevices">BME280</a>)</span></h3></span> </td>
<td> 1.0 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> Arcadiy Kisel, <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<p>I2C Barometric Pressure, Temperature and Humidity sensor. Connect through a Serial output transport into the I2C mode.
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> transport </td>
<td> Transport of the I2C, Serial </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> i2c
</td></tr>
<tr>
<td> addr </td>
<td> Device address [0...119] </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 118
</td></tr>
<tr>
<td> oss </td>
<td> Oversampling setting (0...7) </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 0
</td></tr>
<tr>
<td> t </td>
<td> T, °С </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable	 </td>
<td>
</td></tr>
<tr>
<td> p </td>
<td> P, Pa </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> h </td>
<td> H,&nbsp;% </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output transport of the type "<a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a>" and set its Identifier like to "i2c", one for each the I2C bus.</dd>
<dd>2. Set proper address of the <a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> device, only the I2C bus address like "/dev/i2c-{N}". Set the symbol's time into the timeouts field to the minimum value.</dd>
<dd>3. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties.</dd>
<dd>4. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter object</a> and select the template for that, one for each I2C slave devices. Enable the parameter.</dd>
<dd>5. Into the tab "Template configuration" of the logical parameter object you need to set:
<ul><li> <i>transport</i> — to the address of the transport into step 1. Tracing for the address changing is supported.</li>
<li> <i>addr</i> — the I2C slave device's address [0...119].</li>
<li> <i>oss</i> — oversampling setting of pressure measurement [0...7].</li></ul></dd>
<dd>6. <i>Result</i>: The logical parameter object will perform interaction and placing of gathered data to the Pressure, Temperature and Humidity attributes.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="SHT3x" title="#SHT3x"><h3><span class="mw-headline" id="I2C:_SHT3x_.28SHT3x.29"><span class="mw-headline-number">9</span> I2C: SHT3x (<a href="Libs_LowLevelDevices.html#SHT3x" title="Special:MyLanguage/Libs/LowLevelDevices">SHT3x</a>)</span></h3></span> </td>
<td> 1.0 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<p>Digital Temperature and Humidity Sensor for the models: SHT30
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> transport </td>
<td> Transport of the I2C, Serial </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> i2c
</td></tr>
<tr>
<td> addr </td>
<td> Device address [0...119] </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 68
</td></tr>
<tr>
<td> H </td>
<td> Humidity </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> T </td>
<td> Temperature </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output transport of the type "<a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a>" and set its Identifier like to "i2c", one for each the I2C bus.</dd>
<dd>2. Set proper address of the <a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> device, only the I2C bus address like "/dev/i2c-{N}". Set the symbol's time into the timeouts field to the minimum value.</dd>
<dd>3. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties.</dd>
<dd>4. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter object</a> and select the template for that, one for each I2C slave devices. Enable the parameter.</dd>
<dd>5. Into the tab "Template configuration" of the logical parameter object you need to set:
<ul><li> <i>transport</i> — to the address of the transport into step 1. Tracing for the address changing is supported;</li>
<li> <i>addr</i> — the I2C slave device's address [0...119].</li></ul></dd>
<dd>6. <i>Result</i>: The logical parameter object will perform interaction and placing of gathered data to the Temperature and Humidity attributes.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="DS3231" title="#DS3231"><h3><span class="mw-headline" id="I2C:_DS1307.2CDS3231_.28DS3231.29"><span class="mw-headline-number">10</span> I2C: DS1307,DS3231 (<a href="Libs_LowLevelDevices.html#DS3231" title="Special:MyLanguage/Libs/LowLevelDevices">DS3231</a>)</span></h3></span> </td>
<td> 1.1 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<p>I2C RTC chips DS1307,DS3231 with Temperature sensor and calibration for DS3231. Connects through a Serial output transport into the I2C mode.
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> transport </td>
<td> Transport of the I2C, Serial </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> i2c
</td></tr>
<tr>
<td> addr </td>
<td> Device address [0...119] </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 119
</td></tr>
<tr>
<td> mode </td>
<td> Mode </td>
<td> Integer numbers selection </td>
<td> Input </td>
<td> Full access </td>
<td> Variable </td>
<td> 0
<p>0;1<br />
DS3231;DS1307
</p>
</td></tr>
<tr>
<td> tm </td>
<td> Date and time, YYYY-MM-DDTHH:mm:SS </td>
<td> String </td>
<td> Input </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> pSQW </td>
<td> Enable SQUARE-WAVE OUTPUT </td>
<td> Boolean </td>
<td> Input </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> pSQWf<br />(dynamically updated) </td>
<td> SQUARE-WAVE OUTPUT frequency </td>
<td> Integer </td>
<td> Input </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> agOff<br />(dynamically created for DS3231) </td>
<td> Aging offset, [-128...127] </td>
<td> Integer </td>
<td> Input </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> t<br />(dynamically created for DS3231) </td>
<td> T, °С </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> p32k<br />(dynamically created for DS3231) </td>
<td> Enable 32768Hz </td>
<td> Boolean </td>
<td> Input </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output transport of the type "<a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a>" and set its Identifier like to "i2c", one for each the I2C bus.</dd>
<dd>2. Set proper address of the <a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> device, only the I2C bus address like "/dev/i2c-{N}". Set the symbol's time into the timeouts field to the minimum value.</dd>
<dd>3. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties.</dd>
<dd>4. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter object</a> and select the template for that, one for each I2C slave devices. Enable the parameter.</dd>
<dd>5. Into the tab "Template configuration" of the logical parameter object you need to set:
<ul><li> <i>transport</i> — to the address of the transport into step 1. Tracing for the address changing is supported.</li>
<li> <i>addr</i> — the I2C slave device's address [0...119].</li></ul></dd>
<dd>6. <i>Result</i>: The logical parameter object will perform interaction and placing of gathered data to the DateTime, Temperature and some one state attributes and also will take the DateTime, some one state attributes and write it to the chip.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="AT24CXX" title="#AT24CXX"><h3><span class="mw-headline" id="I2C:_AT24C.7B32.7C64.7D_.28AT24CXX.29"><span class="mw-headline-number">11</span> I2C: AT24C{32|64} (<a href="Libs_LowLevelDevices.html#AT24CXX" title="Special:MyLanguage/Libs/LowLevelDevices">AT24CXX</a>)</span></h3></span> </td>
<td> 1.0 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<p>Provides operations with EEPROM memory based on I2C chips AT24C32 (4KB) and AT24C64 (8KB). Supported random reading and writing.
</p><p><b><u>Output user protocol's XML request structure</u></b><br />
<b>&lt;{cmd} addr="{ChipAddr}" off="{MemOffset}" size="{ReadSize}" err="1:Error"&gt;{ReadWriteSeq}&lt;/{cmd}&gt;</b>
</p>
<dl><dd><i>cmd</i> — command, for now there allowed: "read", "write";</dd>
<dd><i>addr</i> — I2C device address [0...119];</dd>
<dd><i>off</i> — memory part offset;</dd>
<dd><i>size</i> — read memory block size.</dd>
<dd><i>ReadWriteSeq</i> — Read/Write bytes sequence.</dd>
<dd><i>err</i> — sets to result of the request.</dd></dl>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output transport of the type "<a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a>" and set its Identifier like to "i2c", one for each the I2C bus.</dd>
<dd>2. Set proper address of the <a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> device, only the I2C bus address like "/dev/i2c-{N}". Set the symbol's time into the timeouts field to the minimum value.</dd>
<dd>3. Place some requesting commands directly into presented or a new internal OpenSCADA procedure like to:</dd></dl>
<pre style="white-space: pre-wrap; align-left: 30px">
req = SYS.XMLNode("read"); req.setAttr("ProtIt","AT24CXX").setAttr("addr",87).setAttr("off",1000).setAttr("size",20).setText("My message");
req = SYS.XMLNode("write"); req.setAttr("ProtIt","AT24CXX").setAttr("addr",87).setAttr("off",1000).setText("Stored data");
</pre>
<dl><dd>4. <i>Result</i>: Into <i>text()</i> for "read" you will get the read data if no errors occur.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="DHT" title="#DHT"><h3><span class="mw-headline" id="GPIO:_DHT11.2C22_.28DHT.29"><span class="mw-headline-number">12</span> GPIO: DHT11,22 (<a href="Libs_LowLevelDevices.html#DHT" title="Special:MyLanguage/Libs/LowLevelDevices">DHT</a>)</span></h3></span> </td>
<td> 1.0 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<p>Digital Temperature and Humidity Sensor for models: DHT11, DHT12, AM2302, AM2320, ... . The module designed for the sensors connect through GPIO, mostly it's <a href="Modules/GPIO.html" title="Special:MyLanguage/Modules/GPIO">Raspberry PI BCM2835 GPIO</a>.<br />
<i>Conditions:</i> Exclusively realtime planing in the priority 199 (FIFO-99).
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> addr </td>
<td> GPIO address with functions mode(), get() and put(), mostly it's BCM2835 </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> DAQ.GPIO.io.pi
</td></tr>
<tr>
<td> pin </td>
<td> IO pin number of the GPIO </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 17
</td></tr>
<tr>
<td> tries </td>
<td> Tries [1...5] </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 2
</td></tr>
<tr>
<td> dev </td>
<td> Device (0-DHT11, 1-DHT22) </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 1
</td></tr>
<tr>
<td> t </td>
<td> T, °С </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable	 </td>
<td>
</td></tr>
<tr>
<td> h </td>
<td> H,&nbsp;% </td>
<td> Real </td>
<td> Input </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output controller object and a parameter into the DAQ module "BCM 2835", by default it's "pi.pi".</dd>
<dd>2. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties (FIFO-199).</dd>
<dd>3. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter</a> and select the template for that, one for each sensor. Enable the parameter.</dd>
<dd>4. Into the tab "Template configuration" of the logical parameter object you need to set:
<ul><li> <i>addr</i> — to the address of the "BCM 2835" parameter like "DAQ.GPIO.io.pi"; tracing for the address changing is supported;</li>
<li> <i>pin</i> — GPIO pin number where connected the data pin of the sensor;</li>
<li> <i>tries</i> — tries of the sensor reading;</li>
<li> <i>dev</i> — generic device specific selection.</li></ul></dd>
<dd>5. <i>Result</i>: The logical parameter will perform interaction and placing of the gathered data to the Temperature and Humidity attributes.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="MAX6675" title="#MAX6675"><h3><span class="mw-headline" id="GPIO:_MAX6675_.28MAX6675.29"><span class="mw-headline-number">13</span> GPIO: MAX6675 (<a href="Libs_LowLevelDevices.html#MAX6675" title="Special:MyLanguage/Libs/LowLevelDevices">MAX6675</a>)</span></h3></span> </td>
<td> 0.1 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> Arcadiy Kisel
</td></tr></table>
<p>Cold-Junction-Compensated K-Thermocouple-to-Digital Converter (0°C to +1024°C). The module designed for the sensors connect through softSPI by GPIO, mostly it's <a href="Modules/GPIO.html" title="Special:MyLanguage/Modules/GPIO">Raspberry PI BCM2835 GPIO</a>.<br />
<i>Conditions:</i> Exclusively realtime planing in the priority 199 (FIFO-99).
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> addr </td>
<td> GPIO address with functions mode(), get() and put(), mostly it's BCM2835 </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> DAQ.GPIO.io.pi
</td></tr>
<tr>
<td> pin_cs </td>
<td> CS pin number of the GPIO </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 8
</td></tr>
<tr>
<td> pin_sclk </td>
<td> SCLK pin number of the GPIO </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 11
</td></tr>
<tr>
<td> pin_miso </td>
<td> MISO pin number of the GPIO </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 9
</td></tr>
<tr>
<td> t </td>
<td> T, °С </td>
<td> Real </td>
<td> Output </td>
<td> Read only </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output controller object and a parameter into the DAQ module "BCM 2835", by default it's "pi.pi".</dd>
<dd>2. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties (FIFO-199).</dd>
<dd>3. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter</a> and select the template for that, one for each sensor. Enable the parameter.</dd>
<dd>4. Into the tab "Template configuration" of the logical parameter object you need to set: 
<ul><li> <i>addr</i> — to the address of the "BCM 2835" parameter like "DAQ.GPIO.io.pi"; tracing for the address changing is supported; </li>
<li> <i>pin_cs</i> — CS pin number where connected the chip selection pin of the sensor; </li>
<li> <i>pin_sclk</i> — SCLK pin number where connected the serial clock pin of the sensor;</li>
<li> <i>pin_miso</i> — MISO pin number where connected the master in slave out (data) pin of the sensor.</li></ul></dd>
<dd>5. <i>Result</i>: The logical parameter will perform interaction and placing of the gathered data to the Temperature attributes.</dd></dl>
<p><br />
</p>
<table class="wikitable">

<tr>
<td> <span id="1602A" title="#1602A"><h3><span class="mw-headline" id="GPIO.7CI2C:_1602A.28HD44780.29_.281602A.29"><span class="mw-headline-number">14</span> GPIO|I2C: 1602A(HD44780) (<a href="Libs_LowLevelDevices.html#1602A" title="Special:MyLanguage/Libs/LowLevelDevices">1602A</a>)</span></h3></span> </td>
<td> 1.0 </td>
<td> GPLv2 </td>
<td> * </td>
<td> en 
</td>
<td> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a>
</td></tr></table>
<p>LCD Module 1602A, STN, BLUB, 16 Character x 2 Line,  5 x 8 Dots, by the direct (<a href="Modules/GPIO.html" title="Special:MyLanguage/Modules/GPIO">Raspberry PI BCM2835 GPIO</a>) or I2C (PCF8574) wiring.<br />
<i>Conditions:</i> Default planing policy but realtime one preferred.
</p><p><b><u>Template IOs</u></b><br />
</p>
<table class="wikitable">

<tr>
<th> Identifier </th>
<th> Parameter </th>
<th> Type </th>
<th> Mode </th>
<th> Attribute </th>
<th> Configuration </th>
<th> Value
</th></tr>
<tr>
<td> transport </td>
<td> Transport of the I2C, Serial (i2c) or<br />
<p>GPIO address with function put(), mostly it's BCM2835 (DAQ.GPIO.io.pi)
</p>
</td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> i2c
</td></tr>
<tr>
<td> addr </td>
<td> I2C device address [0...119] </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 39
</td></tr>
<tr>
<td> RS </td>
<td> GPIO Pin: Reset </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 7
</td></tr>
<tr>
<td> E </td>
<td> GPIO Pin: Enable </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 8
</td></tr>
<tr>
<td> D4 </td>
<td> GPIO Pin: Data4 </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 25
</td></tr>
<tr>
<td> D5 </td>
<td> GPIO Pin: Data5 </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 24
</td></tr>
<tr>
<td> D6 </td>
<td> GPIO Pin: Data6 </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 23
</td></tr>
<tr>
<td> D7 </td>
<td> GPIO Pin: Data7 </td>
<td> Integer </td>
<td> Input </td>
<td> Not attribute </td>
<td> Constant </td>
<td> 18
</td></tr>
<tr>
<td> ln1 </td>
<td> Line 1 </td>
<td> String </td>
<td> Input </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> ln2 </td>
<td> Line 2 </td>
<td> String </td>
<td> Input </td>
<td> Full access </td>
<td> Variable </td>
<td>
</td></tr>
<tr>
<td> f_frq </td>
<td> Function calculate frequency (Hz) </td>
<td> Real </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 1000
</td></tr>
<tr>
<td> f_start </td>
<td> Function start flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_stop </td>
<td> Function stop flag </td>
<td> Boolean </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr>
<tr>
<td> f_err </td>
<td> Function error </td>
<td> String </td>
<td> Input </td>
<td> Not attribute </td>
<td> Variable </td>
<td> 0
</td></tr></table>
<p><b><u>Configuring and using</u></b><br />
</p>
<dl><dd>1. Create an output controller and an object of parameter in DAQ module "BCM 2835", by default it's "pi.pi" or create an output transport of the type "<a href="Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a>", set address like to "i2c", one for each the I2C bus.</dd>
<dd>2. Create and start <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical controller object</a> or use any presented one with the needed scheduling properties.</dd>
<dd>3. Create <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">a logical parameter object</a> and select the template for that, one for each sensor. Enable the parameter.</dd>
<dd>4. Into the tab "Template configuration" of the logical parameter object you need to set:
<ul><li> <i>transport</i> — to address of the "BCM 2835" parameter like to "DAQ.GPIO.io.pi" or to address of the transport into step 1; tracing for the address changing is supported;</li>
<li> <i>addr</i> — the I2C slave device's address [0...119];</li>
<li> <i>RS, E, D4, D5, D6, D7</i> — numbers of the GPIO pins where connected the proper data ones of the sensor.</li></ul></dd>
<dd>5. <i>Result</i>: The logical parameter object will perform interaction and setting lines' values to the display.</dd></dl>






</div><table style="border-top: dotted 2px #999999; margin-top: 20pt; color: gray;" width="100%"><tr><td style="text-align: left;" width="40%"><a href="http://oscada.org/wiki/Libs/LowLevelDevices/uk">Libs/LowLevelDevices/uk</a> - <a href="http://oscada.org/en/main/about-the-project/licenses/">GFDL</a></td><td style="text-align: center;">July 2021</td><td style="text-align: right;" width="40%">OpenSCADA 1+r2759</td></tr></table></body>
</html>