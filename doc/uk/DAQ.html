<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="UTF-8" />
<title>Документи/Збір даних - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../en/files/doc.css" rel="stylesheet" /></head>
<body><div class="floatright"><a href="index.html"><img src="../en/files/index.png" /></a></div><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="uk">Документи/Збір даних</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="uk"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Documents%2FDAQ&amp;action=page&amp;filter=&amp;language=uk" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Documents/DAQ" title="Documents/DAQ">Documents/DAQ</a> and the translation is 100% complete.</div><hr /><div class="mw-pt-languages" dir="ltr" lang="en"><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="../en/DAQ.html" title="Documents/DAQ (100% translated)">English</a>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--complete" href="../ru/DAQ.html" title="Документы/Сбор данных (98% translated)">mRussian</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">Українська</span></div></div>
<div style="float:right; border:1px solid gray; width:300px; padding:2px; margin-left: 10pt; margin-bottom: 10pt;">
<ul><li> <b>Автор:</b> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Роман Савоченко</a> </li></ul>
</div>
<p>Збір даних SCADA(Supervisory Control and Data Acquisition)-системи є її невід'ємною частиною, яка займається отриманням даних із джерел різноманітного походження. Природа даних, з якими працює SCADA, характеризується сигналами базових типів значень (цілі, реальні, логічні та рядок). Сигнали змінюються у часі та мають історією — життя. У теорії управління технологічними процесами (ТП), під сигналом мається на увазі значення давача установки ТП у коді АЦП — "сирий" сигнал, або у реальному значені — інженерний. Сигнали можуть поєднуватися у групи за смисловим навантаженням, які часто називаються параметрами або комплексним тегом. Наприклад, розвинуті джерела даних можуть надавати структури параметрів із визначеним набором пов'язаних сигналів. Крім безпосередньо збору даних, до функції цього механізму також входить і передача дій на виконавчі пристрої управління ТП, зазвичай це: засувки, насоси та регулюючі клапани. Сукупно, це обладнання отримало назву — Пристрій Узгодження із Об'єктом (ПУО).
</p><p>Джерела даних характеризуються великим розмаїттям, яке можна умовно поділити на три групи:
</p>
<ul><li> Джерела "сирих" даних, які надають код АЦП або рівні дискретних сигналів, а також які включають простішу обробку. Зазвичай, це модулі розосередженого ПУО або простіші промислові програмовані логічні контролери (ПЛК).</li>
<li> Потужні промислові ПЛК, що мають значні обчислювальні потужністю та можливості формування складних параметрів з різною структурою.</li>
<li> Локальні або супутні джерела даних. Наприклад, ПУО у вигляді плат розширення, а також дані апаратного та програмного оточення в якому функціонує система.</li></ul>
<p>Розмаїття джерел даних породило великий спектр механізмів доступу до них. Локальні джерела даних різняться інтерфейсами програмування додатку (API), а мережеві джерела, своєю чергою, транспортним та протокольним рівнями взаємодії. В цілому, це призвело до того, що додання підтримки нового джерела даних потребує створення модуля сполучення або драйверу. Враховуючи ж велике розмаїття джерел, це доволі затратно та фактично нереально охопити весь спектр ринку таких пристроїв. Ситуація дещо спрощується із мережевими джерелами, завдяки наявності низки стандартних та вільних протоколів взаємодії, однак багато джерел все-ж використовують власні протоколи: закриті комерційні або протоколи, зав'язані на закриті механізми комерційних операційних систем (ОС).
</p><p>У термінах OpenSCADA, надаються наступні об'єкти моделі даних обслуговування механізму збору даних:
</p>
<ul><li> "Атрибут" — об'єкт віддзеркалення даних сигналу, включає поточне значення визначеного типу сигналу та доступ до історії зміни цих значень;</li>
<li> "Параметр" — об'єкт групи атрибутів зі структурою, відповідною до особливостей окремо взятого джерела даних;</li>
<li> "Об'єкт контролеру" — об'єкт окремого джерела даних. Як правило це окремий модуль ПУО або пристрій промислового ПЛК.</li></ul>
<p>Для врахування особливостей різних пристроїв збору даних, а також різних механізмів взаємодії, у OpenSCADA передбачено <a href="Program_manual.html#DAQ" title="Special:MyLanguage/Documents/Program manual">підсистему "Збір Даних"</a>, яка є модульною. У якості модуля підсистеми виступає драйвер сполучення із джерелом даних окремого типу. Кожний модуль може містити конфігурацію декількох пристроїв цього типу у вигляді об'єктів контролеру. Загальну схему об'єктів підсистеми "Збір даних" зображено на рисунку 1.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:309px;"><a class="image" href="http://oscada.org/wiki/File:Oscada_subsys_daq_str_uk.png"><img class="thumbimage" height="335" src="files/Oscada_subsys_daq_str_uk.png" width="307" /></a>  <div class="thumbcaption">Рис. 1. Схема підсистеми "Збір Даних".</div></div></div></div>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.D0.9C.D0.B5.D1.82.D0.BE.D0.B4.D0.B8_.D0.B7.D0.B1.D0.BE.D1.80.D1.83_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85"><span class="tocnumber">1</span> <span class="toctext">Методи збору даних</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#.D0.9F.D1.80.D0.BE.D1.81.D1.82.D0.B8.D0.B9_.D1.81.D0.B8.D0.BD.D1.85.D1.80.D0.BE.D0.BD.D0.BD.D0.B8.D0.B9_.D0.BC.D0.B5.D1.85.D0.B0.D0.BD.D1.96.D0.B7.D0.BC_.D0.B7.D0.B1.D0.BE.D1.80.D1.83"><span class="tocnumber">1.1</span> <span class="toctext">Простий синхронний механізм збору</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#.D0.9F.D1.80.D0.BE.D1.81.D1.82.D0.B8.D0.B9_.D0.B0.D1.81.D0.B8.D0.BD.D1.85.D1.80.D0.BE.D0.BD.D0.BD.D0.B8.D0.B9_.D0.BC.D0.B5.D1.85.D0.B0.D0.BD.D1.96.D0.B7.D0.BC_.D0.B7.D0.B1.D0.BE.D1.80.D1.83"><span class="tocnumber">1.2</span> <span class="toctext">Простий асинхронний механізм збору</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#.D0.9F.D0.B0.D0.BA.D0.B5.D1.82.D0.BD.D0.B8.D0.B9_.D0.BC.D0.B5.D1.85.D0.B0.D0.BD.D1.96.D0.B7.D0.BC_.D0.B7.D0.B1.D0.BE.D1.80.D1.83"><span class="tocnumber">1.3</span> <span class="toctext">Пакетний механізм збору</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#.D0.9F.D0.B0.D1.81.D0.B8.D0.B2.D0.BD.D0.B8.D0.B9_.D0.BC.D0.B5.D1.85.D0.B0.D0.BD.D1.96.D0.B7.D0.BC_.D0.B7.D0.B1.D0.BE.D1.80.D1.83_.D1.82.D0.B0_.D1.96.D0.BD.D1.96.D1.86.D1.96.D0.B0.D1.82.D0.B8.D0.B2.D0.BD.D1.96_.D0.BF.D1.96.D0.B4.D0.BA.D0.BB.D1.8E.D1.87.D0.B5.D0.BD.D0.BD.D1.8F"><span class="tocnumber">1.4</span> <span class="toctext"><span>Пасивний механізм збору та ініціативні підключення</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#.D0.92.D1.96.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.96_.D0.B4.D0.B6.D0.B5.D1.80.D0.B5.D0.BB.D0.B0_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85"><span class="tocnumber">2</span> <span class="toctext"><span>Віртуальні джерела даних</span></span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#.D0.9B.D0.BE.D0.B3.D1.96.D1.87.D0.BD.D0.B8.D0.B9_.D1.80.D1.96.D0.B2.D0.B5.D0.BD.D1.8C_.D0.BE.D0.B1.D1.80.D0.BE.D0.B1.D0.BA.D0.B8_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85"><span class="tocnumber">3</span> <span class="toctext"><span>Логічний рівень обробки даних</span></span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#.D0.9A.D0.BE.D0.BD.D1.86.D0.B5.D0.BF.D1.86.D1.96.D1.8F_.D0.B4.D0.BE.D1.81.D1.82.D1.83.D0.BF.D1.83_.D0.B4.D0.BE_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_.D0.BA.D0.BE.D1.80.D0.B8.D1.81.D1.82.D1.83.D0.B2.D0.B0.D1.86.D1.8C.D0.BA.D0.B8.D0.B9_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB"><span class="tocnumber">3.1</span> <span class="toctext"><span>Концепція доступу до даних через користувацький протокол</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#.D0.A0.D0.B5.D0.B7.D0.B5.D1.80.D0.B2.D1.83.D0.B2.D0.B0.D0.BD.D0.BD.D1.8F_.D0.B4.D0.B6.D0.B5.D1.80.D0.B5.D0.BB_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85"><span class="tocnumber">4</span> <span class="toctext"><span>Резервування джерел даних</span></span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#.D0.9C.D1.96.D1.82.D0.BA.D0.B0_.D1.87.D0.B0.D1.81.D1.83_.D0.B4.D0.B6.D0.B5.D1.80.D0.B5.D0.BB.D0.B0_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85"><span class="tocnumber">5</span> <span class="toctext"><span>Мітка часу джерела даних</span></span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#.D0.9F.D0.BE.D1.81.D0.B8.D0.BB.D0.B0.D0.BD.D0.BD.D1.8F"><span class="tocnumber">6</span> <span class="toctext">Посилання</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id=".D0.9C.D0.B5.D1.82.D0.BE.D0.B4.D0.B8_.D0.B7.D0.B1.D0.BE.D1.80.D1.83_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85"><span class="mw-headline-number">1</span> Методи збору даних</span></h2>
<p>Враховуючи різні властивості джерел даних, а також можливі варіанти взаємодії, методи збору даних можна поділити на: простий синхронний, простий асинхронний, пакетний та пасивний.
</p><p>У огляді механізмів нижче будуть приймати участь наступні об'єкти:
</p>
<ul><li> "ObjectSCADA" — будь-який об'єкт SCADA-системи, який звертається за значенням сигналу, наприклад, архіви та візуалізатори;</li>
<li> "DAQParamAttribute" — атрибут параметра підсистеми "Збір Даних", який виступає посередником у доступі до значень сигналу джерела даних;</li>
<li> "DAQParamAttributeArch" — об'єкт архіву атрибута;</li>
<li> "HardwarePLC" — об'єкт джерела даних, наприклад, модулі розосередженого ПУО або промислові ПЛК.</li></ul>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D1.81.D1.82.D0.B8.D0.B9_.D1.81.D0.B8.D0.BD.D1.85.D1.80.D0.BE.D0.BD.D0.BD.D0.B8.D0.B9_.D0.BC.D0.B5.D1.85.D0.B0.D0.BD.D1.96.D0.B7.D0.BC_.D0.B7.D0.B1.D0.BE.D1.80.D1.83"><span class="mw-headline-number">1.1</span> Простий синхронний механізм збору</span></h3>
<p>Механізм характеризується запитами до джерела даних синхронно із запитом до атрибуту параметра (рис.2). Цей механізм, зазвичай, застосовується при роботі з локальними джерелами даних, які характеризуються низькою латентністю, тобто затримкою у відповіді на запит. За допомогою цього методу можна отримати актуальні дані безпосередньо із запитом, однак час запиту об'єкту буде включати час транспортування та обробки запиту джерелом даних.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:686px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_simpleSync.png"><img class="thumbimage" height="179" src="../en/files/DAQ_simpleSync.png" width="684" /></a>  <div class="thumbcaption">Рис. 2. Діаграма послідовності взаємодії при синхронних запитах.</div></div></div></div>
<p>Відповідно до діаграми вище, ми отримуємо наступну послідовність запитів отримання даних та їх передачі:
</p>
<ul><li> об'єкт SCADA-системи надсилає запит значення до об'єкту атрибута параметра <b>DAQParamAttribute::getVal()</b>;</li>
<li> об'єкт атрибута параметру, отримавши запит, надсилає його джерелу даних <b>HardwarePLC::valueRequest()</b>;</li>
<li> джерело даних, обробивши запит, повертає результат;</li>
<li> об'єкт атрибуту параметра, отримавши результат, повертає його об'єкту SCADA-системи.</li></ul>
<p>У OpenSCADA такий механізм реалізують наступні модулі підсистеми "Збір Даних":
</p>
<ul><li> <i><a href="Modules/JavaLikeCalc.html" title="Special:MyLanguage/Modules/JavaLikeCalc">JavaLikeCalc</a></i> — обчислювач на Java-подібній мові високого рівня. У якості джерела даних виступає користувацька програма на Java-подібній мові. Атрибути параметрів модуля синхронно звертаються до входів/виходів обчислювального контексту користувацької функції.</li>
<li> <i><a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">LogicLev</a></i> — модуль логічного рівня параметрів збору даних, детальніше про нього у розділі 3. У якості джерела даних цього модуля виступають інші параметри підсистеми "Збір Даних" та контекст виконання шаблону параметрів. Атрибути параметрів модуля синхронно звертаються до атрибутів інших параметрів, у режимі віддзеркалення параметрів підсистеми "Збір Даних", або до входів/виходів контексту виконання шаблону, у режимі роботи за шаблоном.</li>
<li> <i><a href="Modules/BlockCalc.html" title="Special:MyLanguage/Modules/BlockCalc">BlockCalc</a></i> — обчислювач на мові блокових схем. У якості джерела даних виступає користувацька блокова схема. Атрибути параметрів модуля синхронно звертаються до входів/виходів блоків блокової схеми.</li>
<li> <i><a href="Modules/DAQGate.html" title="Special:MyLanguage/Modules/DAQGate">DAQGate</a></i> — модуль віддзеркалення об'єктів контролерів віддалених OpenSCADA-станцій на локальну. У модулі реалізовано синхронний режим запису даних.</li>
<li> <i><a href="Modules/ModBus.html" title="Special:MyLanguage/Modules/ModBus">ModBus</a></i> — модуль доступу до даних джерел за посередництвом сімейства протоколів "ModBus". У модулі реалізовано синхронний режим запису даних.</li>
<li> <i><a href="Modules/DiamondBoards.html" title="Special:MyLanguage/Modules/DiamondBoards">DiamondBoards</a></i> — модуль доступу до даних PC/104 плат фірми Diamond Systems. Плати PC/104 розташовуються на ISA-шині, відповідно є локальними та доступні порівняно швидко. У режимі збору даних не за перериванням, доступ до значень АЦП здійснюється синхронно. Режим запису значення ЦАП завжди працює синхронно.</li></ul>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D1.81.D1.82.D0.B8.D0.B9_.D0.B0.D1.81.D0.B8.D0.BD.D1.85.D1.80.D0.BE.D0.BD.D0.BD.D0.B8.D0.B9_.D0.BC.D0.B5.D1.85.D0.B0.D0.BD.D1.96.D0.B7.D0.BC_.D0.B7.D0.B1.D0.BE.D1.80.D1.83"><span class="mw-headline-number">1.2</span> Простий асинхронний механізм збору</span></h3>
<p>Механізм характеризується запитами до джерела даних незалежно від запиту до атрибуту параметра (рис.3). Зазвичай, запити до джерела даних здійснюються періодично, у власному завдані опитування окремо взятого контролеру та блоками по декілька сигналів. При цьому, запитом до атрибуту параметра повертається значення, отримане останнім сеансом зв'язку із джерелом даних. Цей механізм зазвичай застосовується при роботі з віддаленими (мережевими) джерелами даних, які характеризуються високою латентністю, тобто затримкою у відповіді на запит. 
</p><p>За допомогою цього методу можна забезпечити оптимізацію часового ресурсу, витраченого на один сигнал, і тим самим збільшити максимальну кількість опитаних сигналів за інтервал часу опитування.
</p><p>У якості показового прикладу розглянемо промисловий ПЛК "Siemens S7-315", при опитувані його по шині ProfiBus (1,5 Мбіт/с). Середній час обробки MPI-запиту цим контролером становить 30 мс. Якщо використовувати синхронний механізм для кожного сигналу, тобто один запит на кожний сигнал, то протягом однієї секунди ми зможемо отримати біля 33 сигналів. А якщо застосувати асинхронний механізм, тобто у одному MPI-пакеті отримувати до 220 байт або 110 сигналів цілочисельного типу на 16-розрядів, то ми зможемо за одну секунду отримати до 3630 сигналів. Як можна бачити, ефективність асинхронного механізму, у цьому випадку, складає 110 разів, а саме значення максимальної ємності MPI-пакету. 
</p><p>Недоліком асинхронного механізму є те, що запит значень атрибуту параметра повертає неактуальне на час запиту значення, а значення останнього сеансу опитування контролеру. Утім, якщо врахувати, що джерело даних може оновлюватися з періодичністю апаратних обмежень АЦП, та й самі давачі можуть мати певні обмеження у швидкості реакції, то й застосування асинхронного механізму збору може мати серйозні підстави.
</p><p>Застосування асинхронного механізму для запису значень у ПЛК є доволі рідкісним явищем, оскільки запис значень зазвичай передбачає вплив оператора на ТП. Оператор, по факту, достатньо рідко вносить коригування у процес, відтак запис можна здійснювати синхронно. Однак, існують ситуації, наприклад, управління ТП регуляторами на SCADA-системі, яка виконує функції середовища виконання ПЛК.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:710px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_simpleAsync.png"><img class="thumbimage" height="279" src="../en/files/DAQ_simpleAsync.png" width="708" /></a>  <div class="thumbcaption">Рис. 3. Діаграма послідовності взаємодії при асинхронних запитах.</div></div></div></div>
<p>Згідно до діаграми вище, ми отримуємо наступну картину:
</p>
<ul><li> атрибут параметру, або вищестоящий об'єкт контролеру, виконує періодичні запити <b>HardwarePLC::valueRequest()</b> отримання значення сигналу або групи сигналів;</li>
<li> отриманні значення сигналів розташовуються локально у атрибутах параметрів;</li>
<li> об'єкт SCADA-системи надсилає запит значення до атрибута параметра <b>DAQParamAttribute::getVal()</b> та отримує збережене локально значення попереднього сеансу опитування джерела даних.</li></ul>
<p>В OpenSCADA такий механізм реалізують наступні модулі підсистеми "Збір Даних":
</p>
<ul><li> <i><a href="Modules/DAQGate.html" title="Special:MyLanguage/Modules/DAQGate">DAQGate</a></i> — модуль віддзеркалення об'єктів контролерів віддалених OpenSCADA-станцій на локальну. В модулі реалізовано асинхронний режим читання даних.</li>
<li> <i><a href="Modules/System.html" title="Special:MyLanguage/Modules/System">System</a></i> — модуль доступу до даних оточення виконання OpenSCADA. У модулі реалізовано асинхронний режим читання даних.</li>
<li> <i><a href="Modules/ModBus.html" title="Special:MyLanguage/Modules/ModBus">ModBus</a></i> — модуль доступу до даних джерел за посередництвом сімейства протоколів "ModBus". У цьому модулі асинхронний режим реалізовано як для читання даних, так і для їх запису (опціонально) на ПЛК.</li>
<li> <i><a href="Modules/SNMP.html" title="Special:MyLanguage/Modules/SNMP">SNMP</a></i> — модуль доступу до даних пристроїв мережі за посередництвом "Simple Network Management Protocol". В модулі реалізовано асинхронний режим читання даних.</li>
<li> <i><a href="Modules/Siemens.html" title="Special:MyLanguage/Modules/Siemens">Siemens</a></i> — модуль доступу до даних контролерів фірми Siemens серії S7. У цьому модулі асинхронний режим реалізовано як для читання даних, так і для їх запису (опціонально) на ПЛК.</li></ul>
<h3><span class="mw-headline" id=".D0.9F.D0.B0.D0.BA.D0.B5.D1.82.D0.BD.D0.B8.D0.B9_.D0.BC.D0.B5.D1.85.D0.B0.D0.BD.D1.96.D0.B7.D0.BC_.D0.B7.D0.B1.D0.BE.D1.80.D1.83"><span class="mw-headline-number">1.3</span> Пакетний механізм збору</span></h3>
<p>Пакетний механізм збору характерний збором даних кожного сигналу пакетом, який включає історію його зміни. Тобто, за один сеанс опитування отримується декілька значень історії сигналу. Пакетний механізм працює спільно із синхронним та асинхронними механізмами.
</p><p>У випадку роботи з синхронним механізмом, виконується фактичне перекидання архіву джерела даних для оперативної роботи у системі (рис. 2). Як і простий синхронний механізм, його бажано застосовувати тільки на низько-латентних джерелах даних або із джерелами, робота яких є сеансовою, наприклад, у сфері комерційного обліку для читання значень лічильників.
</p><p>При роботі спільно із асинхронним механізмом, історія отриманих сигналів зазвичай прямо розташовується у архіви (рис. 4), а поточні значення атрибута параметру встановлюються у останнє значення пакету. Така комбінація ефективна при зборі швидких даних або при синхронізації архівів після втрати зв'язку з віддаленим джерелом даних.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:555px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_packAsync.png"><img class="thumbimage" height="267" src="../en/files/DAQ_packAsync.png" width="553" /></a>  <div class="thumbcaption">Рис. 4. Діаграма послідовності взаємодії при асинхронних запитах пакетного механізму.</div></div></div></div>
<p>Згідно діаграми вище, ми отримаємо наступну поведінку пакетного механізму при асинхронних запитах:
</p>
<ul><li> атрибут параметру, або вищестоящий об'єкт контролера, здійснює періодичні запити <b>HardwarePLC::valuesRequest()</b> отримання пакетів значень сигналу або групи сигналів;</li>
<li> отримані пакети значень сигналів розташовуються до архіву, запитом <b>DAQParamAttributeArch::setValues()</b>, а останнє значення пакетів розташовується у атрибут параметру;</li>
<li> об'єкт SCADA-системи надсилає запит фрагменту архіву до атрибуту параметра <b>DAQParamAttribute::getValues()</b>, а той переспрямовує запит до архіву <b>DAQParamAttributeArch::getValues()</b>. У результаті, повертається фрагмент архіву, доступний після попереднього сеансу опитування джерела даних;</li>
<li> об'єкт SCADA-системи надсилає запит останнього значення до об'єкту атрибута параметра <b>DAQParamAttribute::getVal()</b> та отримує збережене локальне значення попереднього сеансу опитування джерела даних.</li></ul>
<p>У OpenSCADA такий механізм реалізують наступні модулі підсистеми "Збір Даних":
</p>
<ul><li> <i><a href="Modules/DAQGate.html" title="Special:MyLanguage/Modules/DAQGate">DAQGate</a></i> — модуль віддзеркалення об'єктів контролерів віддалених OpenSCADA-станцій на локальну. Реалізує синхронний та асинхронний пакетний режими віддзеркалення архівів віддалених OpenSCADA-станцій.</li>
<li> <i><a href="Modules/DiamondBoards.html" title="Special:MyLanguage/Modules/DiamondBoards">DiamondBoards</a></i> — модуль доступу до даних PC/104 плат фірми Diamond Systems. Плати PC/104 розташовуються на ISA-шині, відтак є локальними та доступні порівняно швидко. У режимі збору даних за перериванням здійснюється очікування пакетів швидких значень (до 200 кГц) за одну секунду (до 200000 значень у пакеті) та наступного розташування даних пакетів у архівах атрибутів параметрів DAQ.</li></ul>
<h3><span class="mw-headline" id=".D0.9F.D0.B0.D1.81.D0.B8.D0.B2.D0.BD.D0.B8.D0.B9_.D0.BC.D0.B5.D1.85.D0.B0.D0.BD.D1.96.D0.B7.D0.BC_.D0.B7.D0.B1.D0.BE.D1.80.D1.83_.D1.82.D0.B0_.D1.96.D0.BD.D1.96.D1.86.D1.96.D0.B0.D1.82.D0.B8.D0.B2.D0.BD.D1.96_.D0.BF.D1.96.D0.B4.D0.BA.D0.BB.D1.8E.D1.87.D0.B5.D0.BD.D0.BD.D1.8F"><span class="mw-headline-number">1.4</span> <span id="PassiveAndInitiative" title="#PassiveAndInitiative">Пасивний механізм збору та ініціативні підключення</span></span></h3>
<p>Пасивний механізм збору характерний ініціативою надання даних до SCADA-системи із боку джерела даних. Цей механізм є достатньо рідкісним явищем, однак може мати місце за певних умов або обмежень у можливості використання прямих механізмів збору даних, рисунок 5. Прикладом такої ситуації можуть слугувати географічно розосереджені системи збору даних за посередництвом мобільних мереж GPRS/EDGE/3G/4G/... . Наділення всіх вузлів окремими реальними та статичними IP-адресами, або формування корпоративної мобільної мережі, у таких мережах може виявитися дорогим задоволенням, тому доступніше виявляється ініціатива сеансу передачі даних із-за динамічних IP-адрес на одну реальну IP-адресу серверу SCADA-системи. Дії на модифікацію передаються джерелу даних в момент сеансу передачі даних джерелом — читання. Хоча тут можливі й типові запити через VPN підключення від джерела даних та функціювання через мережеву СУБД-посередника.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:729px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_passive.png"><img class="thumbimage" height="190" src="../en/files/DAQ_passive.png" width="727" /></a>  <div class="thumbcaption">Рис.5. Діаграма послідовності взаємодії у пасивному механізмі роботи.</div></div></div></div>
<p>Згідно до діаграми вище, ми отримуємо наступну поведінку пасивного механізму:
</p>
<ul><li> об'єкт джерела даних здійснює періодичні сеанси зв'язку із атрибутом параметру <b>DAQParamAttributeArch::setVal()</b> для передачі своїх даних та отримання команд дій;</li>
<li> об'єкт SCADA-системи надсилає запит останнього значення атрибуту параметра <b>DAQParamAttribute::getVal()</b> та отримує збережене локально значення попереднього сеансу зв'язку джерела даних.</li></ul>
<p>У випадку коли хост, що ініціює підключення, має динамічну адресу яка не є "сірою", тобто за нею можна підключитися прямо, тоді ініціативне підключення можна використовувати лише для отримання зворотної адреси, за якою прямо і підключатися, а у контролері таких підключень здійснювати лише оновляння динамічної адреси.
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../en/files/At.png" width="22" /></a> Окремим випадком є ініціатива встановлення TCP-підключення від джерела даних та подальше здійснення стандартних запитів за цим підключенням від сервера, що вхідний транспорт <a href="Modules/Sockets.html" title="Special:MyLanguage/Modules/Sockets">модуля "Сокети"</a> наразі підтримує. Цей режим наразі навіть найрозповсюдженіший!
</p><p>OpenSCADA також сама підтримує ініціацію таких підключень, тобто може виступати у ролі джерела даних за "сірим" та динамічним IP. Так, вхідний транспорт <a href="Modules/Sockets.html" title="Special:MyLanguage/Modules/Sockets">модуля "Сокети"</a> у режимі 2 виступає ініціатором підключення після чого надсилає ідентифікуючу послідовність та переходить у звичайний режим отримання запитів від хосту до якого під'єднався. <a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../en/files/At.png" width="22" /></a> Щодо чого наразі особливо корисним є віддалений контроль OpenSCADA станцій у сірих мережах за такого підключення.
</p>
<h2><span class="mw-headline" id=".D0.92.D1.96.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.96_.D0.B4.D0.B6.D0.B5.D1.80.D0.B5.D0.BB.D0.B0_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85"><span class="mw-headline-number">2</span> <span id="Virtual" title="#Virtual">Віртуальні джерела даних</span></span></h2>
<p>Крім збору фізичних даних, актуальною є функція віртуального збору даних. Віртуальні дані представляють собою дані, отримані всередині системи як незалежно, так і на основі фізичних даних. Практично, механізми формування віртуальних даних реалізуються разом з механізмом користувацьких обчислень. В середині промислових контролерів та SCADA-систем використовуються різні мови програмування. У випадку з контролерами, у якості таких мов часто використовуються мови низького рівня (асемблери), однак, останнім часом, все частіш використовуються мови високого рівня (C, Pascal та інші), а також формальні мови IEC 61131-3 (схеми потоків станів SFC, блокові схеми FBD, релейні схеми LD та текстові ST, IL). У випадку із SCADA-системами, обчислювання частіше забезпечуються мовами програмування високого рівня та формальними мовами.
</p><p>У OpenSCADA можуть бути реалізовані інтерфейси програмування та віртуальних джерел даних на основі різних мов, у окремих модулях підсистеми "Збір Даних". На поточний час доступні модулі віртуальних обчислювачів:
</p>
<ul><li> Обчислювач на Java-подібній мові: <a href="Modules/JavaLikeCalc.html" title="Special:MyLanguage/Modules/JavaLikeCalc">JavaLikeCalc</a>;</li>
<li> Блоковий обчислювач: <a href="Modules/BlockCalc.html" title="Special:MyLanguage/Modules/BlockCalc">BlockCalc</a>.</li></ul>
<p>До ядра OpenSCADA інтегровано механізм користувацьких функцій або <a href="User_API.html" title="Special:MyLanguage/Documents/User API">API користувацького програмування</a>. Користувацькі функції можуть надаватися будь яким об'єктом програми, в тому числі й модулями, відповідно до власної функціональності, тим самим надаючи користувачу деякий набір функцій контролю за тим або іншим об'єктом. Функції користувацького API можуть бути як статичними, тобто ті що реалізують фіксовану функціональність окремого об'єкту, так і динамічними, тобто ті що формуються користувачем під потрібне йому завдання на внутрішній мові користувацького програмування високого рівня.
</p><p>Модуль <a href="Modules/JavaLikeCalc.html" title="Special:MyLanguage/Modules/JavaLikeCalc">JavaLikeCalc</a> надає до OpenSCADA механізм створення динамічних користувацьких функцій та їх бібліотек на Java-подібній мові. Опис функції на Java-подібній мові полягає у обв'язки параметрів функції алгоритмом. Крім цього, модуль наділено функціями безпосередніх обчислень, шляхом створення обчислювальних контролерів із асоційованою обчислювальною функцією. Модулем надається механізм прекомпіляції контекстно-залежних функцій, що використовується для вбудовування користувацьких алгоритмів безпосередньо до контексту різних компонентів OpenSCADA, це, наприклад, <a href="Program_manual.html#DAQ" title="Special:MyLanguage/Documents/Program manual">шаблони параметрів підсистеми "Збір Даних"</a> та <a href="Modules/VCAEngine.html" title="Special:MyLanguage/Modules/VCAEngine">рушій Середовища Візуалізації та Управління (СВУ)</a>.
</p><p>Модуль <a href="Modules/BlockCalc.html" title="Special:MyLanguage/Modules/BlockCalc">BlockCalc</a> надає до OpenSCADA механізм створення користувацьких обчислень, що ґрунтується на формальній мові блокових схем. Мови блокового програмування ґрунтуються на понятті блокових схем та функціональних блоків. Причому, залежно від сутності блоку, блокові схеми можуть бути: логічними схемами, схемами релейної логіки, моделлю технологічного процесу та інше. Сутність блокової схеми полягає в тому, що вона містить перелік блоків та зв'язки між ними. З формальної точки зору блок — це елемент (функція), яка має входи, виходи та алгоритм обчислення. Виходячи із концепції середовища програмування, блок — це кадр значень, асоційований з об'єктом функції. Входи та виходи блоків треба поєднувати для отримання цільної блокової схеми.
</p><p>З метою наповнення API користувацького програмування функціями, створені наступні спеціалізовані модулі статичних функцій API користувацького програмування:
</p>
<ul><li> Бібліотека функцій системного API: <a href="Modules/FLibSYS.html" title="Special:MyLanguage/Modules/FLibSYS">FLibSYS</a>;</li>
<li> Бібліотека стандартних математичних функцій: <a href="Modules/FLibMath.html" title="Special:MyLanguage/Modules/FLibMath">FLibMath</a>;</li>
<li> Бібліотека функцій сумісності зі SCADA Complex1: <a href="Modules/FLibComplex1.html" title="Special:MyLanguage/Modules/FLibComplex1">FLibComplex1</a>.</li></ul>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:602px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_progCompon_uk.png"><img class="thumbimage" height="662" src="files/DAQ_progCompon_uk.png" width="600" /></a>  <div class="thumbcaption">Рис. 6. Загальна структура компонентів середовища програмування.</div></div></div></div>
<h2><span class="mw-headline" id=".D0.9B.D0.BE.D0.B3.D1.96.D1.87.D0.BD.D0.B8.D0.B9_.D1.80.D1.96.D0.B2.D0.B5.D0.BD.D1.8C_.D0.BE.D0.B1.D1.80.D0.BE.D0.B1.D0.BA.D0.B8_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85"><span class="mw-headline-number">3</span> <span id="LogicLev" title="#LogicLev">Логічний рівень обробки даних</span></span></h2>
<p>Вище ми відзначали, що тип джерела даних може коливатися від "сирого" до комплексного. Під "сирим" мається на увазі джерело, яке надає тільки елементарні сигнали (цілі, реальні, логічні, рядок, ...), до того ж окремо. Під комплексним мається на увазі джерело, яке групує сигнали та, в параметрі підсистеми "Збір Даних", надає атрибути додаткового призначення, які покривають практично всі діагностичні завдання, тобто параметр є закінченим об'єктом, який не потребує доповнення.
</p><p>Враховуючи таку розбіжність, може виникнути ситуація, коли інформації у параметру контролера від джерела даних недостатньо для опису реального об'єкту ТП загалом та потрібен довільний об'єкт більш високого рівня абстракції. Вирішенням цієї ситуації може бути формування додаткових параметрів, що є ненаглядним та вносить плутанину. Більш правильним рішенням є використання прошарку "Логічного рівня", який виконує функцію гнучкого формування параметрів-контейнерів сигналів потрібної структури та що включає пост-обробку.
</p><p>Функціонально, "Логічний рівень" призначено для надання у OpenSCADA механізму вільного формування параметрів-контейнерів сигналів потрібної структури.
</p><p>Експлуатаційним призначенням "Логічного рівня" є:
</p>
<ul><li> розширення сфери застосування OpenSCADA за рахунок збільшення гнучкості опису параметрів підсистеми "Збір Даних";</li>
<li> скорочення трудовитрат на створення складних автоматизованих систем.</li></ul>
<p>Концепцію "Логічного рівня" засновано на шаблонах параметрів, для яких, у підсистемі "Збір Даних", передбачено контейнер бібліотек шаблонів (рис.1). Кожна бібліотека містить шаблони параметрів, які можуть використовуватися модулями підсистеми "Збір Даних" для реалізації параметрів на основі шаблонів. Модулями OpenSCADA, які використовують шаблони у своїй роботі, є:
</p>
<ul><li> <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">LogicLev</a> — модуль реалізації класичної концепції "Логічного рівня".</li>
<li> <a href="Modules/ModBus.html" title="Special:MyLanguage/Modules/ModBus">ModBus</a> — модуль доступу до даних джерел за посередництвом сімейства протоколів "ModBus". Крім типу параметру прямого опису переліку регістрів, модуль підтримує і логічний тип, де регістри "ModBus" описуються у зв'язках шаблону.</li>
<li> <a href="Modules/Siemens.html" title="Special:MyLanguage/Modules/Siemens">Siemens</a> — модуль збору даних контролерів фірми Siemens серії S7. Завдяки високій гнучкості та функціональності контролерів цієї серії, що дозволяє формувати комплексні типи даних різноманітної структури, всі параметри цього модуля працюють за шаблонами.</li>
<li> <a href="Modules/OPC_UA.html" title="Special:MyLanguage/Modules/OPC UA">OPC-UA</a> — модуль доступу до даних джерел за посередництвом протоколу "OPC-UA". Крім типу параметру прямого опису переліку вузлів, модуль підтримує і логічний тип, де вузли "OPC-UA" описуються у зв'язках шаблону.</li></ul>
<p>Загальний механізм роботи "Логічного рівня", на прикладі модуля <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">LogicLev</a>, зображено на рисунку 7.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:302px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_loglevel_uk.png"><img class="thumbimage" height="364" src="files/DAQ_loglevel_uk.png" width="300" /></a>  <div class="thumbcaption">Рис. 7. Механізм роботи "Логічного рівня" на прикладі модуля "LogicLev".</div></div></div></div>
<p>Виходячи із цього зображення видно, що параметри контролеру логічного рівня виконують функцію віддзеркалення інших параметрів підсистеми "Збір Даних" (на прикладі параметрів 1 та 4) та довільне формування параметрів на основі шаблонів 1, 2 та інших параметрів підсистеми "Збір Даних" (на прикладі параметрів 2, 3 та 5).
</p><p>Структура параметрів з шаблоном в основі має структуру, зображену на рисунку 8.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:244px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_str_prmtmpl_uk.png"><img class="thumbimage" height="200" src="files/DAQ_str_prmtmpl_uk.png" width="242" /></a>  <div class="thumbcaption">Рис. 8. Структура параметрів з шаблоном в основі.</div></div></div></div>
<p>Як можна бачити із структури, параметр логічного рівня складається із об'єкту функції, атрибутів та конфігурації шаблону. Об'єкт функції це екземпляр виконання функції шаблону з набором входів/виходів та програмою обчислення шаблону на одній із мов користувацького програмування, зазвичай це Java-подібна мова користувацького програмування модуля <a href="Modules/JavaLikeCalc.html" title="Special:MyLanguage/Modules/JavaLikeCalc">JavaLikeCalc</a>. Утім, шаблон може бути взагалі без програми, надаючи тільки структуру перекидання входів/виходів. Атрибути у структурі зображують перелік атрибутів результуючого параметру відповідно до шаблону. Конфігурація у структурі надає конфігурацію властивостей шаблону та його зовнішніх зв'язків.
</p><p>Логіку роботи логічного рівня параметрів можна записати наступним чином:
</p>
<ul><li> Параметр зв'язується з шаблоном, із якого отримується структура атрибутів, відповідно до функції шаблону.</li>
<li> Виконується зв'язування об'єкту функції параметру з функцією із шаблону.</li>
<li> Формується структура зв'язків відповідно до шаблону функції. Виходячи із структури зв'язків формується форма зв'язування параметру та користувачем встановлюються зв'язки.</li>
<li> При доступі до атрибутів отриманого параметра здійснюється перевірка на наявність прямого зв'язку. У випадку наявності прямого зв'язку, запит переспрямовується за цим зв'язком, інакше, значення береться із об'єкту функції параметру.</li>
<li> Паралельно працює обчислювання функції шаблону за об'єктом функції параметрів. При цьому, перед обчисленням здійснюється читання значень за зв'язками, а після обчислення запис змін за цими зв'язками.</li></ul>
<p>Шаблон параметрів, загалом, надає наступне:
</p>
<ul><li> структуру входів/виходів функції шаблону;</li>
<li> ознаки конфігурації та зв'язування шаблона (константа, зв'язок);</li>
<li> попередні значення конфігурації постійних та шаблону зв'язків;</li>
<li> ознаки атрибутів результуючого параметру логічного рівня, типів: не атрибут, атрибут з повним доступом, атрибут з доступом тільки на читання; </li>
<li> механізм обчислення входів/виходів функції шаблонів мовою користувацького програмування OpenSCADA.</li></ul>
<p>На рисунку 9 наведено зображення вкладки конфігурації шаблону параметрів підсистеми "Збір Даних" у вигляді таблиці з конфігурацією входів/виходів та тексту програми користувацького програмування.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:920px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_prmtmpl_uk.png"><img class="thumbimage" height="737" src="files/DAQ_prmtmpl_uk.png" width="918" /></a>  <div class="thumbcaption">Рис. 9. Вкладка конфігурації шаблону параметрів підсистеми "Збір Даних".</div></div></div></div>
<p>Вкладкою входи/виходи "ВВ" шаблону параметрів передбачено наступні властивості спеціалізованого призначення: "Атрибут", "Конфігурація" та "Значення".
</p><p>Властивість "Атрибут" виступає ознакою віддзеркалення входу/виходу шаблону на результуючий атрибут параметра. Передбачено наступні варіанти цієї властивості:
</p>
<ul><li> <i>Не атрибут</i> — вхід/вихід функції шаблону не віддзеркалюється на атрибут;</li>
<li> <i>Тільки читання</i> — вхід/вихід функції шаблону віддзеркалюється на атрибут з доступом тільки на читання;</li>
<li> <i>Повний доступ</i> — вхід/вихід функції шаблону віддзеркалюється на атрибут з повним доступом.</li></ul>
<p>Властивість "Конфігурація" виступає ознакою, яка вказує на використання входу/виходу функції шаблону в результуючій конфігурації шаблону на логічному рівні. Передбачено наступні варіанти цієї властивості:
</p>
<ul><li> <i>Змінна</i> — доступний для доступу та контролю тільки з процедури шаблона, як змінна, яка зберігається із контекстом параметру логічного рівня;</li>
<li> <i>Константа</i> — доступний для встановлення на рівні параметра логічного рівня, у вигляді постійної розділу конфігурації шаблону;</li>
<li> <i>Зв'язок</i> — доступний для встановлення на рівні параметру логічного рівня, у вигляді зв'язку розділу конфігурації шаблону.</li></ul>
<p>Поле "Значення" описує передвстановлене значення постійних та шаблонів зовнішніх зв'язків. Шаблон зовнішніх зв'язків використовується з метою описання механізму групування та автоматичного розподілу зовнішніх зв'язків. Структура шаблону зовнішніх зв'язків однакова у частині підключення до атрибутів параметрів підсистеми "Збір даних" та розширюється специфічним форматом адреси окремого модуля підсистеми "Збору даних", який використовує механізм шаблонів. Підключення до параметрів підсистеми "Збір даних" — шаблон конфігурації зовнішнього зв'язку має вигляд <b>{Параметр}|{атрибут}</b>, де:
</p>
<ul><li> <i>Параметр</i> — використовується для об'єднання атрибутів та розташування на формі конфігурації;</li>
<li> <i>атрибут</i> — для асоціативного зв'язування атрибутів при призначені параметру. </li></ul>
<p><span id="LogicLevLnks" title="#LogicLevLnks">Саме подальше зв'язування</span> загалом може здійснюватися:
</p>
<ul><li> загальним визначенням-обранням адреси-атрибуту параметру підсистеми "Збір даних"; наприклад, зв'язок "LogicLev.experiment.Pi.var" здійснює доступ атрибуту параметру до іншого атрибуту параметра; Знак "(+)", у кінці адреси, вказує на вдалу лінковку та присутність цільового об'єкту; для атрибутів об'єктного типу допустимий ієрархічний доступ до конкретної властивості об'єкту, шляхом вказання її шляху через символ '#', наприклад: "LogicLev.experiment.Pi.var#pr1.pr2";</li>
<li> визначенням специфічної адреси окремого модуля підсистеми "Збір даних";</li>
<li> прямим встановленням постійного значення у форматі "<b>val:{Постійна}</b>";</li>
<li> порожньою або помилковою адресою, коли значення за зв'язком встановлюється у <b>EVAL</b>.</li></ul>
<p>У якості прикладу використання шаблону, на рисунку 10 наведено зображення параметру "F3" модуля логічного рівня, де представлено вкладку "Конфігурація шаблона" для конфігурації шаблону параметру, включаючи зв'язування. На рисунку 11 представлено вкладку "Атрибути" з переліком атрибутів та їх значень, створених за посередництвом шаблону.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:845px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_wprm_tmpl_uk.png"><img class="thumbimage" height="597" src="files/DAQ_wprm_tmpl_uk.png" width="843" /></a>  <div class="thumbcaption">Рис. 10. Вкладка "Конфігурація шаблону" параметру "F3" модуля логічного рівня.</div></div></div></div>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:920px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_wprm_a_uk.png"><img class="thumbimage" height="672" src="files/DAQ_wprm_a_uk.png" width="918" /></a>  <div class="thumbcaption">Рис. 11. Вкладка "Атрибути" параметру "F3" модуля логічного рівня.</div></div></div></div>
<h3><span class="mw-headline" id=".D0.9A.D0.BE.D0.BD.D1.86.D0.B5.D0.BF.D1.86.D1.96.D1.8F_.D0.B4.D0.BE.D1.81.D1.82.D1.83.D0.BF.D1.83_.D0.B4.D0.BE_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_.D0.BA.D0.BE.D1.80.D0.B8.D1.81.D1.82.D1.83.D0.B2.D0.B0.D1.86.D1.8C.D0.BA.D0.B8.D0.B9_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB"><span class="mw-headline-number">3.1</span> <span id="UserPrt" title="#UserPrt">Концепція доступу до даних через користувацький протокол</span></span></h3>
<p>Наступним рівнем, заснованим на Логічному Рівні, є концепція доступу до даних через користувацький протокол, що реалізується або прямо у коді шаблону або як окремий об'єкт Користувацького Протоколу у <a href="Modules/UserProtocol.html" title="Special:MyLanguage/Modules/UserProtocol">модулі Protocol.UserProtocol</a>, де наразі також можна використовувати DAQ-шаблони.
</p><p>Концепцію доступу до даних через користувацький протокол можна зобразити як на рисунку 1.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:324px;"><a class="image" href="http://oscada.org/wiki/File:UserPrtDevs_concept_uk.png"><img class="thumbimage" height="275" src="files/UserPrtDevs_concept_uk.png" width="322" /></a>  <div class="thumbcaption">Рис.1. Концепція доступу до даних через користувацький протокол.</div></div></div></div>
<p>Як можна бачити з рисунку 1, взаємодія з пристроєм відбувається через деякий транспорт на якому вони фізично базуються. Запит до транспорту Ви можете надіслати:
</p>
<ol><li> Безпосередньо за допомогою функції системного API OpenSCADA об'єкту транспорту <i><a href="User_API.html#SYSTransport" title="Special:MyLanguage/Documents/User API">string messIO( string mess, real timeOut = 0 );</a></i>, якщо протоколоспецифічна частина дуже проста та дані вам потрібно лише вилучити.</li>
<li> Загорнутий запит даних <i>req</i>, функцією <i><a href="User_API.html#SYSTransport" title="Special:MyLanguage/Documents/User API">int messIO( XMLNodeObj req, string prt );</a></i> та для протоколу <i>prt</i>, якщо протокольна частина достатньо складна та вже представлена у OpenSCADA.</li>
<li> Загорнутий запит даних специфічний до користувача за допомогою функції <i><a href="User_API.html#SYSTransport" title="Special:MyLanguage/Documents/User API">int messIO( XMLNodeObj req, "UserProtocol" );</a></i> та реалізації <a href="Modules/UserProtocol.html" title="Special:MyLanguage/Modules/UserProtocol">користувацького протоколу</a>, якщо протокольна частина достатньо складна та ще відсутня у OpenSCADA. Користувач реалізує тут саму протоколоспецифічну частину у <a href="Modules/UserProtocol.html" title="Special:MyLanguage/Modules/UserProtocol">модулі UserProtocol</a> та частину специфічну до даних у шаблоні для <a href="Modules/LogicLev.html" title="Special:MyLanguage/Modules/LogicLev">модуля Логічного Рівня</a> або безпосередньо у процедурі контролеру на внутрішній мові програмування <a href="Modules/JavaLikeCalc.html" title="Special:MyLanguage/Modules/JavaLikeCalc">модуля JavaLikeCalc</a>. </li></ol>
<dl><dd><dl><dd> <a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../en/files/At.png" width="22" /></a> Цей останній метод наразі розвинено до можливості формування протокольної частини коду безпосередньо у тому-ж коді шаблону, як окрема вбудована функція через виклик функції запиту першого методу, якщо немає потреби повторного використання, або навіть якщо така потреба є та тут має сенс створення комплексного шаблону, який зможе поєднувати роль й вихідного протоколу, через його підключення також до модуля користувацького протоколу. Та воно буде повністю зберігатися у одній бібліотеці шаблонів. </dd></dl></dd></dl>
<p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../en/files/At.png" width="22" /></a> Пряма робота із вихідним транспортом функції <a href="User_API.html#SYSTransport" title="Special:MyLanguage/Documents/User API">string messIO( string mess, real timeOut = 0 );</a> не передбачає блокування транспорту поза викликом цієї функції, а відтак, для складних протоколів із посилками відповіді більш ніж у одному пакеті, що передбачає процес "доочікування", не можна використовувати спільний транспорт, за яким можливе надсилання пакетів різних протоколів або навіть один, але з різних завдань (об'єктів контролерів). Відтак, якщо є потреба використання спільного транспорту, то розташовуйте параметри опитування за протоколом у одному об'єкті контролеру (завдані) або використовуйте <a href="Modules/UserProtocol.html" title="Special:MyLanguage/Modules/UserProtocol">модуль користувацького протоколу</a>, до якого це зауваження не має стосунку, оскільки він здійснює таке блокування на час виклику процедури обробки, як і решта модульних протоколів OpenSCADA. 
</p><p>Створено наступні бібліотеки з використанням концепції доступу до даних через користувацький протокол:
</p>
<ul><li> <a href="Libs_Devices.html" title="Special:MyLanguage/Libs/Devices">Бібліотека промислових пристроїв</a></li>
<li> <a href="Libs_LowLevelDevices.html" title="Special:MyLanguage/Libs/LowLevelDevices">Бібліотека низькорівневих сенсорів та чипів</a></li></ul>
<h2><span class="mw-headline" id=".D0.A0.D0.B5.D0.B7.D0.B5.D1.80.D0.B2.D1.83.D0.B2.D0.B0.D0.BD.D0.BD.D1.8F_.D0.B4.D0.B6.D0.B5.D1.80.D0.B5.D0.BB_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85"><span class="mw-headline-number">4</span> <span id="Redundancy" title="#Redundancy">Резервування джерел даних</span></span></h2>
<p>Резервування загалом, та джерел даних зокрема, слугує для підвищення загального рівня відмовостійкості рішення шляхом включення дублювальних вузлів до спільної роботи з основним вузлом. У випадку відмови основного вузла відбувається підхоплення функцій основного вузла резервним. Часто, схема резервування може працювати і у режимі розподілу навантаження між вузлами, що спільно працюють.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:569px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_red_uk.png"><img class="thumbimage" height="378" src="files/DAQ_red_uk.png" width="567" /></a>  <div class="thumbcaption">Рис. 12. Горизонтальне та вертикальне резервування.</div></div></div></div>
<p>У випадку з підсистемою "Збір Даних", резервування даних (рис.12) виконує функції:
</p>
<ul><li> <b>Резервування механізму збору даних</b>. Зазвичай ця функція реалізується без особливих механізмів, шляхом простого запуску паралельних резервних станцій з однаковою конфігурацією та працюючих незалежно. Однак, у випадку виконання станцією функції ПЛК, така поведінка недозволена з причини одночасної видачі керуючих дій та відсутності синхронізації даних обчислювачів.</li>
<li> <b>Компенсація втрати даних на час недоступності вузла</b> за рахунок архіву резервного. Передбачено два механізми компенсації. Перший та основний механізм здійснює завантаження ділянок архіву з резервної станції під час запуску станції загалом або окремих об'єктів контролерів. Ділянка архіву запитується з моменту останнього запису у локальному архіві та по поточний час. Глибина запиту, при цьому, обмежується визначенням граничного часу в конфігурації резервування. Другий, доповнюючий механізм, здійснює заповнення "дірок" у архіві значень, під час фактичного запиту користувача до цих даних. Такий підхід, з одного боку, дозволяє здійснити прогнозовану за часом синхронізацію при старті, а з іншого боку, фактично виключає втрату даних при умові роботи хоча б однієї станції на протязі всього робочого часу.</li>
<li> <b>Розподіл навантаження по збору даних між вузлами</b>. При створені складних розподілених систем може виявитися важливим питання прогнозування та оптимізації загальної продуктивності системи. Враховуючи такі завдання, механізм резервування передбачає виконання завдань збору даних окремих джерел (об'єктів контролерів OpenSCADA) тільки на одній станції. При цьому, завдання решти станцій переходять в режим синхронізації даних зі станцією, що виконується. У випадку втрати зв'язку зі станцією, що виконується, запускається завдання локального збору даних. Передбачено, також, можливість оптимального розподілу навантаження виконання задач збору даних групи об'єктів контролерів, між станціями.</li>
<li> <b>Оптимізація навантаження на зовнішні джерела даних</b> за рахунок запиту (обміну) даних у зовнішнього джерела тільки одним вузлом. На практиці часто зустрічаються високо-навантажені джерела даних, або інтерфейси доступу до джерел даних, для яких навіть збір даних однією станцією може бути проблемою і вимагатиме зниження періодичності збору, тобто якості даних. Механізм резервування, крім розподілу навантаження між станціями за описаною вище схемою, дозволяє зняти додаткове навантаження на джерело даних та його інтерфейси, тим самим підвищивши якість даних. Запис до атрибуту резервного об'єкту контролеру призводить до відправки запиту модифікації на основний, тобто — через основний.</li>
<li> <b>Запобігання деякої різниці даних на різних вузлах</b>, пов'язане з незбігом моментів часу при незалежному зборі даних окремими вузлами, здійснюється шляхом отримання даних зі станції з активним об'єктом контролера. У системах високої звітності з резервуванням має бути виключено, або зведено до мінімуму, розходження у даних на різних станціях, що передбачає реальний збір даних однією станцією та синхронізацію з цими даними інших станцій.</li></ul>
<p>Резервування рекомендується налаштовувати таким чином щоб БД резервних станцій зберігалися однаковими, що надалі дозволить безболісно копіювати їх, при відновленні, на будь яку станцію та, відповідно, у резервній копії можна зберігати тільки один набір БД. При цьому, налаштування, специфічні до окремої станції, будуть зберігатися у конфігураційному файлі та можна буде легко конфігурувати та міняти потрібну станцію через вибір відповідного конфігураційного файлу.
</p><p>Налаштування резервування починається з додання резервних станцій до переліку станцій OpenSCADA на вкладці "Підсистема" підсистеми "Транспорти" (Рис.13). Причому додавати тут потрібно не лише резервні станції до поточної, але й саму цю поточну станцію з її зовнішньою адресою, тобто своєрідна петля. Надалі ці налаштування будуть збережені до загальної БД резервованої системи та сама БД з цього моменту буде використовуватися при створені всіх резервних станцій. Відповідно, важливо на цьому етапі внести всі потрібні зміни до загальної БД довкола проекту в цілому!
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:954px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_tr_extHst_uk.png"><img class="thumbimage" height="454" src="files/DAQ_tr_extHst_uk.png" width="952" /></a>  <div class="thumbcaption">Рис. 13. Вкладка "Підсистема" підсистеми "Транспорти".</div></div></div></div>
<p>Далі, на конкретній станції з копією загальної БД, налаштовуємо її специфічні параметри у вкладці "Резервування" головної сторінки (рис.14), які будуть збережені у конфігураційному файлі.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:715px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_sys_rd_uk.png"><img class="thumbimage" height="583" src="files/DAQ_sys_rd_uk.png" width="713" /></a>  <div class="thumbcaption">Рис. 14. Вкладка "Резервування" головної сторінки.</div></div></div></div>
<p>Після цього вся конфігурація резервування здійснюється у вкладці "Резервування" підсистеми "Збір даних" (Рис.15). Якщо встановити параметр "Передача локальних первинних команд" (Рис.14) то ця конфігурація, як і будь яка інша загального характеру, може здійснюватися на одній з станцій, а внесенні зміни потраплять на всі резервні, звісно якщо вони будуть доступні.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:917px;"><a class="image" href="http://oscada.org/wiki/File:DAQ_rd_uk.png"><img class="thumbimage" height="583" src="files/DAQ_rd_uk.png" width="915" /></a>  <div class="thumbcaption">Рис. 15. Вкладка "Резервування" підсистеми "Збір Даних".</div></div></div></div>
<p>Завдання обслуговування механізму резервування запускається завжди та виконується з періодичністю, встановленою у відповідному конфігураційному полі. Реальна робота щодо здійснення резервування відбувається при наявності хоча б однієї резервної станції у переліку станцій та передбачає:
</p>
<ul><li> Контроль за з'єднанням із зовнішніми станціями. В процесі контролю здійснюються запити до віддалених станцій, за оновленням інформації про них та перевірки зв'язку. У випадку втрати зв'язку із станцією, повтор підключення до неї здійснюється через проміжок часу, вказаний у конфігураційному полі інтервалу часу відновлення підключення. У полі "Живий", станції, відображається поточний стан зв'язку. У полі "Лічильник" представлено кількість запитів, здійснених до віддаленої станції, або ж час, який залишився до здійснення наступної спроби підключення із втраченою станцією.</li>
<li> Локальне планування виконання об'єктів контролерів у резерві. Планування здійснюється відповідно до рівня станцій та вподобанням виконання об'єктів контролерів.</li>
<li> Виклик функції синхронізації даних локальних об'єктів контролерів, працюючих у режимі синхронізації даних із зовнішніх станцій.</li></ul>
<p>Для контролю за часом, витраченим на виконання циклу обслуговування резервування, передбачено поле статусу. При наближені реального часу виконання до циклу завдання обслуговування резервування, рекомендується збільшити періодичність виконання цього завдання!
</p><p>Для об'єкту контролера підсистеми "Збір Даних" передбачено режими резервування "Асиметричне" та "Тільки порушення". Асиметричне резервування працює з тією конфігурацією контролеру віддаленої станції, яка є і не намагається її узагальнювати. Для цього режиму працюють всі раніш описані функції та властивості резервування. Резервування "Тільки порушення" передбачає фактичну роботу без резервування, але з придушенням порушень від резервного об'єкту контролера з метою виключення дублювальних повідомлень про порушення.
</p>
<h2><span class="mw-headline" id=".D0.9C.D1.96.D1.82.D0.BA.D0.B0_.D1.87.D0.B0.D1.81.D1.83_.D0.B4.D0.B6.D0.B5.D1.80.D0.B5.D0.BB.D0.B0_.D0.B4.D0.B0.D0.BD.D0.B8.D1.85"><span class="mw-headline-number">5</span> <span id="TimeStamp" title="#TimeStamp">Мітка часу джерела даних</span></span></h2>
<p>Фактично всі джерела даних, які підтримуються OpenSCADA, у якості мітки часу оперативних-потокових даних використовують час комп'ютера де працює OpenSCADA та здійснюється опитування цих джерела даних, навіть у випадку можливості отримання часу серверу або джерела у джерела даних, і часто навіть у випадку коли таким джерелом виступає інша станція-ПЛК з OpenSCADA.
</p><p>Такий підхід визначено з декількох причин, а саме:
</p>
<ul><li> розрізнення та виокремлення відмінності часу оперативних значень джерела даних та ПК збору даних не має жодної практичної мети окрім діагностичної з виявлення самого розходження часу, оскільки поточні дані архівуються у архів періодичних значень, де мітка часу так чи інакше притягується та округляється до цієї періодичності, тобто частина часу точніша за період даних архіву втрачається;</li>
<li> рідко яке джерело даних взагалі має годинник реального часу, а коли і має то до нього одразу ставиться вимога синхронізації часу із зовнішнім джерелом зразкового часу, що у свою чергу вимагає вирішення складнощів із прямим підключенням GPS приймача або доступом до NTP-серверу у інтернет або локальній мережі; за визначеним-же підходом зразковим часом стає час ПК збору даних, навіть коли він сам не синхронізований, оскільки він один;</li>
<li> мітка часу джерела даних може змінюватися з власною періодичністю або це оновлення взагалі може бути аперіодичним, що у випадку використання цієї мітки при опитувані призведе до прогалин у архіві, та навіть коли періодичності опитування-архівування та оновлення мітки часу джерела однакові такі прогалини будуть мати місце через відсутність синхронності, що доведеться компенсувати зменшенням періодичності опитування та, відповідно, збільшенням навантаження на мережу та джерело; відтак це зробить архів мало корисним, хоча наразі і надається можливість вважати такі прогалини (прохідні) не фактом відсутності або помилковістю даних.</li></ul>
<p>Наразі відомо один метод, коли від мітки часу джерела даних є практична цінність, це робота з історією-архівом на боці джерела даних, коли за виявленням прогалин у даних, наприклад, на час відсутності зв'язку, замість поточних-оперативних даних запитується ділянка історії-архіву, що відповідає цій прогалині. Та цей метод реалізовано у модулі <a href="Modules/DAQGate.html" title="Special:MyLanguage/Modules/DAQGate">DAQ.DAQGate</a>, при роботі OpenSCADA на боці джерела даних або ПЛК.
</p>
<h2><span class="mw-headline" id=".D0.9F.D0.BE.D1.81.D0.B8.D0.BB.D0.B0.D0.BD.D0.BD.D1.8F"><span class="mw-headline-number">6</span> Посилання</span></h2>
<ul><li> <a class="external" href="http://oscada.org/wiki/File:Oscada_subsys_daq_str_uk.odg" title="File:Oscada subsys daq str uk.odg">Діаграма: Ієрархічна структура підсистеми "Збір даних".</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:Daq.xmi.gz" title="File:Daq.xmi.gz">UML: Діаграми послідовності підсистеми "Збір Даних".</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:Daq_loglevel_uk.dia" title="File:Daq loglevel uk.dia">Діаграма: Механізм роботи "Логічного рівня" на прикладі модуля LogicLev.</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:Loglev_prm_uk.dia" title="File:Loglev prm uk.dia">Діаграма: Структура параметру логічного рівня.</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:Daq_progcompon_uk.dia" title="File:Daq progcompon uk.dia">Діаграма: Загальна структура компонентів середовища програмування.</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:UserPrtDevs_concept_uk.odg" title="File:UserPrtDevs concept uk.odg">Діаграма: Концепція доступу до даних через користувацький протокол.</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:Daq_red_uk.odg" title="File:Daq red uk.odg">Діаграма: Горизонтальне та вертикальне резервування.</a></li></ul>






</div><table style="border-top: dotted 2px #999999; margin-top: 20pt; color: gray;" width="100%"><tr><td style="text-align: left;" width="40%"><a href="http://oscada.org/wiki/Documents/DAQ/uk">Documents/DAQ/uk</a> - <a href="http://oscada.org/en/main/about-the-project/licenses/">GFDL</a></td><td style="text-align: center;">September 2022</td><td style="text-align: right;" width="40%"> 1+r2848</td></tr></table></body>
</html>