<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="UTF-8" />
<title>Модули/Протокол пользователя - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../../en/files/doc.css" rel="stylesheet" /></head>
<body><div class="floatright"><a href="http://oscada.org"><img alt="OpenSCADA" src="../../en/files/Logo-big.png" /></a></div><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="ru">Модули/Протокол пользователя</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="ru"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Modules%2FUserProtocol&amp;action=page&amp;filter=&amp;language=ru" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Modules/UserProtocol" title="Modules/UserProtocol">Modules/UserProtocol</a> and the translation is 100% complete.</div><hr /><div class="mw-pt-languages" dir="ltr" lang="en"><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="../../en/Modules/UserProtocol.html" title="Modules/UserProtocol (100% translated)">English</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">российский</span>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--complete" href="../../uk/Modules/UserProtocol.html" title="Модулі/Протокол користувача (100% translated)">українська</a></div></div>
<table class="wikitable">

<tr>
<th> Модуль </th>
<th> Имя </th>
<th> Версия </th>
<th> Лицензия </th>
<th> Источник </th>
<th> Языки </th>
<th> Платформы </th>
<th> Тип </th>
<th> Автор </th>
<th> Описание
</th></tr>

<tr>
<td> <a href="../Modules/UserProtocol.html" title="Special:MyLanguage/Modules/UserProtocol">UserProtocol</a> </td>
<td> Пользовательский протокол
</td>
<td> 1.5 </td>
<td> GPL2 </td>
<td> prot_UserProtocol.so </td>
<td> en,uk,ru,de </td>
<td> x86,x86_64,ARM
</td>
<td> Протокол </td>
<td> Роман Савоченко </td>
<td>
<p>Обеспечивает создание собственных пользовательских протоколов на внутреннем языке OpenSCADA.
</p>
</td></tr></table>
<p>Модуль предназначен для предоставления пользователю возможности создания реализаций различных протоколов собственными силами на внутреннем языке OpenSCADA, обычно <a href="../Modules/JavaLikeCalc.html" title="Special:MyLanguage/Modules/JavaLikeCalc">JavaLikeCalc</a>, не прибегая к низкоуровневому программированию.
</p><p>Основная цель модуля — упростить задачу подключения к OpenSCADA устройств источников данных, которые имеют незначительное распространение и/или предоставляют доступ к собственным данным по специфическому протоколу, обычно достаточно простому для реализации на внутреннем языке OpenSCADA. Для реализации этого предоставляется механизм формирования протокола исходящего запроса.
</p><p>Кроме механизма протокола исходящего запроса предоставляется механизм протокола входящего запроса, который позволяет OpenSCADA обслуживать запросы на получение данных по специфическим протоколам, которые достаточно просто могут быть реализованы на внутреннем языке OpenSCADA.
</p><p>Модуль предоставляет возможность создания реализаций множества различных протоколов в объекте "Пользовательский протокол" (рис.1), а также использовать для этого <a href="../Program_manual.html#DAQTmpl" title="Special:MyLanguage/Documents/Program manual">стандартные шаблоны DAQ</a>. Использование шаблонов DAQ позволяет создавать библиотеки комплексных протоколов и вызов их в этом модуле многократно, как их реализации, а также предоставляет контекст данных исполнения входного шаблона с их связыванием с данными подсистемы "Сбор Данных".
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:754px;"><a class="image" href="http://oscada.org/wiki/File:UserProtocol_up_main_ru.png"><img class="thumbimage" height="573" src="../files/UserProtocol_up_main_ru.png" width="752" /></a>  <div class="thumbcaption">Рис.1. Основная вкладка объекта "Пользовательский протокол".</div></div></div></div>
<p>Главная вкладка содержит основные настройки пользовательского протокола:
</p>
<ul><li> Раздел "Состояние" — содержит свойства, характеризующие состояние протокола: статус, "Включен", имя БД (содержащей конфигурацию и с отслеживанием наличия данных в различных хранилищах и предоставлением последовательного удаления дубликатов) и дату последней модификации.</li>
<li> Идентификатор, имя и описание узла протокола.</li>
<li> Состояние "Включен", в которое переводить протокол при загрузке.</li>
<li> <a href="../Program_manual.html#DAQTmpl" title="Special:MyLanguage/Documents/Program manual">DAQ шаблон</a>, связанный с протоколом. Выбор шаблона тут выключает режим работы по прямым процедурам и доступ к следующим опциям. Режим DAQ-шаблона может работать во входном, выходном или обоих режимах запроса, в зависимости от наличия необходимых атрибутов.</li>
<li> Признак полного перевода текста процедур и языка входной и выходной процедур. Выбор языка для входной и/или выходной процедур включает соответствующую часть протокола и открывает доступ к соответствующим вкладкам конфигурации.</li></ul>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.D0.92.D1.85.D0.BE.D0.B4.D0.BD.D0.B0.D1.8F_.D1.87.D0.B0.D1.81.D1.82.D1.8C_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D0.B0"><span class="tocnumber">1</span> <span class="toctext">Входная часть протокола</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#.D0.92.D1.8B.D1.85.D0.BE.D0.B4.D0.BD.D0.B0.D1.8F_.D1.87.D0.B0.D1.81.D1.82.D1.8C_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D0.B0"><span class="tocnumber">2</span> <span class="toctext">Выходная часть протокола</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id=".D0.92.D1.85.D0.BE.D0.B4.D0.BD.D0.B0.D1.8F_.D1.87.D0.B0.D1.81.D1.82.D1.8C_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D0.B0"><span class="mw-headline-number">1</span> Входная часть протокола</span></h2>
<p>Протокол входных запросов работает в кооперации с входным транспортом и отдельный объект "Пользовательского протокола" указывается в поле конфигурации протокола транспорта, вместе с именем модуля UserProtocol. Далее все запросы к транспорту будут направляться к прямой процедуре, или процедуре шаблону, с обработки запроса протокола (рис.2).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:893px;"><a class="image" href="http://oscada.org/wiki/File:UserProtocol_up_in_ru.png"><img class="thumbimage" height="690" src="../files/UserProtocol_up_in_ru.png" width="891" /></a>  <div class="thumbcaption">Рис.2. Вкладка конфигурации и контроля входных запросов.</div></div></div></div>
<p>Вкладка конфигурации и контроля входных запросов содержит:
</p>
<ul><li> Время ожидания запроса, в миллисекундах. Используется для включения режима пулинга-опробования, установкой в ненулевое значение. В режиме пулинга-опробования входной транспорт будет вызывать протокол с пустым запросом, в случае отсутствия запроса в течении указанного времени.</li>
<li> Таблицу контекста данных процедуры входного запроса. В основном имеет смысл только при работе по шаблону и где можно контролировать этот процесс обработки, включая возможность вмешательства через изменение значений данных.</li>
<li> Текст прямой процедуры протокола, отсутствует в режиме работы по шаблону.</li>
<li> Связи на данные подсистемы "Сбор Данных", которые видимы и доступны для определения в режиме работы по шаблону и во включенном состоянии объекта протокола.</li></ul>
<p>Для прямой процедуры обработки предопределены, и обязательны или опциональны для создания в шаблоне, следующие атрибуты обмена с входящим транспортом:
</p>
<ul><li> <i><b>Входной результат (rez)</b></i> &lt;Логический&gt; — результат обработки (false — полный запрос; true — неполный, удерживать подключение); в режиме DAQ-шаблона Вы должны писать сюда прямо, не оператором "return";</li>
<li> <i><b>Входной запрос (request)</b></i> &lt;Строка&gt; — полное-аккумулированное сообщение запроса, которое протокол должен очищать на предмет обработанных данных;</li>
<li> <i><b>Входной ответ (answer)</b></i> &lt;Строка&gt; — сообщение ответа;</li>
<li> <i>Входной отправитель (sender)</i> &lt;Строка&gt; — отправитель запроса;</li>
<li> <i>Транспорт (tr)</i> &lt;Объект&gt; — объект входного транспорта.</li></ul>
<p>Общий сценарий обработки входящих запросов:
</p>
<ul><li> Запрос формируется удалённой станцией и через сеть попадает на <a href="../Program_manual.html#Communication" title="Special:MyLanguage/Documents/Program manual">транспорт OpenSCADA</a>.</li>
<li> OpenSCADA транспорт передаёт запрос этому модулю, выбранному в поле протокола, и объекту пользовательского протокола, в виде значений переменной "request" — для последовательности запроса и "sender" — для адреса отправителя запроса.</li>
<li> Запускается выполнение процедуры протокола входящего запроса, в процессе которой анализируется содержимое переменной "request" и формируется ответ в переменной "answer". По окончанию выполнения процедуры формируется переменная "rez", которая указывает транспорту на факт получения полного запроса и формирование корректного ответа (false) или необходимость транспорту ожидать остатка данных (true) — удерживать подключение.</li>
<li> Если результат обработки равен "false", и ответ ненулевой, то транспорт отправляет ответ, а сама процедура протокола должна удалить обработанную часть запроса "request", поскольку только она может определить целостность посылки и потенциальное наличие за ней начала следующей.</li>
<li> Если результат процедуры обработки равен "true" то транспорт продолжает ожидать данные. При получении следующей порции данных они добавляются к переменной "request" и выполнение процедуры повторяется.</li></ul>
<p>В качестве примера рассмотрим реализацию обработки запросов по протоколу DCON для некоторых запросов к источнику данных с адресом "10":
</p>
<pre style="white-space: pre-wrap;">
var enCRC = true;
//SYS.messDebug("/DCON/in","REQ: "+request);
//Проверка запроса на полноту
if(request.length &lt; 4 || request[request.length-1]&nbsp;!= "\r") {
  if(request.length &gt; 10) request = "";
  return true;
}
//Проверка запроса на целостность (CRC) и адрес
if(enCRC) {
  CRC = 0;
  for(i = 0; i &lt; (request.length-3); i++) CRC += request.charCodeAt(i);
  if(CRC&nbsp;!= request.slice(request.length-3,request.length-1).toInt(16) || request.slice(1,3).toInt(16)&nbsp;!= 10) return false;
}
//Анализ запроса и подготовка ответа
if(request[0] == "#") answer = "&gt;+05.123+04.153+07.234-02.356+10.000-05.133+02.345+08.234";
else if(request[0] == "@") answer = "&gt;AB3C";
else answer = "?";
//Завершение ответа
if(enCRC) {
  CRC = 0;
  for(i=0; i &lt; answer.length; i++) CRC += answer.charCodeAt(i);
  answer += (CRC&amp;0xFF).toString(16,2)+"\r";
}
//SYS.messDebug("/DCON/in","ANSV: "+answer[0]);
return 0;
</pre>
<h2><span class="mw-headline" id=".D0.92.D1.8B.D1.85.D0.BE.D0.B4.D0.BD.D0.B0.D1.8F_.D1.87.D0.B0.D1.81.D1.82.D1.8C_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D0.B0"><span class="mw-headline-number">2</span> Выходная часть протокола</span></h2>
<p>Протокол исходящих запросов работает в кооперации с исходящим транспортом и отдельным объектом "Пользовательского протокола". Источником запроса через протокол может выступать <a href="../User_API.html#SYSTransport" title="Special:MyLanguage/Documents/User API">функция общесистемного API пользовательского программирования выходного транспорта</a> "<b>int messIO( XMLNodeObj req, string prt );</b>", в параметрах которой указывается:
</p>
<ul><li> <i>req</i> — запрос в виде дерева XML со структурой, соответствующей входному формату реализованного протокола;</li>
<li> <i>prt</i> — имя этого модуля — "UserProtocol".</li></ul>
<p>Запрос, отправленный вышеуказанным образом, направляться в прямую процедуру обработки запроса протокола (рис.3), или процедуру шаблона, с идентификатором пользовательского протокола, указываемым в атрибуте <b>req.attr("ProtIt")</b>.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:893px;"><a class="image" href="http://oscada.org/wiki/File:UserProtocol_up_out_ru.png"><img class="thumbimage" height="690" src="../files/UserProtocol_up_out_ru.png" width="891" /></a>  <div class="thumbcaption">Рис.3. Вкладка прямой процедуры обслуживания исходящих запросов.</div></div></div></div>
<p>Вкладка процедуры обработки выходных запросов содержит только поле текста прямой процедуры обработки на внутреннем языке программирования OpenSCADA, который указан в предыдущей вкладке. Эта вкладка отсутствует для режима работы по шаблону.
</p><p>Для процедуры обработки предопределены, и обязательные или опциональные для создания в шаблоне, следующие атрибуты обмена:
</p>
<ul><li> <i><b>Выходной ВВ (io)</b></i> &lt;Объект::XMLNode&gt; — XML узел обмена с клиентом, через который протокол принимает запросы и в который помещается результат в формате, который реализуется процедурой;</li>
<li> <i><b>Транспорт (tr)</b></i> &lt;Объект&gt; — объект транспорта, предназначено для вызова функции транспорта <i>string messIO( string mess, real timeOut = 1000 );</i> — <b>tr.messIO(req)</b>, блокируется на время вызова процедуры.</li></ul>
<p>Общий сценарий формирования выходного запроса:
</p>
<ul><li> Формирование XML-дерева согласно структуре, которая реализуется протоколом, и указание идентификатора пользовательского протокола в атрибуте "ProtIt".</li>
<li> Отправка запроса транспорту через этот протокол — "<b>SYS.Transport["{Modul}"]["out_{OutTransp}"].messIO(req, "UserProtocol");</b>".</li>
<li> Выбор пользовательского протокола согласно <b>req.attr("ProtIt")</b> и инициализация переменных выходного транспорта: <i>io</i> — согласно первому аргументу <b>messIO()</b> и <i>tr</i> — объект "OutTransp".</li>
<li> Вызов процедуры на исполнение, которая, осуществив обработку структуры <i>io</i>, формирует прямой запрос транспорта <i>tr.messIO(req);</i>, результат которого обрабатывается и помещается назад в <i>io</i>.</li></ul>
<p>Суть выделения протокольной части кода в процедуру пользовательского протокола заключается в упрощении и унификации интерфейса клиентского обмена при многократном использовании и предполагает формирование структуры XML-узла обмена в виде атрибутов адресов удалённых станций, адресов читаемых и записываемых переменных, а также значений самих переменных. При этом весь груз непосредственного кодирования запроса и декодирования ответа возлагается на процедуру пользовательского протокола. Если это одноразовая реализация, которая к тому-же не предусматривает реализации входной части, то проще это сделать прямо в исходном шаблоне к источнику данных, в виде встроенной функции.
</p><p>В качестве примера рассмотрим реализацию запросов посредством протокола DCON к обработчику, реализованному в предыдущем разделе. Начнём с реализации протокольной части:
</p>
<pre style="white-space: pre-wrap;">
//Формирование конечного запроса
request = io.name().slice(0,1) + io.attr("addr").toInt().toString(16,2) + io.text();
if(io.attr("CRC").toInt()) {
  CRC = 0;
  for(i = 0; i &lt; request.length; i++) CRC += request.charCodeAt(i);
    request += (CRC&amp;0xFF).toString(16,2) + "\r";
}
else request += "\r";
//Отправка запроса
resp = tr.messIO(request);
while(resp[resp.length-1]&nbsp;!= "\r") {
  tresp = tr.messIO("");
  if(!tresp.length) break;
  resp += tresp;
}
//Анализ ответа
if(io.attr("CRC").toInt()) {
  if(resp.length &lt; 4 || resp[resp.length-1]&nbsp;!= "\r") { io.setAttr("err","10:"+tr("Error or no response.")); return; }
  //Проверка ответа на целостность (CRC)
  CRC = 0;
  for(i = 0; i &lt; (resp.length-3); i++) CRC += resp.charCodeAt(i);
    if(CRC&nbsp;!= resp.slice(resp.length-3,resp.length-1).toInt(16)) { io.setAttr("err","11:"+tr("CRC error.")); return; }
}
else if(resp.length &lt; 2 || resp[resp.length-1]&nbsp;!= "\r") { io.setAttr("err","10:"+tr("Error or no response.")); return; }
if(resp[0]&nbsp;!= "&gt;") { io.setAttr("err","12:"+resp[0]+":"+tr("DCON error.")); return; }
//Возврат результата
io.setAttr("err","");
io.setText(resp.slice(1,resp.length-3));
</pre>
<p>И процедура непосредственной отправки DCON запроса, через предыдущую процедуру протокола. Эту процедуру необходимо поместить в нужную задачу или промежуточную функцию OpenSCADA, например, в процедуру объекта контроллера <a href="../Modules/JavaLikeCalc.html#Examples" title="Special:MyLanguage/Modules/JavaLikeCalc">DAQ.JavaLikeCalc</a>:
</p>
<pre style="white-space: pre-wrap;">
//Подготовка запроса
req = SYS.XMLNode("#").setAttr("ProtIt","DCON").setAttr("addr",10);
//Отправка запроса
SYS.Transport["Serial"]["out_TestDCON"].messIO(req,"UserProtocol");
if(!req.attr("err").length) SYS.messDebug("TEST REQ","RES: "+req.text());

//Подготовка второго запроса
req = SYS.XMLNode("@").setAttr("ProtIt","DCON").setAttr("addr",10);
//Отправка второго запроса
SYS.Transport["Serial"]["out_TestDCON"].messIO(req,"UserProtocol");
if(!req.attr("err").length) SYS.messDebug("TEST REQ","RES: "+req.text());
</pre>






</div><table style="border-top: dotted 2px #999999; margin-top: 20pt; color: gray;" width="100%"><tr><td style="text-align: left;" width="40%"><a href="http://oscada.org/wiki/Modules/UserProtocol/ru">Modules/UserProtocol/ru</a> - <a href="http://oscada.org/en/main/about-the-project/licenses/">GFDL</a></td><td style="text-align: center;">November 2021</td><td style="text-align: right;" width="40%">OpenSCADA 1+r2782</td></tr></table></body>
</html>