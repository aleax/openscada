<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<title>Модули/Serial - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../files/doc.css" rel="stylesheet" /></head>
<body><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="ru">Модули/Serial</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="ru"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Modules%2FSerial&amp;action=page&amp;filter=&amp;language=ru" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Modules/Serial" title="Modules/Serial">Modules/Serial</a> and the translation is 100% complete.</div><hr /><div class="mw-pt-languages noprint" dir="ltr" lang="en"><div class="mw-pt-languages-label">Other languages:</div><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="http://oscada.org/wiki/Modules/Serial" title="Modules/Serial (100% translated)">English</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">российский</span>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--complete" href="http://oscada.org/wiki/Modules/Serial/uk" title="Модулі/Serial (100% translated)">українська</a></div></div>
<div class="noprint" style="float:right; border:1px solid gray; width:300px; background-color:ivory; padding:2px;">
<table cellspacing="0">
<tr>
<td> <a class="image" href="http://oscada.org/wiki/File:Constr.png"><img alt="Constr.png" height="32" src="../files/Constr.png" width="32" /></a>
</td>
<td style="padding-left:5px;"> The translation checking and actualizing
</td></tr></table>
</div>
<table class="wikitable">

<tr>
<th> Модуль </th>
<th> Имя </th>
<th> Версия </th>
<th> Лицензия </th>
<th> Источник </th>
<th> Языки </th>
<th> Платформы </th>
<th> Тип </th>
<th> Автор </th>
<th> Описание
</th></tr>

<tr>
<td> <a href="../Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> </td>
<td> Последовательные интерфейсы  </td>
<td> 1.6 </td>
<td> GPL2 </td>
<td> tr_Serial.so </td>
<td> en,uk,ru,de </td>
<td> x86,x86_64,ARM
</td>
<td> Транспорт </td>
<td> Роман Савоченко, Максим Кочетков </td>
<td> Предоставляет последовательные интерфейсы. Используется для обмена данными через последовательные интерфейсы типа RS232, RS485, GSM и другое.
</td></tr></table>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.D0.92.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B8.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="tocnumber">1</span> <span class="toctext">Входящие транспорты</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#.D0.98.D1.81.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B8.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="tocnumber">2</span> <span class="toctext">Исходящие транспорты</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#API_.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">3</span> <span class="toctext">API пользовательского программирования</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#.D0.97.D0.B0.D0.BC.D0.B5.D1.87.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">4</span> <span class="toctext">Замечания</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#.D0.92.D0.B8.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5.2F.D0.BB.D0.BE.D0.BA.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D1.8B"><span class="tocnumber">4.1</span> <span class="toctext">Виртуальные/локальные последовательные интерфейсы</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#.D0.9F.D1.80.D0.BE.D0.B1.D1.80.D0.BE.D1.81_.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.B0_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_.D1.81.D0.B5.D1.82.D1.8C_Ethernet"><span class="tocnumber">4.2</span> <span class="toctext">Проброс последовательного интерфейса через сеть Ethernet</span></a></li>
</ul>
</li>
</ul>
</div>

<p>Модуль транспорта Serial предоставляет в систему поддержку транспортов, основанных на последовательных интерфейсах типа RS232, RS485, GSM и другие. Поддерживаются входящие и исходящие транспорты. Добавить новые входящие и исходящие интерфейсы можно посредством конфигурации транспортной подсистемы в любом конфигураторе системы OpenSCADA.
</p><p>В режиме модема модулем поддерживается смешанный режим работы. Смешанный режим подразумевает наличие входящего транспорта, который ожидает внешних подключений, а также исходящего транспорта на том-же устройстве. Т.е. входящий транспорт будет игнорировать все запросы при наличии установленного исходящим транспортом соединения, в тоже время исходящий транспорт не будет осуществлять попыток установить соединение при наличии подключения к входящему транспорту или соединения другого исходящего транспорта, например, с другим номером телефона.
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../files/At.png" width="22" /></a> В обычном режиме последовательного интерфейса не допускается многократное использование одного и того-же порта во входящих и исходящих транспортах. Глобального блокирования последовательного устройства не осуществляется в виду неоднозначности этого процесса на системном уровне, а многократное использование может привести к непредсказуемым проблемам. При необходимости организации локального последовательного канала с парой связанных портов рекомендуется использование команды "<b>$ socat -d -d pty,raw,echo=0,perm=0666 pty,raw,echo=0,perm=0666</b>".
</p>
<h2><span class="mw-headline" id=".D0.92.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B8.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="mw-headline-number">1</span> Входящие транспорты</span></h2>
<p>Сконфигурированный и запущенный входящий транспорт открывает порт последовательного интерфейса для ожидания запросов клиентов. Каждый входящий интерфейс обязательно связывается с одним из доступных транспортных протоколов, к которому передаются входящие сообщения.
</p><p>Диалог конфигурации входящего последовательного интерфейса изображён на рисунок 1.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:667px;"><a class="image" href="http://oscada.org/wiki/File:Serial_in_ru.png"><img class="thumbimage" height="533" src="../files/Serial_in_ru.png" width="665" /></a>  <div class="thumbcaption">Рис.1. Диалог конфигурации входящего последовательного интерфейса.</div></div></div></div>
<p>С помощью этого диалога можно установить:
</p>
<ul><li> Состояние транспорта, а именно: "Статус", "Выполняется" и имя БД, содержащей конфигурацию.</li>
<li> Идентификатор, имя и описание транспорта.</li>
<li> Адрес интерфейса в формате строки: <i>"dev:spd:format[:fc[:mdm]]"</i>. Где:
<ul><li> <i>dev</i> — адрес последовательного устройства (/dev/ttyS0);</li>
<li> <i>spd</i> — скорость последовательного устройства из ряда: 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000 или 921600;</li>
<li> <i>format</i> — формат асинхронных данных "{размер}{чётность}{стоп}" (8N1, 7E1, 5O2, ...);</li>
<li> <i>fc</i> — управление потоком:
<ul><li> "h" — аппаратное (CRTSCTS);</li>
<li> "s" — программное (IXON|IXOFF);</li>
<li> "rts" — использование RTS сигнала для передачи(false) и проверки на эхо, для сырого RS-485;</li>
<li> "rts1" — использование RTS сигнала для передачи(true) и проверки на эхо, для сырого RS-485;</li>
<li> "rtsne" — использование RTS сигнала для передачи(false) без проверки на эхо, для сырого RS-485;</li>
<li> "rts1ne" — использование RTS сигнала для передачи(true) без проверки на эхо, для сырого RS-485;     </li>
<li> "RS485" — использовать RS-485 режим, посредством TIOCSRS485.</li></ul></li>
<li> <i>mdm</i> — режим модема, ожидание 'RING'.</li></ul></li>
<li> Выбор транспортного протокола.</li>
<li> Состояние, в которое переводить транспорт при загрузке: "Запущен".</li>
<li> Временные интервалы интерфейса в формате строки: <i>"symbol:frm[::rtsDelay1:rtsDelay2]"</i>. Где:
<ul><li> <i>symbol</i> — время символа в миллисекундах. Используется для контроля факта окончания фрейма;</li>
<li> <i>frm</i> — максимальное время фрейма в миллисекундах. Используется для ограничение максимального размера пакета запроса (фрейма);</li>
<li> <i>rtsDelay1</i> — задержка, в миллисекундах, между включением передатчика сигналом RTS и началом передачи;</li>
<li> <i>rtsDelay2</i> — задержка, в миллисекундах, между окончанием передачи и отключением передатчика сигналом RTS.</li></ul></li>
<li> Приоритет задачи входящего потока.</li></ul>
<p>Транспорт поддерживает возможность работы в режиме модема. Данный режим включается пятым параметром адреса и подразумевает ожидания звонка от удалённого модема (запрос "RING"), ответа на звонок (команда "ATA") и последующей передачи запросов от удалённой станции протоколу транспорта. Отключение сеанса связи осуществляется инициатором соединения и приводит к переподключению модема приёмника на ожидание новых звонков.
</p><p>Для настройки модема входящего транспорта предусмотрена специальная вкладка "Модем" (рис.2).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:650px;"><a class="image" href="http://oscada.org/wiki/File:Serial_in_mod_ru.png"><img class="thumbimage" height="476" src="../files/Serial_in_mod_ru.png" width="648" /></a>  <div class="thumbcaption">Рис.2. Вкладка "Модем" конфигурации модема входящего последовательного интерфейса.</div></div></div></div>
<p>С помощью этого диалога можно установить следующие свойства работы с модемом:
</p>
<ul><li> Время ожидания, таймаут, модема на запросы, в секундах.</li>
<li> Выдержка времени перед инициализацией модема, в секундах.</li>
<li> Выдержка времени после инициализации модема, в секундах.</li>
<li> Первая строка инициализации, обычно содержит команду сброса настроек модема "ATZ".</li>
<li> Вторая строка инициализации.</li>
<li> Строка результата инициализации модема, обычно "OK", которой отвечает модем на инициализацию и которую нужно ожидать.</li>
<li> Запрос звонка, обычно "RING", который шлёт модем в случае поступления исходящего вызова.</li>
<li> Ответ на звонок, обычно "ATA", который отправляется модему для ответа на звонок.</li>
<li> Строка результата на ответ на звонок, обычно "CONNECT", которой отвечает модем на команду ответа и которую нужно ожидать.</li></ul>
<h2><span class="mw-headline" id=".D0.98.D1.81.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B8.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="mw-headline-number">2</span> Исходящие транспорты</span></h2>
<p>Сконфигурированный и запущенный исходящий транспорт открывает порт последовательного интерфейса для отправки запросов через него.
</p><p>Главная вкладка страницы конфигурации исходящего последовательного интерфейса изображёна на рис.3.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:751px;"><a class="image" href="http://oscada.org/wiki/File:Serial_out_ru.png"><img class="thumbimage" height="560" src="../files/Serial_out_ru.png" width="749" /></a>  <div class="thumbcaption">Рис.3. Главная вкладка страницы конфигурации исходящего последовательного интерфейса.</div></div></div></div>
<p>С помощью этого диалога можно установить:
</p>
<ul><li> Состояние транспорта, а именно: "Статус", "Запущен" и имя БД, содержащей конфигурацию.</li>
<li> Идентификатор, имя и описание транспорта.</li>
<li> Адрес интерфейса в формате строки: <i>"dev:spd:format[:fc[:modTel]]"</i>. Где:
<ul><li> <i>dev</i> — адрес последовательного устройства (/dev/ttyS0);</li>
<li> <i>spd</i> — скорость последовательного устройства из ряда: 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000 или 921600;</li>
<li> <i>format</i> — формат асинхронных данных "{размер}{чётность}{стоп}" (8N1, 7E1, 5O2, ...);</li>
<li> <i>fc</i> — управление потоком:
<ul><li> "h" — аппаратное (CRTSCTS);</li>
<li> "s" — программное (IXON|IXOFF);</li>
<li> "rts" — использование RTS сигнала для передачи(false) и проверки на эхо, для сырого RS-485;</li>
<li> "rts1" — использование RTS сигнала для передачи(true) и проверки на эхо, для сырого RS-485;</li>
<li> "rtsne" — использование RTS сигнала для передачи(false) без проверки на эхо, для сырого RS-485;</li>
<li> "rts1ne" — использование RTS сигнала для передачи(true) без проверки на эхо, для сырого RS-485;     </li>
<li> "RS485" — использовать RS-485 режим, посредством TIOCSRS485.</li></ul></li>
<li> <i>modTel</i> — телефон модема, присутствие этого поля переключает транспорт на работу в режиме модема.</li></ul></li>
<li> Состояние, в которое переводить транспорт при загрузке: "Запущен".</li>
<li> Временные интервалы интерфейса в формате строки: <i>"conn:symbol[-NextReqMult][:KeepAliveTm[:rtsDelay1:rtsDelay2]]"</i>. Где:
<ul><li> <i>conn</i> — время ожидания соединения т.е. ответа от удалённого устройства;</li>
<li> <i>symbol</i> — время символа в миллисекундах. Используется для контроля факта окончания фрейма и таймаута следующего запроса;</li>
<li> <i>NextReqMult</i> — множитель времени следующего запроса к времени символа <i>symbol</i>, 4 по умолчанию;</li>
<li> <i>KeepAliveTm</i> — таймаут жизни в секундах для перезапуска транспорта;</li>
<li> <i>rtsDelay1</i> — задержка, в миллисекундах, между включением передатчика сигналом RTS и началом передачи;</li>
<li> <i>rtsDelay2</i> — задержка, в миллисекундах, между окончанием передачи и отключением передатчика сигналом RTS.</li></ul></li>
<li> Не останавливать при обработке. Иногда закрытие открытого устройства может быть разрушительным, например, на ПЛК LP от ICP-DAS, и Вы можете предотвратить это данной опцией.</li></ul>
<p>Транспорт поддерживает возможность работы в режиме модема. Данный режим включается наличием пятого параметра адреса и подразумевает осуществление звонка по телефону, указанному пятым параметром, в момент запуска транспорта. После установки связи с удалённым модемом все запросы передачи направляются станции за удалённым модемом. Отключение сеанса связи, с остановкой транспорта, осуществляется по таймауту активности.
</p><p>Транспорт может работать с аппаратной шиной I2С если в качестве устройства выбрать "/dev/i2c-{N}" и шина позволит установить адрес подчинённого устройства командой I2C_SLAVE, из <b>первого байта запроса</b>. Скорость и формат не играют роли в данном режиме. Из таймаутов тут фактически работает только время символа и в основном для расчёта ожидания повтора запроса.
</p><p>Для настройки модема исходящего транспорта предусмотрена специальная вкладка "Модем" (рис.4).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:695px;"><a class="image" href="http://oscada.org/wiki/File:Serial_out_mod_ru.png"><img class="thumbimage" height="561" src="../files/Serial_out_mod_ru.png" width="693" /></a>  <div class="thumbcaption">Рис.4. Вкладка "Модем" конфигурации модема исходящего последовательного интерфейса.</div></div></div></div>
<p>С помощью этого диалога можно установить следующие свойства работы с модемом:
</p>
<ul><li> Время ожидания, таймаут, модема на запросы, в секундах.</li>
<li> Время жизни соединения, в секундах. Если в течении этого времени будет отсутствовать передача данных через транспорт то соединение будет разорвано.</li>
<li> Выдержка времени перед инициализацией модема, в секундах.</li>
<li> Выдержка времени после инициализации модема, в секундах.</li>
<li> Первая строка инициализации, обычно содержит команду сброса настроек модема "ATZ".</li>
<li> Вторая строка инициализации.</li>
<li> Строка результата инициализации модема, обычно "OK", которой отвечает модем на инициализацию и которую нужно ожидать.</li>
<li> Строка дозвона к удалённому модему, обычно "ATDT". При дозвоне номер телефона добавляется к данному префиксу.</li>
<li> Строка результата удачного соединения, обычно "CONNECT".</li>
<li> Строка результата занятости линии, обычно "BUSY".</li>
<li> Строка результата отсутствия несущей в линии, обычно "NO CARRIER".</li>
<li> Строка результата отсутствия гудка линии, обычно "NO DIALTONE".</li>
<li> Строка выхода из режима данных, обычно "+++" и "Время перед инициализацией модема" после неё используется.</li>
<li> Команда повесить трубку, обычно "+++ATH". Данная команда вызывается всегда, когда нужно разорвать соединение.</li>
<li> Строка результата команды повесить трубку, обычно "OK", которой отвечает модем на команду и которую нужно ожидать.</li></ul>
<h2><span class="mw-headline" id="API_.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"><span class="mw-headline-number">3</span> API пользовательского программирования</span></h2>
<p><b>Объект "Исходящий транспорт" (SYS.Transport.Serial.out_{OutTransport})</b>
</p>
<ul><li> <i>bool TS( bool rts = EVAL )</i> — Управление отправкой посредством установки запроса <i>rts</i> и возврат состояния разрешения CTS.</li>
<li> <i>bool DR( bool dtr = EVAL )</i> — Управление готовностью устройства посредством установки готовности терминала <i>dtr</i> и возврат состояния готовности DSR.</li>
<li> <i>bool DCD()</i> — Возврат состояния обнаружения несущей данных.</li>
<li> <i>bool RI()</i> — Возврат индикатора звонка.</li>
<li> <i>int sendbreak( int duration = 0 )</i> — Отправить в поток прерывание нулями в течении <i>duration</i> (0 — некоторый интервал по умолчанию).</li></ul>
<h2><span class="mw-headline" id=".D0.97.D0.B0.D0.BC.D0.B5.D1.87.D0.B0.D0.BD.D0.B8.D1.8F"><span class="mw-headline-number">4</span> Замечания</span></h2>
<p>Коммуникации через последовательные интерфейсы имеют ряд особенностей. Наиболее важной особенностью является критерий окончания сообщения и время ожидания этого критерия. В одних протоколах таким критерием является признак окончания или указанный размер сообщения. В других протоколах таким критерием является отсутствие данных во входящем потоке в течение указанного времени, время символа. В обоих случаях время ожидания критерия или символа является ключевым и сильно сказывается на общем времени обмена. Следовательно, чем меньше это время тем лучше. Тут и возникает проблема латентности оборудования и его драйверов.
</p><p>Проверить латентность канала обмена и тем самым оптимально настроить время дожидания, символа можно с помощью интерфейса вкладки "Запрос" исходящего транспорта. Для этого необходимо указать образцовый запрос соответствующего протокола, указать "Ожидать таймаут", отослать запрос и проконтролировать его целостность. Для получения более репрезентативного результата необходимо запрос повторить несколько раз. Если наблюдается получение неполных ответов, то время символа необходимо увеличить, иначе можно уменьшить.
</p><p>На встроенном оборудовании последовательных интерфейсов RS232/422/485 можно добиться низкого уровня латентности, вплоть до единиц миллисекунд. Однако, на высоко-нагруженных системах с множеством задач в приоритете реального времени латентность может стать недетерминированной в связи с исполнением потока обслуживания событий ядра Linux в низком приоритете. Для решения этой проблемы необходимо установить высокий приоритет этим потокам, что можно сделать с помощью скрипта, поместив его, например, в "/etc/rc.local":
</p>
<pre style="white-space: pre-wrap;">
#!/bin/sh

# High priority set to kernel threads events for serial interfaces reaction rise
events=`ps -Ao pid,comm | sed -n '/[ ]*\([^ ]\)[ ]*events\/[0-9]/s//\1/p'`
for ie in $events; do
  chrt -pr 21 $ie
done
</pre>
<p>Этот скрипт не имеет смысла для ядер Linux реального времени, с патчем PREEMPT_RT, поскольку все потоки прерываний и событий там уже запускаются в приоритете реального времени.
</p><p>На внешнем оборудовании последовательных интерфейсов, например, в переходниках USB-&gt;RS232/422/485, может возникнуть проблема высокой латентности, связанная с особенностью аппаратной реализации или его драйвера. Решать эту проблему нужно путём изучения настроек этого оборудования или установкой большого времени ожидания, символа!
</p><p>Похожим образом определяется и оптимальное время подключения, а именно: установить время подключения в значение по умолчанию для данной скорости (ставится при смене скорости в адресе), снять "Ожидать таймаут", отослать запрос. Если ответ пришёл то берём измеренное время отклика устройства, удваиваем и устанавливаем полученное значение как время подключения. Необоснованное превышение времени подключения приведёт к большим ожиданиям в случае отсутствия устройства, а также срабатывания защитных таймаутов внутренних процедур!
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../files/At.png" width="22" /></a> На рынке встречаются USB-&gt;Serial преобразователи, которые работают только с терминалами, т.е. они могут передавать и обрабатывать исключительно ASCII символы и не могут быть переключены в бинарный режим. Известные экземпляры таких преобразователей: PL2303TA (Y-105).
</p>
<h3><span class="mw-headline" id=".D0.92.D0.B8.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5.2F.D0.BB.D0.BE.D0.BA.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D1.8B"><span class="mw-headline-number">4.1</span> Виртуальные/локальные последовательные интерфейсы</span></h3>
<p>Часто для локальной проверки, без физического оборудования, необходима пара портов подключенных в одну сеть. Создание таких портов и выполнение множества других операций над последовательным потоком позволяет выполнять утилита <b>socat</b>. Например, для создания двух связанных портов нужно выполнить команду, которая создаст их и сообщит адреса:
</p>
<pre style="white-space: pre-wrap;">
$ socat -d -d pty,raw,echo=0,perm=0666 pty,raw,echo=0,perm=0666
2013/07/02 16:37:29 socat[10402] N PTY is /dev/pts/6
2013/07/02 16:37:30 socat[10402] N PTY is /dev/pts/7
2013/07/02 16:37:30 socat[10402] N starting data transfer loop with FDs [3,3] and [5,5]
</pre>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B1.D1.80.D0.BE.D1.81_.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.B0_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_.D1.81.D0.B5.D1.82.D1.8C_Ethernet"><span class="mw-headline-number">4.2</span> Проброс последовательного интерфейса через сеть Ethernet</span></h3>
<p>В некоторых случаях бывает полезным пробросить порт последовательного интерфейса удалённой машины на локальный порт, например, для опроса устройств, подключенных к последовательному интерфейсу удалённой машины. Конечно, если установить на удалённую машину OpenSCADA в конфигурации ПЛК, то можно будет сразу выполнять обработку этих данных, предварительное буферирование/архивирование и т.д., но иногда оборудование может быть сложным для запуска OpenSCADA, где и спасает возможность проброса последовательного потока через сеть. Для решения этой задачи можно воспользоваться той-же утилитой <b>socat</b> или <b>remserial</b>, <b>ser2net</b>, какую удастся собрать и запустить на удалённой машине. Примеры проброса последовательного порта:
</p>
<pre style="white-space: pre-wrap;">
# Создание сокета на порту 5555 удалённой машине, для порта /dev/ttyS0
$ socat tcp-l:5555,reuseaddr,fork file:/dev/ttyS0,raw
# Подключение к сокету отражённого порта удалённой машины и формирование файла отражённого локального интерфейса
$ socat -d -d pty,raw,echo=0,perm=0666 tcp:192.168.2.4:5555,mss=1400
2013/07/04 10:09:09 socat[12947] N PTY is /dev/pts/4
2013/07/04 10:09:09 socat[12947] N opening connection to AF=2 192.168.2.4:5555
2013/07/04 10:09:09 socat[12947] N successfully connected from local address AF=2 192.168.2.61:33493
2013/07/04 10:09:09 socat[12947] N starting data transfer loop with FDs [3,3] and [5,5]
</pre>
<p>В случае с "socat", а возможно и других утилит, можно на клиентской стороне опустить запуск драйвера EthernetTCP-&gt;Serial и подключаться из OpenSCADA прямо на TCP-порт удалённого устройства.
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../files/At.png" width="22" /></a> В работе через драйвер EthernetTCP-&gt;Serial есть особенность, которая связанна с наличием двух таймаутов подключения, один в драйвере, другой в <a href="../Modules/Sockets.html" title="Special:MyLanguage/Modules/Sockets">Transport.Sockets</a>. Важно чтобы значение этого таймаута в <a href="../Modules/Sockets.html" title="Special:MyLanguage/Modules/Sockets">Transport.Sockets</a> был больше чем в драйвере иначе возможно смещение и получение на запрос запоздалый ответ от предыдущего запроса.
</p><p>Многие производители промышленного коммуникационного оборудования выпускают готовые конвертеры из Ethernet в RS-232/422/485, которые могут использоваться с OpenSCADA таким-же образом. Комментарии и перечень конвертеров с которыми работа OpenSCADA проверена:
</p>
<ul><li> <a class="external text" href="http://www.icpdas.com" rel="nofollow noreferrer noopener" target="_blank">ICP DAS</a>: <a class="external text" href="http://www.icpdas.com/products/Industrial/pds/tds-700.htm" rel="nofollow noreferrer noopener" target="_blank">tDS-7xx</a> — настраивается через WEB-интерфейс и работает по прямому подключение к TCP-порту;</li>
<li> <a class="external text" href="http://tibbo.com" rel="nofollow noreferrer noopener" target="_blank">Tibbo</a>: <a class="external text" href="http://tibbo.com/products/controllers/ds100.html" rel="nofollow noreferrer noopener" target="_blank">DS100</a> — <span style="color: red">настраивается только через программу для MS Windows®</span>, предоставляет собственный драйвер для формирования виртуальных последовательных интерфейсов на Linux, работает по прямому подключение к TCP-порту.</li></ul>






</div></body>
</html>