<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="UTF-8" />
<title>Модули/Serial - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../../en/files/doc.css" rel="stylesheet" /></head>
<body><div class="floatright"><a href="http://oscada.org"><img alt="OpenSCADA" src="../../en/files/Logo-big.png" /></a></div><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="ru">Модули/Serial</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="ru"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Modules%2FSerial&amp;action=page&amp;filter=&amp;language=ru" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Modules/Serial" title="Modules/Serial">Modules/Serial</a> and the translation is 100% complete.</div><hr /><div class="mw-pt-languages" dir="ltr" lang="en"><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="../../en/Modules/Serial.html" title="Modules/Serial (100% translated)">English</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">российский</span>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--complete" href="../../uk/Modules/Serial.html" title="Модулі/Serial (100% translated)">українська</a></div></div>
<table class="wikitable">

<tr>
<th> Модуль </th>
<th> Имя </th>
<th> Версия </th>
<th> Лицензия </th>
<th> Источник </th>
<th> Языки </th>
<th> Платформы </th>
<th> Тип </th>
<th> Автор </th>
<th> Описание
</th></tr>

<tr>
<td> <a href="../Modules/Serial.html" title="Special:MyLanguage/Modules/Serial">Serial</a> </td>
<td> Последовательные интерфейсы
</td>
<td> 2.4 </td>
<td> GPL2 </td>
<td> tr_Serial.so </td>
<td> en,uk,ru,de </td>
<td> x86,x86_64,ARM
</td>
<td> Транспорт </td>
<td> Роман Савоченко<br />&nbsp;&nbsp;<font size="-2"><i>Максим Кочетков (2016)</i></font> </td>
<td> Предоставляет транспорт основанный на последовательных интерфейсах. Используется для обмена данными через последовательные интерфейсы типа RS232, RS485, GSM и похожие.
<ul><li> <b>Сделать (To Do):</b></li></ul>
<dl><dd> - проверить режим модема и добавить к нему поле ввода PIN.</dd></dl>
</td></tr></table>
<p>Модуль предоставляет в программу поддержку транспортов, основанных на последовательных интерфейсах типа RS232, RS485, GSM и похожие. Поддерживаются входные и выходные транспорты. Добавить новые входные и выходные интерфейсы можно посредством конфигурации транспортной подсистемы в любом конфигураторе OpenSCADA.
</p><p>Модулем, в режиме модема, поддерживается смешанный режим работы, который предусматривает наличие входного транспорта, ожидающего внешних подключений, а также выходного транспорта на том-же устройстве. Т.е. входной транспорт будет игнорировать все запросы при наличии установленного выходным транспортом соединения, в тоже время выходной транспорт не будет осуществлять попыток установить соединение при наличии подключения к входному транспорту или соединения другого выходного транспорта, например, с другим номером телефона.
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../../en/files/At.png" width="22" /></a> В обычном режиме последовательного интерфейса не допускается многократное использование одного и того-же порта во входных и выходных транспортах. Глобальное блокирование последовательного устройства не осуществляется в виду неоднозначности этого процесса на системном уровне, а многократное использование может привести к непредсказуемым и сложно-уловимым проблемам. При необходимости организации локального последовательного канала с парой связанных портов рекомендуется использование команды "<b>$ socat -d -d pty,raw,echo=0,perm=0666 pty,raw,echo=0,perm=0666</b>".
</p>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.D0.92.D1.85.D0.BE.D0.B4.D0.BD.D1.8B.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="tocnumber">1</span> <span class="toctext">Входные транспорты</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#.D0.92.D1.8B.D1.85.D0.BE.D0.B4.D0.BD.D1.8B.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="tocnumber">2</span> <span class="toctext">Выходные транспорты</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#API_.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">3</span> <span class="toctext">API пользовательского программирования</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#.D0.97.D0.B0.D0.BC.D0.B5.D1.87.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">4</span> <span class="toctext"><span>Замечания</span></span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#.D0.92.D0.B8.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5.2F.D0.BB.D0.BE.D0.BA.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D1.8B"><span class="tocnumber">4.1</span> <span class="toctext">Виртуальные/локальные последовательные интерфейсы</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#.D0.9F.D1.80.D0.BE.D0.B1.D1.80.D0.BE.D1.81_.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.B0_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_.D1.81.D0.B5.D1.82.D1.8C_Ethernet"><span class="tocnumber">4.2</span> <span class="toctext">Проброс последовательного интерфейса через сеть Ethernet</span></a></li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id=".D0.92.D1.85.D0.BE.D0.B4.D0.BD.D1.8B.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="mw-headline-number">1</span> Входные транспорты</span></h2>
<p>Сконфигурированный и запущенный входной транспорт открывает порт последовательного интерфейса для ожидания запросов клиентов. Каждый входной интерфейс обязательно связывается с одним из доступных транспортных протоколов, к которому передаются входные сообщения.
</p><p>Диалог конфигурации входного последовательного интерфейса изображён на рисунок 1.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:653px;"><a class="image" href="http://oscada.org/wiki/File:Serial_in_ru.png"><img class="thumbimage" height="597" src="../files/Serial_in_ru.png" width="651" /></a>  <div class="thumbcaption">Рис.1. Диалог конфигурации входного последовательного интерфейса.</div></div></div></div>
<p>С помощью этого диалога можно установить:
</p>
<ul><li> Состояние транспорта, а именно: "Статус", "Выполняется" и имя БД, содержащей конфигурацию.</li>
<li> Идентификатор, имя и описание транспорта.</li>
<li> Адрес интерфейса в формате строки: "<b>{dev}:{spd}:{format}[:{opts}[:{mdm}]]</b>", где:
<ul><li> <i>dev</i> — адрес последовательного устройства (/dev/ttyS0);</li>
<li> <i>spd</i> — скорость последовательного устройства из ряда: 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000 или 921600;</li>
<li> <i>format</i> — формат асинхронных данных "<b>{размер}{чётность}{стоп}</b>" (8N1, 7E1, 5O2, ...);</li>
<li> <i>opts</i> — различные параметры, в основном для управления потоком, разделённые символом ',':
<ul><li> "[-]h" — аппаратное (CRTSCTS);</li>
<li> "[-]s" — программное (IXON|IXOFF);</li>
<li> "rts" — использование RTS сигнала для передачи(false) и проверки на эхо, для сырого RS-485;</li>
<li> "rts1" — использование RTS сигнала для передачи(true) и проверки на эхо, для сырого RS-485;</li>
<li> "rtsne" — использование RTS сигнала для передачи(false) без проверки на эхо, для сырого RS-485;</li>
<li> "rts1ne" — использование RTS сигнала для передачи(true) без проверки на эхо, для сырого RS-485;     </li>
<li> "[-]RS485" — использовать RS-485 режим, посредством TIOCSRS485.</li></ul></li>
<li> <i>mdm</i> — режим модема, ожидание 'RING'.</li></ul></li>
<li> Выбор транспортных протоколов.</li>
<li> Состояние "Выполняется", в которое переводить транспорт при загрузке.</li>
<li> Временные интервалы интерфейса в формате строки: "<b>{symbol}:{frm}[::{rtsDelay1}:{rtsDelay2}]</b>", где:
<ul><li> <i>symbol</i> — время символа в миллисекундах, используется для контроля факта окончания фрейма;</li>
<li> <i>frm</i> — максимальное время фрейма в миллисекундах, используется для ограничение максимального размера пакета запроса — фрейма;</li>
<li> <i>rtsDelay1</i> — задержка между включением передатчика сигналом RTS и началом передачи, в миллисекундах;</li>
<li> <i>rtsDelay2</i> — задержка между окончанием передачи и отключением передатчика сигналом RTS, в миллисекундах.</li></ul></li>
<li> Приоритет задачи входного потока.</li></ul>
<p>Транспорт поддерживает возможность работы в режиме модема. Данный режим включается пятым параметром адреса и подразумевает ожидания звонка от удалённого модема (запрос "RING"), ответа на звонок (команда "ATA") и последующей передачи запросов от удалённой станции к транспортному протоколу. Отключение сеанса связи осуществляется инициатором соединения и приводит к переподключению модема приёмника на ожидание новых звонков.
</p><p>Для настройки модема входного транспорта предусмотрена специальная вкладка "Модем" (рис.2).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:710px;"><a class="image" href="http://oscada.org/wiki/File:Serial_in_mod_ru.png"><img class="thumbimage" height="461" src="../files/Serial_in_mod_ru.png" width="708" /></a>  <div class="thumbcaption">Рис.2. Вкладка "Модем" конфигурации модема входного последовательного интерфейса.</div></div></div></div>
<p>С помощью этого диалога можно установить следующие свойства работы с модемом:
</p>
<ul><li> Время ожидания (таймаут) модема на запросы, в секундах.</li>
<li> Выдержка времени перед инициализацией модема, в секундах.</li>
<li> Выдержка времени после инициализации модема, в секундах.</li>
<li> Первая строка инициализации (обычно содержит команду сброса настроек модема "ATZ").</li>
<li> Вторая строка инициализации.</li>
<li> Строка результата инициализации модема (обычно "OK"), которой отвечает модем на инициализацию и которую нужно ожидать.</li>
<li> Запрос звонка (обычно "RING"), который шлёт модем в случае поступления исходящего вызова.</li>
<li> Ответ на звонок (обычно "ATA"), который отправляется модему для ответа на звонок.</li>
<li> Строка результата на ответ на звонок (обычно "CONNECT"), которой отвечает модем на команду ответа и которую нужно ожидать.</li></ul>
<h2><span class="mw-headline" id=".D0.92.D1.8B.D1.85.D0.BE.D0.B4.D0.BD.D1.8B.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="mw-headline-number">2</span> Выходные транспорты</span></h2>
<p>Сконфигурированный и исполняющийся выходной транспорт открывает порт последовательного интерфейса для отправки запросов через него.
</p><p>Главная вкладка страницы конфигурации выходного последовательного интерфейса изображёна на рисунке 3.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:710px;"><a class="image" href="http://oscada.org/wiki/File:Serial_out_ru.png"><img class="thumbimage" height="560" src="../files/Serial_out_ru.png" width="708" /></a>  <div class="thumbcaption">Рис.3. Главная вкладка страницы конфигурации выходного последовательного интерфейса.</div></div></div></div>
<p>С помощью этого диалога можно установить:
</p>
<ul><li> Состояние транспорта, а именно: "Статус", "Исполняется" и имя БД, содержащей конфигурацию.</li>
<li> Идентификатор, имя и описание транспорта.</li>
<li> Адрес интерфейса в формате строки: "<b>{dev}:{spd}:{format}[:{opts}[:{modTel}]]</b>", где:
<ul><li> <i>dev</i> — адрес последовательного устройства (/dev/ttyS0);</li>
<li> <i>spd</i> — скорость последовательного устройства из ряда: 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000 или 921600;</li>
<li> <i>format</i> — формат асинхронных данных "<b>{размер}{чётность}{стоп}</b>" (8N1, 7E1, 5O2, ...);</li>
<li> <i>opts</i> — различные параметры, в основном для управления потоком, разделённые символом ',':
<ul><li> "[-]h" — аппаратное (CRTSCTS);</li>
<li> "[-]s" — программное (IXON|IXOFF);</li>
<li> "rts" — использование RTS сигнала для передачи(false) и проверки на эхо, для сырого RS-485;</li>
<li> "rts1" — использование RTS сигнала для передачи(true) и проверки на эхо, для сырого RS-485;</li>
<li> "rtsne" — использование RTS сигнала для передачи(false) без проверки на эхо, для сырого RS-485;</li>
<li> "rts1ne" — использование RTS сигнала для передачи(true) без проверки на эхо, для сырого RS-485;</li>
<li> "[-]RS485" — использовать RS-485 режим, посредством TIOCSRS485.</li></ul></li>
<li> <i>modTel</i> — телефон модема, присутствие этого поля переключает транспорт на работу в режиме модема.</li></ul></li>
<li> Состояние "Исполняется", в которое переводить транспорт при загрузке.</li>
<li> Временные интервалы интерфейса в формате строки: "<b>{conn}:{symbol}[-{NextReqMult}][:{KeepAliveTm}[:{rtsDelay1}:{rtsDelay2}]]</b>", где:
<ul><li> <i>conn</i> — максимальное время ожидания ответа подключения, в миллисекундах — т.е. ответа от удалённого устройства;</li>
<li> <i>symbol</i> — максимальное время одного символа, используется для обнаружения окончания фрейма и таймаута следующего запроса, в миллисекундах;</li>
<li> <i>NextReqMult</i> — множитель времени следующего запроса к времени символа <i>symbol</i>, 4 по умолчанию;</li>
<li> <i>KeepAliveTm</i> — таймаут жизни для перезапуска транспорта, в секундах; используйте значение &lt; 0 для останова транспорта после отсутствия ответа на любой запрос;</li>
<li> <i>rtsDelay1</i> — задержка между включением передатчика сигналом RTS и началом передачи, в миллисекундах;</li>
<li> <i>rtsDelay2</i> — задержка между окончанием передачи и отключением передатчика сигналом RTS, в миллисекундах.</li></ul></li>
<li> Не останавливать при обработке. Иногда закрытие открытого устройства может быть разрушительным, например, на ПЛК LP от ICP-DAS, и Вы можете предотвратить это данной опцией.</li></ul>
<p>Транспорт поддерживает возможность работы в режиме модема. Данный режим включается наличием пятого параметра адреса и подразумевает осуществление звонка по телефону, указанному этим параметром, в момент запуска транспорта. После установки связи с удалённым модемом все запросы передачи направляются станции за удалённым модемом. Отключение сеанса связи, с остановкой транспорта, осуществляется по таймауту активности.
</p><p>Для настройки модема выходного транспорта предусмотрена специальная вкладка "Модем" (рис.4).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:710px;"><a class="image" href="http://oscada.org/wiki/File:Serial_out_mod_ru.png"><img class="thumbimage" height="621" src="../files/Serial_out_mod_ru.png" width="708" /></a>  <div class="thumbcaption">Рис.4. Вкладка "Модем" конфигурации модема выходного последовательного интерфейса.</div></div></div></div>
<p>С помощью этого диалога можно установить следующие свойства работы с модемом:
</p>
<ul><li> Время ожидания (таймаут) модема на запросы, в секундах.</li>
<li> Время жизни соединения, в секундах. Если в течении этого времени будет отсутствовать передача данных через транспорт, то соединение будет разорвано.</li>
<li> Выдержка времени перед инициализацией модема, в секундах.</li>
<li> Выдержка времени после инициализации модема, в секундах.</li>
<li> Первая строка инициализации (обычно содержит команду сброса настроек модема "ATZ").</li>
<li> Вторая строка инициализации.</li>
<li> Строка результата инициализации модема (обычно "OK"), которой отвечает модем на инициализацию и которую нужно ожидать.</li>
<li> Строка дозвона к удалённому модему (обычно "ATDT"). При дозвоне номер телефона добавляется к данному префиксу.</li>
<li> Строка результата удачного соединения (обычно "CONNECT").</li>
<li> Строка результата занятости линии (обычно "BUSY").</li>
<li> Строка результата отсутствия несущей в линии (обычно "NO CARRIER").</li>
<li> Строка результата отсутствия гудка линии (обычно "NO DIALTONE").</li>
<li> Строка выхода из режима данных (обычно "+++") и используется "Время перед инициализацией модема", после неё.</li>
<li> Команда повесить трубку (обычно "+++ATH"). Данная команда вызывается всегда, когда нужно разорвать соединение.</li>
<li> Строка результата команды повесить трубку (обычно "OK"), которой отвечает модем на команду и которую нужно ожидать.</li></ul>
<p>Транспорт может работать с аппаратной шиной I2С, если в качестве устройства выбрать "/dev/i2c-{N}" и шина позволит установить адрес подчинённого устройства командой I2C_SLAVE, из <b>первого байта запроса</b>. Скорость и формат не играют роли в данном режиме. Из таймаутов тут фактически работает только время символа и в основном для расчёта ожидания повтора запроса.
</p>
<h2><span class="mw-headline" id="API_.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"><span class="mw-headline-number">3</span> API пользовательского программирования</span></h2>
<p><b>Объект "Выходной транспорт" (SYS.Transport.Serial.out_{OutTransport})</b>
</p>
<ul><li> <i>bool TS( bool rts = EVAL )</i> — управляет отправкой, посредством установки запроса <i>rts</i>, и возвращает состояние разрешения CTS.</li>
<li> <i>bool DR( bool dtr = EVAL )</i> — управляет готовностью устройства, посредством установки готовности терминала <i>dtr</i>, и возвращает состояние готовности DSR.</li>
<li> <i>bool DCD()</i> — состояние обнаружения несущей данных.</li>
<li> <i>bool RI()</i> — индикатор звонка.</li>
<li> <i>int sendbreak( int duration = 0 )</i> — отправляет в поток прерывание нулями в течении <i>duration</i> (0 — некоторый интервал по умолчанию).</li></ul>
<h2><span class="mw-headline" id=".D0.97.D0.B0.D0.BC.D0.B5.D1.87.D0.B0.D0.BD.D0.B8.D1.8F"><span class="mw-headline-number">4</span> <span id="Notes" title="#Notes">Замечания</span></span></h2>
<p>Коммуникации через последовательные интерфейсы имеют ряд особенностей. Наиболее важной особенностью является критерий окончания сообщения и время ожидания этого критерия. В одних протоколах таким критерием является признак окончания или указанный размер сообщения. В других протоколах таким критерием является отсутствие данных во входном потоке в течение указанного времени — время символа. В обоих случаях время ожидания критерия, или символа, является ключевым и сильно сказывается на общем времени обмена. Следовательно, чем меньше это время тем лучше. Тут и возникает проблема латентности оборудования и его драйверов.
</p><p>Проверить латентность канала обмена, и тем самым оптимально настроить время дожидания-символа, можно с помощью интерфейса вкладки "Запрос" выходного транспорта. Для этого необходимо указать образцовый запрос соответствующего протокола, указать "Ожидать таймаут", отослать запрос и проконтролировать его целостность. Для получения более репрезентативного результата необходимо запрос повторить несколько раз. Если наблюдается получение неполных ответов, то время символа необходимо увеличить, иначе можно уменьшить.
</p><p>На встроенном оборудовании последовательных интерфейсов RS232/422/485 можно добиться низкого уровня латентности — вплоть до единиц миллисекунд. Однако, на высоко-нагруженных системах с множеством задач в приоритете реального времени, латентность может стать недетерминированной, в связи с исполнением потока обслуживания событий ядра Linux в низком приоритете. Для решения этой проблемы необходимо установить высокий приоритет этим потокам, что можно сделать с помощью скрипта, поместив его, например, в "/etc/rc.local":
</p>
<pre style="white-space: pre-wrap;">
#!/bin/sh

# Setting the high priority for events kernel threads to rise the serial interfaces reaction
events=`ps -Ao pid,comm | sed -n '/[ ]*\([^ ]\)[ ]*events\/[0-9]/s//\1/p'`
for ie in $events; do
  chrt -pr 21 $ie
done
</pre>
<p>Этот скрипт не имеет смысла для ядер Linux реального времени, с патчем PREEMPT_RT, поскольку все потоки прерываний и событий там уже запускаются в приоритете реального времени.
</p><p>На внешнем оборудовании последовательных интерфейсов, например, в переходниках USB-&gt;RS232/422/485, может возникнуть проблема высокой латентности, связанная с особенностью аппаратной реализации или его драйвера. Решать эту проблему нужно путём изучения настроек этого оборудования или установкой большого времени ожидания- символа!
</p><p>Похожим образом определяется и оптимальное время подключения, а именно: установить время подключения в значение по умолчанию для данной скорости (ставится при смене скорости в адресе), снять "Ожидать таймаут", отослать запрос. Если ответ пришёл то берём измеренное время отклика устройства, удваиваем и устанавливаем полученное значение, как время подключения. Необоснованное превышение времени подключения приведёт к большим ожиданиям в случае отсутствия устройства, а также срабатывания защитных таймаутов внутренних процедур!
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../../en/files/At.png" width="22" /></a> На рынке встречаются USB-&gt;Serial преобразователи, которые работают только с терминалами, т.е. они могут передавать и обрабатывать исключительно ASCII символы и не могут быть переключены в бинарный режим. Известные экземпляры таких преобразователей: PL2303TA (Y-105).
</p>
<h3><span class="mw-headline" id=".D0.92.D0.B8.D1.80.D1.82.D1.83.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5.2F.D0.BB.D0.BE.D0.BA.D0.B0.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D1.8B.D0.B5_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D1.8B"><span class="mw-headline-number">4.1</span> Виртуальные/локальные последовательные интерфейсы</span></h3>
<p>Часто для локальной проверки, без физического оборудования, необходима пара портов подключенных в одну сеть. Создание таких портов и выполнение множества других операций над последовательным потоком позволяет выполнять утилита <b>socat</b>. Например, для создания двух связанных портов нужно выполнить команду, которая создаст их и сообщит адреса:
</p>
<pre style="white-space: pre-wrap;">
$ socat -d -d pty,raw,echo=0,perm=0666 pty,raw,echo=0,perm=0666
2013/07/02 16:37:29 socat[10402] N PTY is /dev/pts/6
2013/07/02 16:37:30 socat[10402] N PTY is /dev/pts/7
2013/07/02 16:37:30 socat[10402] N starting data transfer loop with FDs [3,3] and [5,5]
</pre>
<h3><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D0.B1.D1.80.D0.BE.D1.81_.D0.BF.D0.BE.D1.81.D0.BB.D0.B5.D0.B4.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D0.BD.D0.BE.D0.B3.D0.BE_.D0.B8.D0.BD.D1.82.D0.B5.D1.80.D1.84.D0.B5.D0.B9.D1.81.D0.B0_.D1.87.D0.B5.D1.80.D0.B5.D0.B7_.D1.81.D0.B5.D1.82.D1.8C_Ethernet"><span class="mw-headline-number">4.2</span> Проброс последовательного интерфейса через сеть Ethernet</span></h3>
<p>В некоторых случаях бывает полезным пробросить порт последовательного интерфейса удалённой машины на локальный порт, например, для опроса устройств, подключенных к последовательному интерфейсу удалённой машины. Конечно, если установить на удалённую машину OpenSCADA в конфигурации ПЛК, то можно будет сразу выполнять обработку этих данных, предварительное буферирование/архивирование и т.д., но иногда оборудование может быть сложным для запуска OpenSCADA, где и спасает возможность проброса последовательного потока через сеть. Для решения этой задачи можно воспользоваться той-же утилитой <b>socat</b> или <b>remserial</b>, <b>ser2net</b>, какую удастся собрать и запустить на удалённой машине. Примеры проброса последовательного порта:
</p>
<pre style="white-space: pre-wrap;">
# Создание сокета на порту 5555 удалённой машине, для порта /dev/ttyS0
$ socat tcp-l:5555,reuseaddr,fork file:/dev/ttyS0,raw
# Подключение к сокету отражённого порта удалённой машины и формирование файла отражённого локального интерфейса
$ socat -d -d pty,raw,echo=0,perm=0666 tcp:192.168.2.4:5555,mss=1400
2013/07/04 10:09:09 socat[12947] N PTY is /dev/pts/4
2013/07/04 10:09:09 socat[12947] N opening connection to AF=2 192.168.2.4:5555
2013/07/04 10:09:09 socat[12947] N successfully connected from local address AF=2 192.168.2.61:33493
2013/07/04 10:09:09 socat[12947] N starting data transfer loop with FDs [3,3] and [5,5]
</pre>
<p>В случае с "socat", а возможно и других утилит, можно на клиентской стороне опустить запуск драйвера EthernetTCP-&gt;Serial и подключаться из OpenSCADA прямо на TCP-порт удалённого устройства.
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../../en/files/At.png" width="22" /></a> В работе через драйвер EthernetTCP-&gt;Serial есть особенность, которая связанна с наличием двух таймаутов подключения: один в драйвере, а другой в <a href="../Modules/Sockets.html" title="Special:MyLanguage/Modules/Sockets">Transport.Sockets</a>. Важно чтобы значение этого таймаута в <a href="../Modules/Sockets.html" title="Special:MyLanguage/Modules/Sockets">Transport.Sockets</a> был больше чем в драйвере иначе возможно смещение и получение запоздалых ответов от предыдущих запросов.
</p><p>Многие производители промышленного коммуникационного оборудования выпускают готовые конвертеры из Ethernet в RS-232/422/485, которые могут использоваться с OpenSCADA таким-же образом. Комментарии и перечень конвертеров с которыми работа OpenSCADA проверена:
</p>
<ul><li> <a class="external text" href="http://www.icpdas.com" rel="nofollow noreferrer noopener" target="_blank">ICP DAS</a>: <a class="external text" href="http://www.icpdas.com/products/Industrial/pds/tds-700.htm" rel="nofollow noreferrer noopener" target="_blank">tDS-7xx</a> — настраивается через WEB-интерфейс и работает по прямому подключение к TCP-порту;</li>
<li> <a class="external text" href="http://tibbo.com" rel="nofollow noreferrer noopener" target="_blank">Tibbo</a>: <a class="external text" href="http://tibbo.com/products/controllers/ds100.html" rel="nofollow noreferrer noopener" target="_blank">DS100</a> — <span style="color: red">настраивается только через программу для MS Windows®</span>, предоставляет собственный драйвер для формирования виртуальных последовательных интерфейсов на Linux, работает по прямому подключение к TCP-порту.</li></ul>






</div><table style="border-top: dotted 2px #999999; margin-top: 20pt; color: gray;" width="100%"><tr><td style="text-align: left;" width="40%"><a href="http://oscada.org/wiki/Modules/Serial/ru">Modules/Serial/ru</a> - <a href="http://oscada.org/en/main/about-the-project/licenses/">GFDL</a></td><td style="text-align: center;">August 2020</td><td style="text-align: right;" width="40%">OpenSCADA 1+r2700</td></tr></table></body>
</html>