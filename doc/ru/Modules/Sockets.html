<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<title>Модули/Sockets - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../files/doc.css" rel="stylesheet" /></head>
<body><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="ru">Модули/Sockets</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="ru"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Modules%2FSockets&amp;action=page&amp;filter=&amp;language=ru" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Modules/Sockets" title="Modules/Sockets">Modules/Sockets</a> and the translation is 100% complete.</div><hr /><div class="mw-pt-languages noprint" dir="ltr" lang="en"><div class="mw-pt-languages-label">Other languages:</div><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="http://oscada.org/wiki/Modules/Sockets" title="Modules/Sockets (100% translated)">English</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">российский</span>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--complete" href="http://oscada.org/wiki/Modules/Sockets/uk" title="Модулі/Sockets (100% translated)">українська</a></div></div>
<div class="noprint" style="float:right; border:1px solid gray; width:300px; background-color:ivory; padding:2px;">
<table cellspacing="0">
<tr>
<td> <a class="image" href="http://oscada.org/wiki/File:Constr.png"><img alt="Constr.png" height="32" src="../files/Constr.png" width="32" /></a>
</td>
<td style="padding-left:5px;"> The translation checking and actualizing
</td></tr></table>
</div>
<table class="wikitable">

<tr>
<th> Модуль </th>
<th> Имя </th>
<th> Версия </th>
<th> Лицензия </th>
<th> Источник </th>
<th> Языки </th>
<th> Платформы </th>
<th> Тип </th>
<th> Автор </th>
<th> Описание
</th></tr>

<tr>
<td> <a href="../Modules/Sockets.html" title="Special:MyLanguage/Modules/Sockets">Sockets</a> </td>
<td> Сокеты </td>
<td> 2.3 </td>
<td> GPL2 </td>
<td> tr_Sockets.so </td>
<td> en,uk,ru,de </td>
<td> x86,x86_64,ARM
</td>
<td> Транспорт </td>
<td> Роман Савоченко, Максим Кочетков </td>
<td> Предоставляет транспорт основанный на сокетах. Поддерживаются интернет и UNIX сокеты. Интернет сокет использует TCP, UDP и RAWCAN протоколы.
</td></tr></table>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.D0.92.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B8.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="tocnumber">1</span> <span class="toctext">Входящие транспорты</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#.D0.98.D1.81.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B8.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="tocnumber">2</span> <span class="toctext">Исходящие транспорты</span></a></li>
</ul>
</div>

<p>Модуль транспорта Sockets предоставляет в систему поддержку транспортов, основанных на сокетах. Поддерживаются входящие и исходящие транспорты, основанные на интернет сокетах: TCP, UDP и UNIX. Добавить новые входящие и исходящие сокеты можно посредством конфигурации транспортной подсистемы в любом конфигураторе системы OpenSCADA.
</p>
<h2><span class="mw-headline" id=".D0.92.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B8.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="mw-headline-number">1</span> Входящие транспорты</span></h2>
<p>Сконфигурированный и запущенный входящий транспорт открывает серверный сокет для ожидания соединения клиентов, кроме инициативного подключения. В случае с UNIX сокетом создаётся файл UNIX сокета. Сокеты TCP и UNIX являются многопоточными, т.е. при подключении клиента к сокетам данных типов создаётся клиентский сокет и новый поток, в котором производиться обслуживание клиента. Серверный сокет в этот момент переходит к ожиданию запросов от нового клиента. Таким образом достигается параллельное обслуживание клиентов. RAWCAN сокет осуществляет прием CAN кадров из интерфейса согласно настроенному фильтру.
</p><p>Каждый входящий сокет связывается с одним из доступных транспортных протоколов, которому передаются входящие сообщения. В связке с транспортным протоколом поддерживается механизм объединения кусков разрозненных при передаче запросов.
</p><p>Диалог конфигурации входящего сокета изображён на рисунок 1.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:944px;"><a class="image" href="http://oscada.org/wiki/File:Sockets_in_ru.png"><img class="thumbimage" height="717" src="../files/Sockets_in_ru.png" width="942" /></a>  <div class="thumbcaption">Рис.1. Диалог конфигурации входящего сокета.</div></div></div></div>
<p>С помощью этого диалога можно установить:
</p>
<ul><li> Состояние транспорта, а именно: "Статус", "Запущен", имя БД (содержащей конфигурацию) и список с информацией о текущих подключениях.</li>
<li> Идентификатор, имя и описание транспорта.</li>
<li> Адрес транспорта. Формат адреса описан в таблице ниже.</li>
<li> Выбор транспортного протокола.</li></ul>
<dl><dd><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../files/At.png" width="22" /></a> Пустое значение выбора протокола переключает транспорт в режим создания ассоциированного исходящего транспорта для каждого подключения на данный входящий.</dd>
<dd>Режим ассоциированных исходящих транспортов для входящего предусматривает наличие некоей внешней для транспорта процедуры, выполняющей роль протокола, которая должна "обходить" все ассоциированные исходящие транспорты, и выполнять запросы на чтение или запись-чтение.</dd>
<dd><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../files/At.png" width="22" /></a> Отсутствие такой процедуры неизбежно приведёт к росту ассоциированных исходящих транспортов в виду отсутствия сущности останавливающей транспорты с закрытыми соединениями и возможности последующего удаления остановленных исходящих транспортов данным входящим транспортом.</dd></dl>
<ul><li> Состояние, в которое переводить транспорт при загрузке: "Запускать".</li>
<li> Длина очереди сокетов, максимальное количество обслуживаемых клиентов, максимальное количество обслуживаемых клиентов по хостам (для TCP) и размер входного буфера.</li>
<li> Приоритет задач транспорта.</li>
<li> Максимальный размер сегмента (MSS), для ограничения размера отправляемых пакетов (сегментов TCP) на плохих каналах связи. Установить в 0 для снятия пользовательского ограничения размера.</li>
<li> Keep alive запросов. Закрытие подключения после указанного количества запросов. Нулевое значение для отключения (не закрывается никогда).</li>
<li> Keep alive время ожидания (сек.). Закрытие подключения после отсутствия запросов в течении указанного времени. Нулевое значение для отключения (не закрывается никогда). </li></ul>
<dl><dd><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../files/At.png" width="22" /></a> Отключать данную функцию не рекомендуется поскольку свойство сетей TCP/IP не гарантирует уведомления сервера об отключении соединения, скажем в случае пропадания питания на клиенте. В результате чего могут <span style="color: red">навсегда</span> оставаться открытые клиентские подключения, а при достижении лимита сервер перестанет принимать новые!</dd></dl>
<p>Особенности формирования адресов входящих сокетов приведены в таблице ниже:
</p>
<table class="wikitable">

<tr>
<th> Тип сокета </th>
<th> Адрес
</th></tr>
<tr>
<td>TCP</td>
<td>
<p><i>TCP:{адрес}:{порт}:{режим}</i><br />
где:
</p>
<ul><li> адрес — Адрес, на котором открывается сокет. Должен быть одним из адресов хоста. Если ничего не указано, то сокет будет доступен на всех интерфейсах хоста. Допускаются как символьное, так и IP представление адреса.</li>
<li> порт — Сетевой порт, на котором открывается сокет. Возможно указание символьного имени порта (в соответствии с /etc/services).</li>
<li> режим — режим работы входящего сокета:
<ul><li> '0' — Принудительно разрывать соединение после сеанса приём-ответ.</li>
<li> '1' — Не разрывать соединение, только с учётом параметров KeepAlive.</li>
<li> '2' — Инициативное подключение. Включает режим инициативы подключения данного входного транспорта к удалённому хосту (адрес вместо локального) и переход в режим ожидания запросов от этого хоста. Значение "Keep alive время ожидания (сек.)" используется как таймаут переподключения данного транспорта по отсутствию активности, с целью восстановления возможно потерянного подключения.</li></ul></li></ul>
<p>Пример: "<i>TCP::10001:1</i>" — TCP-сокет доступен на всех интерфейсах, открыт на порту 10001 и соединения не разрывает.
</p>
</td></tr>
<tr>
<td>UDP</td>
<td>
<p><i>UDP:{адрес}:{порт}</i><br />
где:
</p>
<ul><li> адрес — тоже что в TCP;</li>
<li> порт — тоже что в TCP.</li></ul>
<p>Пример: "<i>UDP:localhost:10001</i>" — UDP-сокет доступен только на интерфейсе "localhost" и открыт на порту 10001.
</p>
</td></tr>
<tr>
<td>RAWCAN</td>
<td>
<p><i>RAWCAN:{интерфейс}:{маска}:{идентификатор}</i><br />
где:
</p>
<ul><li> интерфейс — имя CAN интерфейса;</li>
<li> маска, идентификатор — маска и идентификатор для фильтрации CAN кадров.</li></ul>
<p>Пример: "<i>RAWCAN:can0:0:0</i>" — принимать все CAN кадры на интерфейсе can0.
Идентификатор CAN фрейма помещается в поле sender, данные - в request, длина поля данных — request.length. Признаком расширенного идентификатора является наличие старшего бита в идентификаторе (0x80000000) 
</p>
</td></tr>
<tr>
<td>UNIX</td>
<td>
<p><i>UNIX:{имя}:{режим}</i><br />
где:
</p>
<ul><li> имя — имя файла UNIX сокета;</li>
<li> режим — тоже что в TCP.</li></ul>
<p>Пример: "<i>UNIX:/tmp/oscada:1</i>" — UNIX-сокет доступен через файл "/tmp/oscada" и соединения не разрывает.
</p>
</td></tr></table>
<h2><span class="mw-headline" id=".D0.98.D1.81.D1.85.D0.BE.D0.B4.D1.8F.D1.89.D0.B8.D0.B5_.D1.82.D1.80.D0.B0.D0.BD.D1.81.D0.BF.D0.BE.D1.80.D1.82.D1.8B"><span class="mw-headline-number">2</span> Исходящие транспорты</span></h2>
<p>Сконфигурированный и запущенный исходящий транспорт открывает соединение с указанным сервером. При разрыве соединения исходящий транспорт отключается. Для возобновления соединения транспорт нужно снова запустить.
</p><p>Главная вкладка страницы конфигурации исходящего сокета изображёна на рис.2.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:697px;"><a class="image" href="http://oscada.org/wiki/File:Sockets_out_ru.png"><img class="thumbimage" height="540" src="../files/Sockets_out_ru.png" width="695" /></a>  <div class="thumbcaption">Рис.2. Главная вкладка страницы конфигурации исходящего сокета.</div></div></div></div>
<p>С помощью этого диалога можно установить:
</p>
<ul><li> Состояние транспорта, а именно: "Статус", "Запущен" и имя БД, содержащей конфигурацию.</li>
<li> Идентификатор, имя и описание транспорта.</li>
<li> Адрес транспорта. Формат адреса описан в таблице ниже.</li>
<li> Состояние, в которое переводить транспорт при загрузке: "Запускать".</li>
<li> Максимальный размер сегмента (MSS), для ограничения размера отправляемых пакетов (сегментов TCP) на плохих каналах связи. Установить в 0 для снятия пользовательского ограничения размера.</li>
<li> Временные интервалы соединения в формате: "<b>conn:next[:rep]</b>". Где:
<ul><li> <i>conn</i> — максимальное время ожидания ответа соединения, в секундах;</li>
<li> <i>next</i> — максимальное время ожидания продолжения ответа, в секундах;</li>
<li> <i>rep</i>  — минимальный таймаут ожидания повтора запроса, в секундах.</li></ul></li></ul>
<p>Адреса исходящих сокетов различного типа формируются следующим образом:
</p>
<table class="wikitable">

<tr>
<th> Тип сокета </th>
<th> Адрес
</th></tr>
<tr>
<td> TCP/UDP</td>
<td>
<p><i>TCP:{адрес}:{порт}</i><br />
<i>UDP:{адрес}:{порт}</i><br />
где:
</p>
<ul><li> адрес — Адрес, с которым выполняется соединение. Допускаются как символьное так и IP представление адреса.</li>
<li> порт — Сетевой порт, с которым выполняется соединение. Возможно указание символьного имени порта (в соответствии с /etc/services).</li></ul>
<p>Пример: "<i>TCP:127.0.0.1:7634</i>" — соединится с портом 7634 на хосте 127.0.0.1.
</p>
</td></tr>
<tr>
<td>RAWCAN</td>
<td>
<p><i>RAWCAN:{интерфейс}:{маска}:{идентификатор}</i><br />
где:
</p>
<ul><li> интерфейс — имя CAN интерфейса;</li>
<li> маска, идентификатор — маска и идентификатор CAN кадров.</li></ul>
<p>Пример: "<i>RAWCAN:can0:0:0</i>" — принимать все CAN кадры на интерфейсе can0.
Отправка CAN фреймов в транспорт осуществляется в виде структуры struct can_frame. Размер структуры - 16 байт. 4 байта - идентификатор, 4 байта длина, 8 байт данные.
</p><p>Пример:<br />
15 CD 5B 07 08 00 00 00 11 12 13 14 15 16 17 18
</p><p>Идентификатор - 123456789 dec = 0x75BCD15 hex -&gt;15 CD 5B 07 (если нужен расширенный - 0x80 добавить в последнем байте)
длина - 08 00 00 00 восемь бай<br />
данные - 11 12 13 14 15 16 17 18 
</p>
</td></tr>
<tr>
<td>UNIX</td>
<td>
<p><i>UNIX:{имя}</i><br />
где:
</p>
<ul><li> имя — имя файла UNIX сокета.</li></ul>
<p>Пример: "<i>UNIX:/tmp/oscada</i>" — соединится с UNIX-сокетом через файл /tmp/oscada.
</p>
</td></tr></table>






</div></body>
</html>