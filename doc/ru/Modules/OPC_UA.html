<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="UTF-8" />
<title>Модули/OPC UA - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="../../en/files/doc.css" rel="stylesheet" /></head>
<body><div class="floatright"><a href="http://oscada.org"><img alt="OpenSCADA" src="../../en/files/Logo-big.png" /></a></div><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="ru">Модули/OPC UA</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="ru"><div class="mw-pt-translate-header noprint" dir="ltr" lang="en">This page is a <span class="plainlinks"><a class="external text" href="http://oscada.org/wiki/index.php?title=Special:Translate&amp;group=page-Modules%2FOPC+UA&amp;action=page&amp;filter=&amp;language=ru" rel="nofollow noreferrer noopener" target="_blank">translated version</a></span> of the page <a class="external" href="http://oscada.org/wiki/Modules/OPC_UA" title="Modules/OPC UA">Modules/OPC UA</a> and the translation is 100% complete.</div><hr /><div class="mw-pt-languages" dir="ltr" lang="en"><div class="mw-pt-languages-list autonym"><a class="mw-pt-languages-ui mw-pt-progress mw-pt-progress--complete" href="../../en/Modules/OPC_UA.html" title="Modules/OPC UA (100% translated)">English</a>&nbsp;• ‎<span class="mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">российский</span>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--complete" href="../../uk/Modules/OPC_UA.html" title="Модулі/OPC UA (100% translated)">українська</a></div></div>
<table class="wikitable">

<tr>
<th> Модуль </th>
<th> Имя </th>
<th> Версия </th>
<th> Лицензия </th>
<th> Источник </th>
<th> Языки </th>
<th> Платформы </th>
<th> Тип </th>
<th> Автор
</th></tr>

<tr>
<td> <a href="../Modules/OPC_UA.html" title="Special:MyLanguage/Modules/OPC UA">OPC_UA</a> </td>
<td> Клиент OPC-UA
</td>
<td> 2.5 </td>
<td> GPL2 </td>
<td> daq_OPC_UA.so </td>
<td> en,uk,ru,de </td>
<td> x86,x86_64,ARM
</td>
<td> Сбор Данных </td>
<td> Роман Савоченко
</td></tr>
<tr>
<th colspan="9"> Описание
</th></tr>
<tr>
<td colspan="9"> Предоставляет реализацию OPC-UA клиентского сервиса.
</td></tr>

<tr>
<td> <a href="../Modules/OPC_UA.html" title="Special:MyLanguage/Modules/OPC UA">OPC_UA</a> </td>
<td> Сервер OPC-UA
</td>
<td> 2.1 </td>
<td> GPL2 </td>
<td> daq_OPC_UA.so </td>
<td> en,uk,ru,de </td>
<td> x86,x86_64,ARM
</td>
<td> Протокол </td>
<td> Роман Савоченко
</td></tr>
<tr>
<th colspan="9"> Описание
</th></tr>
<tr>
<td colspan="9"> Предоставляет реализацию OPC-UA сервиса сервера.
</td></tr>

<tr>
<td> <a href="../Modules/OPC_UA.html" title="Special:MyLanguage/Modules/OPC UA">OPC_UA</a> </td>
<td> Библиотека реализации OPC-UA в OpenSCADA
</td>
<td> 2.1 </td>
<td> LGPL3 </td>
<td> libOPC_UA.{h,cpp} </td>
<td> en </td>
<td> x86,x86_64,ARM
</td>
<td> Библиотека </td>
<td> Роман Савоченко
</td></tr>
<tr>
<th colspan="9"> Описание
</th></tr>
<tr>
<td colspan="9"> Предоставляет реализацию протокола OPC-UA в части клиента и сервера, в виде отдельной библиотеки.
<ul><li> <b>Общая трудоёмкость:</b> &gt; 50 <span title="человеко-дней, 1ЧД — 10 часов">ЧД<sup style="color: blue">[!]</sup></span></li>
<li> <b>Спонсировано, 2 года ТП на 13 <span title="человеко-дней, 1ЧД — 10 часов">ЧД<sup style="color: blue">[!]</sup></span>:</b> Дмитрий Лыков, ООО Вектор</li>
<li> <b>Спонсировано, перенос кода протокола в LGPL библиотеку, значительное улучшение и документирование на 8.4 <span title="человеко-дней, 1ЧД — 10 часов">ЧД<sup style="color: blue">[!]</sup></span>:</b> Александр Леута, MYSCADA</li>
<li> <b>Спонсировано, работу с UAExpert 1.4 и kepware2 на 0.9 <span title="человеко-дней, 1ЧД — 10 часов">ЧД<sup style="color: blue">[!]</sup></span>:</b> Устьянцев Михаил</li>
<li> <b>Спонсировано, <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Documents/Release_0.9/Update4#OPC_UA" title="Special:MyLanguage/Documents/Release 0.9/Update4">работу с UAExpert 1.5, реализацию клиентского Publish и Chunks, значительную унификации</a>, поддержки Логического Уровня и полную ревизию документа на 10.4 <span title="человеко-дней, 1ЧД — 10 часов">ЧД<sup style="color: blue">[!]</sup></span>:</b> <a class="external" href="http://oscada.org/wiki/Special:MyLanguage/Fund" title="Special:MyLanguage/Fund">Фонд</a></li>
<li> <a class="external text" href="http://oscada.org/en/development/tasks/posts/subsystem_daq/module_opc_ua_functions_extending/" rel="nofollow noreferrer noopener" target="_blank">Задача расширения модуля</a></li>
<li> <b>Сделать (To Do):</b></li></ul>
<dl><dd> + отревизировать представительскую страницу документации;</dd>
<dd> - разрешить противоречие в <i>Client::messIO()</i> на предмет смешивания режима чистого запроса с режимом свободного чтения/записи и времени ожидания тут ответа без прямой передачи таймаута подключения;</dd>
<dd> + дополнить встроенным Логическим Режимом DAQ-Параметров;</dd>
<dd> - добавить поддержку аутентификации к входной-серверной части протокола;</dd>
<dd> - добавить автоматическое создание входных транспортов и их пре-конфигурацию из свойств объекта КонечногоУзла;</dd>
<dd> + реализовать запрос-сервис "Publish" и "куски" в клиентской части;</dd>
<dd> - глубоко пересмотреть сервис Publish на предмет потери пакетов и отправки запроса Republish;</dd>
<dd> - добавить поддержку сервиса истории серверной части, смотря и тестируя совместно с обменом UAExpert;</dd>
<dd> - добавить поддержку сервиса истории клиентской части.</dd></dl>
</td></tr></table>
<p>OPC (OLE for Process Control) — это семейство протоколов и технологий, предоставляющих единый интерфейс для управления объектами автоматизации и технологическими процессами. Создание и поддержку спецификаций OPC координирует международная некоммерческая организация <a class="external text" href="http://opcfoundation.org" rel="nofollow noreferrer noopener" target="_blank">OPC Foundation</a>, созданная в 1994 году ведущими производителями средств промышленной автоматизации.
</p><p>В виду того, что значительное влияние в организации OPC Foundation имеет корпорация Microsoft, протоколы OPC до последнего времени были одноплатформенными и закрытыми, по причине привязки к закрытым технологиям MS Windows. Однако, с недавних пор, организацией OPC Foundation были созданы такие многоплатформенные решения, как OPC XML-DA и OPC-UA. Наибольший интерес из них представляет OPC-UA, как унифицирующий все протоколы ранних версий в рамках открытых и многоплатформенных технологий. 
</p><p>Данный модуль реализует поддержку интерфейса и протокола OPC-UA как в виде клиентского сервиса, так и в виде сервера OPC-UA. Клиентский сервис OPC-UA реализуется одноимённым модулем подсистемы "Сбор данных", а сервер реализуется модулем подсистемы "Протоколы". Весь код реализации этим модулем специфики протокола OPC-UA был вынесен, по просьбе пользователей, в отдельную библиотеку, которая распространяется под лицензией LGPL3.
</p><p>Текущей версией данных модулей и библиотеки реализуются бинарная часть протокола и базовые сервисы в небезопасном режиме и безопасных режимах политик "Base128Rsa15" и "Base256". В последствии планируется реализация остальных сервисов OPC-UA, по потребности.
</p><p>Хотя протокол OPC-UA и является многоплатформенным, его спецификация и SDK не являются свободнодоступными, а предоставляются только членам организации OPC Foundation. По этой причине реализация данных модулей столкнулась со значительными препятствиями и проблемами.
</p><p>Во первых, протокол OPC-UA сложен и реализация его вообще без спецификации крайне трудоёмка. По этой причине работы над данными модулями долгое время не начиналась, и только благодаря спонсорской помощи одной из организаций-члена OPC Foundation, проект OpenSCADA получил документацию спецификации. При этом SDK и исходные тексты ANSIС-API протокола OPC-UA получены не были по причине несовместимости их лицензии с GPL и, как следствие, потенциальной угрозы нарушения лицензии при работе с исходными текстами, что могло привести к последующим юридическим проблемам при свободном распространении данных модулей.
</p><p>Во вторых, даже наличие спецификации не позволяет решить ряд технических вопросов без примеров реализации и возможности проверки на рабочем прототипе клиента и сервера OPC-UA. Например, именно технические особенности реализации алгоритмов симметричного шифрования и получения ключей для них не позволили реализовать поддержку политик безопасности сразу.
</p><p>Для отладки функционирования модулей использовалось демонстрационное ПО фирмы <a class="external text" href="http://www.unified-automation.com" rel="nofollow noreferrer noopener" target="_blank">Unified Automation</a>, в составе OPC-UA клиента — UAExpert и сервера — "OPC-UA Demo Server", из пакета SDK. В виду постоянного развития самого клиента "UAExpert", в плане интерпретации спецификации OPC-UA, новые его версии часто имеют проблемы при работе с сервером OPC-UA от OpenSCADA. В целом, результаты совместимости работы с клиентами и серверами различных производителей можно получить в <a href="#TableOfCompat">таблице совместимости</a>.
</p>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB_OPC-UA"><span class="tocnumber">1</span> <span class="toctext">Протокол OPC-UA</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#.D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D1.80.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B8_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D0.B0"><span class="tocnumber">2</span> <span class="toctext">Модуль реализации протокола</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#.D0.9E.D0.B1.D1.81.D0.BB.D1.83.D0.B6.D0.B8.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B7.D0.B0.D0.BF.D1.80.D0.BE.D1.81.D0.BE.D0.B2_.D0.BF.D0.BE_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.83_OPC-UA"><span class="tocnumber">2.1</span> <span class="toctext">Обслуживание запросов по протоколу OPC-UA</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#.D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D1.81.D0.B1.D0.BE.D1.80.D0.B0_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85"><span class="tocnumber">3</span> <span class="toctext">Модуль сбора данных</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#.D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.BA.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80.D0.B0"><span class="tocnumber">3.1</span> <span class="toctext">Объект контроллера</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#.D0.9F.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D1.8B"><span class="tocnumber">3.2</span> <span class="toctext">Параметры</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#.D0.A1.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82.D0.BD.D1.8B.D0.B9_.28std.29"><span class="tocnumber">3.2.1</span> <span class="toctext">Стандартный (std)</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#.D0.9B.D0.BE.D0.B3.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B9_.28logic.29"><span class="tocnumber">3.2.2</span> <span class="toctext">Логический (logic)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-9"><a href="#API_.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">3.3</span> <span class="toctext"><span>API пользовательского программирования</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#.D0.91.D0.B8.D0.B1.D0.BB.D0.B8.D0.BE.D1.82.D0.B5.D0.BA.D0.B0_libOPC_UA"><span class="tocnumber">4</span> <span class="toctext">Библиотека libOPC_UA</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#.D0.A1.D0.BB.D1.83.D0.B6.D0.B5.D0.B1.D0.BD.D1.8B.D0.B5_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82.D1.8B.2C_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8_.D0.B8_.D0.BA.D0.BB.D0.B0.D1.81.D1.81_UA"><span class="tocnumber">4.1</span> <span class="toctext">Служебные объекты, функции и класс UA</span></a>
<ul>
<li class="toclevel-3 tocsection-12"><a href="#.D0.94.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5"><span class="tocnumber">4.1.1</span> <span class="toctext">Данные</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#.D0.92.D0.BD.D0.B5.D1.88.D0.BD.D0.B8.D0.B5_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8"><span class="tocnumber">4.1.2</span> <span class="toctext">Внешние функции</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#.D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.B0.D0.B2.D1.82.D0.BE.D0.BC.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D1.80.D0.B0.D0.B7.D0.B1.D0.BB.D0.BE.D0.BA.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_POSIX_.D0.BC.D1.8E.D1.82.D0.B5.D0.BA.D1.81.D0.B0_.D0.B4.D0.BB.D1.8F_OPC_.28OPCAlloc.29"><span class="tocnumber">4.1.3</span> <span class="toctext">Объект автоматического разблокирования POSIX мютекса для OPC (OPCAlloc)</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#.D0.9E.D1.88.D0.B8.D0.B1.D0.BA.D0.B0_OPC_.28OPCError.29"><span class="tocnumber">4.1.4</span> <span class="toctext">Ошибка OPC (OPCError)</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#XML-.D1.82.D0.B5.D0.B3_.28XML_N.29"><span class="tocnumber">4.1.5</span> <span class="toctext">XML-тег (XML_N)</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="#.D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D1.83.D0.B7.D0.BB.D0.B0_OPC-UA_.28NodeId.29"><span class="tocnumber">4.1.6</span> <span class="toctext">Объект узла OPC-UA (NodeId)</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="#.D0.9A.D0.BE.D1.80.D0.BD.D0.B5.D0.B2.D0.BE.D0.B9_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D0.B0_OPC-UA_.28UA.29"><span class="tocnumber">4.1.7</span> <span class="toctext">Корневой объект протокола OPC-UA (UA)</span></a>
<ul>
<li class="toclevel-4 tocsection-19"><a href="#.D0.92.D0.BA.D0.BB.D1.8E.D1.87.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.BE.D0.B2_.D0.B1.D0.B5.D0.B7.D0.BE.D0.BF.D0.B0.D1.81.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.28SecuritySetting.29"><span class="tocnumber">4.1.7.1</span> <span class="toctext">Включенный объект параметров безопасности (SecuritySetting)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-20"><a href="#.D0.9E.D1.81.D0.BD.D0.BE.D0.B2.D0.BD.D0.BE.D0.B9_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.9A.D0.BB.D0.B8.D0.B5.D0.BD.D1.82.D0.B0_.28Client-.3EUA.29"><span class="tocnumber">4.2</span> <span class="toctext">Основной объект Клиента (Client-&gt;UA)</span></a>
<ul>
<li class="toclevel-3 tocsection-21"><a href="#.D0.9A.D0.BE.D0.BC.D0.BF.D0.BB.D0.B5.D0.BA.D1.81.D0.BD.D1.8B.D0.B9_.D1.81.D0.B5.D0.B0.D0.BD.D1.81_.D0.9A.D0.BB.D0.B8.D0.B5.D0.BD.D1.82.D0.B0_.28Client::SClntSess.29"><span class="tocnumber">4.2.1</span> <span class="toctext">Комплексный сеанс Клиента (Client::SClntSess)</span></a>
<ul>
<li class="toclevel-4 tocsection-22"><a href="#.D0.9F.D0.BE.D0.B4.D0.BF.D0.B8.D1.81.D0.BA.D0.B0_.D0.9A.D0.BB.D0.B8.D0.B5.D0.BD.D1.82.D0.B0_.28Client::Subscr.29"><span class="tocnumber">4.2.1.1</span> <span class="toctext">Подписка Клиента (Client::Subscr)</span></a>
<ul>
<li class="toclevel-5 tocsection-23"><a href="#.D0.AD.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82_.D0.9C.D0.BE.D0.BD.D0.B8.D1.82.D0.BE.D1.80.D0.B8.D0.BD.D0.B3.D0.B0_.D0.9F.D0.BE.D0.B4.D0.BF.D0.B8.D1.81.D0.BA.D0.B8_.D0.9A.D0.BB.D0.B8.D0.B5.D0.BD.D1.82.D0.B0_.28Client::Subscr::MonitItem.29"><span class="tocnumber">4.2.1.1.1</span> <span class="toctext">Элемент Мониторинга Подписки Клиента (Client::Subscr::MonitItem)</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-24"><a href="#.D0.9E.D1.81.D0.BD.D0.BE.D0.B2.D0.BD.D0.BE.D0.B9_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server-.3EUA.29"><span class="tocnumber">4.3</span> <span class="toctext">Основной объект Сервера (Server-&gt;UA)</span></a>
<ul>
<li class="toclevel-3 tocsection-25"><a href="#.D0.9A.D0.B0.D0.BD.D0.B0.D0.BB_.D0.91.D0.B5.D0.B7.D0.BE.D0.BF.D0.B0.D1.81.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::SecCnl.29"><span class="tocnumber">4.3.1</span> <span class="toctext">Канал Безопасности Сервера (Server::SecCnl)</span></a></li>
<li class="toclevel-3 tocsection-26"><a href="#.D0.A1.D0.B5.D0.B0.D0.BD.D1.81_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::Sess.29"><span class="tocnumber">4.3.2</span> <span class="toctext">Сеанс Сервера (Server::Sess)</span></a>
<ul>
<li class="toclevel-4 tocsection-27"><a href="#.D0.A2.D0.BE.D1.87.D0.BA.D0.B0_.D0.BF.D1.80.D0.BE.D0.B4.D0.BE.D0.BB.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BE.D0.B1.D0.B7.D0.BE.D1.80.D0.B0_.D0.A1.D0.B5.D0.B0.D0.BD.D1.81.D0.B0_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::Sess::ContPoint.29"><span class="tocnumber">4.3.2.1</span> <span class="toctext">Точка продолжения обзора Сеанса Сервера (Server::Sess::ContPoint)</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-28"><a href="#.D0.9F.D0.BE.D0.B4.D0.BF.D0.B8.D1.81.D0.BA.D0.B0_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::Subscr.29"><span class="tocnumber">4.3.3</span> <span class="toctext">Подписка Сервера (Server::Subscr)</span></a>
<ul>
<li class="toclevel-4 tocsection-29"><a href="#.D0.AD.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82_.D0.9C.D0.BE.D0.BD.D0.B8.D1.82.D0.BE.D1.80.D0.B8.D0.BD.D0.B3.D0.B0_.D0.9F.D0.BE.D0.B4.D0.BF.D0.B8.D1.81.D0.BA.D0.B8_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::Subscr::MonitItem.29"><span class="tocnumber">4.3.3.1</span> <span class="toctext">Элемент Мониторинга Подписки Сервера (Server::Subscr::MonitItem)</span></a>
<ul>
<li class="toclevel-5 tocsection-30"><a href="#.D0.AD.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82_.D0.B7.D0.BD.D0.B0.D1.87.D0.B5.D0.BD.D0.B8.D1.8F_.D0.AD.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.B0_.D0.9C.D0.BE.D0.BD.D0.B8.D1.82.D0.BE.D1.80.D0.B8.D0.BD.D0.B3.D0.B0_.D0.9F.D0.BE.D0.B4.D0.BF.D0.B8.D1.81.D0.BA.D0.B8_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::Subscr::MonitItem::Val.29"><span class="tocnumber">4.3.3.1.1</span> <span class="toctext">Элемент значения Элемента Мониторинга Подписки Сервера (Server::Subscr::MonitItem::Val)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-3 tocsection-31"><a href="#.D0.9A.D0.BE.D0.BD.D0.B5.D1.87.D0.BD.D0.B0.D1.8F_.D0.A2.D0.BE.D1.87.D0.BA.D0.B0_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::EP.29"><span class="tocnumber">4.3.4</span> <span class="toctext">Конечная Точка Сервера (Server::EP)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-32"><a href="#.D0.9F.D1.80.D0.B8.D0.B2.D0.B0.D1.82.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BB.D1.8E.D1.87.D0.B8_.D0.B8_.D1.81.D0.B5.D1.80.D1.82.D0.B8.D1.84.D0.B8.D0.BA.D0.B0.D1.82.D1.8B"><span class="tocnumber">5</span> <span class="toctext">Приватные ключи и сертификаты</span></a></li>
<li class="toclevel-1 tocsection-33"><a href="#.D0.97.D0.B0.D0.BC.D0.B5.D1.87.D0.B0.D0.BD.D0.B8.D1.8F"><span class="tocnumber">6</span> <span class="toctext">Замечания</span></a></li>
<li class="toclevel-1 tocsection-34"><a href="#.D0.A2.D0.B0.D0.B1.D0.BB.D0.B8.D1.86.D0.B0_.D1.81.D0.BE.D0.B2.D0.BC.D0.B5.D1.81.D1.82.D0.B8.D0.BC.D0.BE.D1.81.D1.82.D0.B8_.D1.81_.D1.80.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F.D0.BC.D0.B8_OPC-UA_.D0.B4.D1.80.D1.83.D0.B3.D0.B8.D1.85_.D0.BF.D1.80.D0.BE.D0.B8.D0.B7.D0.B2.D0.BE.D0.B4.D0.B8.D1.82.D0.B5.D0.BB.D0.B5.D0.B9"><span class="tocnumber">7</span> <span class="toctext"><span>Таблица совместимости с реализациями OPC-UA других производителей</span></span></a></li>
<li class="toclevel-1 tocsection-35"><a href="#.D0.A1.D1.81.D1.8B.D0.BB.D0.BA.D0.B8"><span class="tocnumber">8</span> <span class="toctext">Ссылки</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id=".D0.9F.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB_OPC-UA"><span class="mw-headline-number">1</span> Протокол OPC-UA</span></h2>
<p>OPC-UA — это платформо-независимый стандарт, с помощью которого системы и устройства различного типа могут взаимодействовать путём отправки сообщений между клиентом и сервером через различные типы сетей. Протокол поддерживает безопасное взаимодействие путём валидации клиентов и серверов, а также противодействия атакам. OPC-UA определяет понятие <i>Сервисы</i>, которые сервера могут предоставлять, а также сервисы, которые сервер поддерживает для клиента. Информация передаётся в виде типов данных, определённых OPC-UA и производителем, кроме того сервера определяют объектную модель, для которой клиенты могут осуществлять динамический обзор.
</p><p>OPC-UA предоставляет совмещение интегрированного адресного пространства и сервисной модели. Это позволяет серверу интегрировать данные, нарушения (Alarms), события (Events) и историю в этом адресном пространстве, а также предоставлять доступ к ним посредством интегрированных сервисов. Сервисы также предоставляют интегрированную модель безопасности.
</p><p>OPC-UA позволяет серверам предоставлять для клиентов определения типов, для доступа к объектам из адресного пространства. OPC-UA допускает предоставление данных в различных форматах, включая бинарные структуры и XML-документы. Через адресное пространство клиенты могут запросить у сервера метаданные, которые описывают формат данных.
</p><p>OPC-UA добавляет поддержку множественной связности между узлами вместо простого ограничения иерархичностью. Такая гибкость, в комбинации с определением типов, позволяет применять OPC-UA для решения задач в широкой проблемной области.
</p><p>OPC-UA спроектирован для обеспечения надёжной выдачи данных. Основная особенность всех OPC серверов — способность выдавать данные и события.
</p><p>OPC-UA спроектирован для поддержки широкого диапазона серверов, от простых ПЛК до промышленных серверов. Эти сервера характеризуются широким спектром размеров, производительности, платформ исполнения и функциональной ёмкости. Следовательно, OPC-UA определяет исчерпывающее множество возможностей и сервер может имплементировать подмножества этих возможностей. Для обеспечения совместимости, OPC-UA определяет подмножества, именуемые <i>Профилями</i>, которые сервера могут указывать для согласования. Клиенты могут в последствии выполнять обзор профилей сервера и пробрасывать взаимодействие с сервером, основанном на профилях.
</p><p>OPC-UA спецификация спроектирована как ядро в слое, изолированном от подлежащих компьютерных технологий и сетевых транспортов. Это позволяет OPC-UA, при необходимости, расширяться на будущие технологии без отторжения основы дизайна. На данный момент, спецификацией определены два способа кодирования данных: UA Binary и XML/text. Дополнительно определено два типа транспортного слоя: TCP и HTTP/SOAP.
</p><p>OPC-UA спроектирован как решение для миграции с OPC клиентов и серверов, которые основаны на Microsoft COM технологиях. OPC COM сервера (DA, HDA и A&amp;E) могут быть легко отражены в OPС-UA. Производители могут самостоятельно осуществлять такую миграцию или же рекомендовать пользователям использовать обёртки и конвертеры между этими протоколами. OPC-UA унифицирует предыдущие модели в едином адресном пространстве с единым множеством сервисов.
</p>
<h2><span class="mw-headline" id=".D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D1.80.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D0.B8_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D0.B0"><span class="mw-headline-number">2</span> Модуль реализации протокола</span></h2>
<p>Модуль сервера содержит код реализации серверной части OPC-UA — серверных сервисов (Рис.1), в части специфичной для OpenSCADA, и используя библиотеку для OPC-UA специфичной части. Для построения OPC-UA сервера достаточно создать входящий транспорт, обычно это TCP-транспорт модуля <a href="../Modules/Sockets.html" title="Special:MyLanguage/Modules/Sockets">Sockets</a>, и выбрать в нём модуль данного протокола, а также сконфигурировать хотя бы один конечный узел модуля протокола, о чём ниже.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:930px;"><a class="image" href="http://oscada.org/wiki/File:OPC-UA_prt_serv_ru.png"><img class="thumbimage" height="491" src="../files/OPC-UA_prt_serv_ru.png" width="928" /></a>  <div class="thumbcaption">Рис.1. Общее состояние "Сервера".</div></div></div></div>
<p>Общее состояние Сервера содержит только перечень активных каналов безопасности.
</p>
<h3><span class="mw-headline" id=".D0.9E.D0.B1.D1.81.D0.BB.D1.83.D0.B6.D0.B8.D0.B2.D0.B0.D0.BD.D0.B8.D0.B5_.D0.B7.D0.B0.D0.BF.D1.80.D0.BE.D1.81.D0.BE.D0.B2_.D0.BF.D0.BE_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D1.83_OPC-UA"><span class="mw-headline-number">2.1</span> Обслуживание запросов по протоколу OPC-UA</span></h3>
<p>Входящие запросы к модулю-протоколу обрабатываются модулем в соответствии со сконфигурированными конечными узлами OPC-UA (EndPoints) (рис.2).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:676px;"><a class="image" href="http://oscada.org/wiki/File:OPC-UA_prt_eps_ru.png"><img class="thumbimage" height="505" src="../files/OPC-UA_prt_eps_ru.png" width="674" /></a>  <div class="thumbcaption">Рис.2. Конечные узлы протокола.</div></div></div></div>
<p>Конечный узел протокола OPC-UA это фактически объект сервера OPC-UA. Конечные узлы в OPC-UA могут быть как локальными, так и удалёнными. Локальные конечные узлы предназначены для предоставления ресурсов станции OpenSCADA по протоколу OPC-UA, в тоже время удалённые конечные узлы служат для выполнения как сервиса обзора доступных OPC-UA узлов, так и для шлюзования запросов к удалённым станциям. В данной версии модуля поддерживается только конфигурация локальных конечных узлов.
</p><p>Общая конфигурация конечного узла осуществляется на главной вкладке страницы конечного узла (рис.2) параметрами:
</p>
<ul><li> Состояние узла, а именно: общий статус, перечень активных сеансов и подписок, "Включен" и имя БД, содержащей конфигурацию.</li>
<li> Идентификатор, имя и описание узла.</li>
<li> Состояние, в которое переводить узел при загрузке: "Включен".</li>
<li> Тип кодирования протокола, на данный момент это только "Бинарный".</li>
<li> URL конечной точки.</li>
<li> Сертификат сервера и приватный ключ в формате PEM.</li></ul>
<dl><dd><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../../en/files/At.png" width="22" /></a> Спрятано во включенном состоянии.</dd></dl>
<ul><li> Политики безопасности сервера.</li></ul>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:946px;"><a class="image" href="http://oscada.org/wiki/File:OPC-UA_prt_ep_main_ru.png"><img class="thumbimage" height="845" src="../files/OPC-UA_prt_ep_main_ru.png" width="944" /></a>  <div class="thumbcaption">Рис.3. Главная вкладка страницы конечного узла.</div></div></div></div>
<h2><span class="mw-headline" id=".D0.9C.D0.BE.D0.B4.D1.83.D0.BB.D1.8C_.D1.81.D0.B1.D0.BE.D1.80.D0.B0_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85"><span class="mw-headline-number">3</span> Модуль сбора данных</span></h2>
<p>Модуль сбора данных предоставляет возможность опроса и записи атрибутов значения(13) узлов типа "Переменная" в режиме прямого опроса запросом "Read" и асинхронным сервисом запроса "Publish".
</p>
<h3><span class="mw-headline" id=".D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.BA.D0.BE.D0.BD.D1.82.D1.80.D0.BE.D0.BB.D0.BB.D0.B5.D1.80.D0.B0"><span class="mw-headline-number">3.1</span> Объект контроллера</span></h3>
<p>Для добавления источника данных OPC-UA создаётся и конфигурируется объект контроллера в OpenSCADA. Пример вкладки конфигурации объекта контроллера данного типа изображен на рисунке 4.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:994px;"><a class="image" href="http://oscada.org/wiki/File:OPC-UA_cntr_main_ru.png"><img class="thumbimage" height="849" src="../files/OPC-UA_cntr_main_ru.png" width="992" /></a>  <div class="thumbcaption">Рис.4. Вкладка конфигурации объекта контроллера OPC-UA.</div></div></div></div>
<p>С помощью этой вкладки можно установить:
</p>
<ul><li> Состояние контроллера, а именно: детализированный общий статус, "Включен", "Исполнение" и имя БД, содержащей конфигурацию.</li>
<li> Идентификатор, имя и описание контроллера.</li>
<li> Состояние, в которое переводить контроллер при загрузке: "Включен" и "Исполнение".</li>
<li> Имя таблицы для хранения конфигурации параметров контроллера.</li>
<li> Политика планирования и приоритет задачи сбора данных.</li>
<li> Период синхронизации конфигурации атрибутов параметров с удалённой станцией, а также время повтора попыток восстановления подключения.</li>
<li> URL конечного узла удалённой станции — сервера OPC-UA. Вначале этот адрес можно указать в виде "<b>opc.tcp://{IP|name}:{port}</b>", после чего, в случае включения объекта контроллера и наличия указанного OPC-UA узла, появится возможность выбрать уточнённый адрес.</li></ul>
<dl><dd><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../../en/files/At.png" width="22" /></a> Часто встречается ситуация, когда уточнённый адрес является символьным, который в этой сети не резолвится, из-за некорректной настройки сервера. В таких случаях нужно оставить исходный IP-адрес или имя которое резолвится в IP правильно.</dd></dl>
<ul><li> Политика безопасности и режим безопасности сообщения.</li>
<li> Сертификат клиента и приватный ключ в формате PEM.</li></ul>
<dl><dd><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../../en/files/At.png" width="22" /></a> Спрятано в состоянии исполнения.</dd></dl>
<ul><li> Пользователь и пароль для аутентификации на сервере, пустое значение включает анонимный доступ.</li>
<li> Использовать функцию "Read", иначе активируется и используется сервис сбора данных Publish (асинхронный) протокола OPC-UA.</li></ul>
<p>С целью облегчения идентификации узлов на удалённой станции, а также выбора их для вставки в объекте параметра контроллера, в самом объекте контроллера предусмотрена вкладка навигации по узлам удалённой станции "Обзор узлов сервера", где можно пройти по дереву объектов и ознакомится с их атрибутами (рис.5).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:729px;"><a class="image" href="http://oscada.org/wiki/File:OPC-UA_cntr_browse_ru.png"><img class="thumbimage" height="671" src="../files/OPC-UA_cntr_browse_ru.png" width="727" /></a>  <div class="thumbcaption">Рис.5. Вкладка "Обзор узлов сервера" страницы объекта контроллера OPC-UA.</div></div></div></div>
<h3><span class="mw-headline" id=".D0.9F.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D1.8B"><span class="mw-headline-number">3.2</span> Параметры</span></h3>
<p>Модуль сбора данных предоставляет два типа параметра: "Стандартный (std)" и "Логический (logic)". Дополнительными конфигурационными полями параметров данного модуля являются:
</p>
<ul><li> <i><b>Стандартный (std)</b></i>:
<ul><li> <i>Перечень атрибутов</i> — содержит структурированный список конфигурации атрибутов ModBUS.</li></ul></li>
<li> <i><b>Логический (logic)</b></i>:
<ul><li> <i>Шаблон параметра</i> — адрес шаблона параметра DAQ.</li></ul></li></ul>
<h4><span class="mw-headline" id=".D0.A1.D1.82.D0.B0.D0.BD.D0.B4.D0.B0.D1.80.D1.82.D0.BD.D1.8B.D0.B9_.28std.29"><span class="mw-headline-number">3.2.1</span> Стандартный (std)</span></h4>
<p>Дополнительным конфигурационным полем параметра данного модуля (рис.6) является перечень узлов OPC-UA и поле однострочной навигации по узлам OPC-UA для вставки выбранных узлов типа "Переменная" в указанный перечень. Атрибут в этом перечне записывается как "<b>{ns}:{id}[|[{flg}][|{id}[|{name}]]]</b>".<br />
Где:
</p>
<ul><li> <i>ns</i> — область имён, числом; нулевое значение может быть опущено;</li>
<li> <i>id</i> — идентификатор узла, числом, строкой, строкой байт или GUID;</li>
<li> <i>flg</i> — флажки неосуществления запроса целевых данных на сервере: тип значения (b-Логический,i-Целое,f-Вещественное,s-Строка,o-Объект), режим чтения/записи (r-чтение, w-запись);</li>
<li> <i>id</i> — идентификатор создаваемого атрибута;</li>
<li> <i>name</i> — имя создаваемого атрибута.</li></ul>
<p>Примеры:
</p>
<dl><dd><b>84</b> — корневой узел;</dd>
<dd><b>3:"BasicDevices2"||var</b> — узел базовых устройств в области имён 3 и в виде строки с прямым ИД атрибута;</dd>
<dd><b>4:"61626364"||var|Variable</b> — узел в области имён 4 и в виде строки байт с прямым ИД и названием атрибута;</dd>
<dd><b>4:{40d95ab0-50d6-46d3-bffd-f55639b853d4}|irw|var|Variable</b> — узел в области имён 4 и в виде GUID с неосуществлением запроса целевых данных на предмет Целого Чтения-Записи и прямым ИД и названием атрибута.</dd></dl>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:688px;"><a class="image" href="http://oscada.org/wiki/File:OPC-UA_prm_ru.png"><img class="thumbimage" height="669" src="../files/OPC-UA_prm_ru.png" width="686" /></a>  <div class="thumbcaption">Рис.6. Вкладка конфигурации объекта параметра OPC-UA.</div></div></div></div>
<p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../../en/files/At.png" width="22" /></a> Узлы типа "Переменная" со значением в виде структуры прочитать целиком обычно нельзя поэтому необходимо её элементы вставлять в перечень узлов чтения отдельно.
</p><p>Согласно указанного списка узлов выполняется опрос и создание атрибутов параметра (рис.7).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:688px;"><a class="image" href="http://oscada.org/wiki/File:OPC-UA_prm_atr_ru.png"><img class="thumbimage" height="589" src="../files/OPC-UA_prm_atr_ru.png" width="686" /></a>  <div class="thumbcaption">Рис.7. Вкладка атрибутов параметра.</div></div></div></div>
<h4><span class="mw-headline" id=".D0.9B.D0.BE.D0.B3.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.B8.D0.B9_.28logic.29"><span class="mw-headline-number">3.2.2</span> Логический (logic)</span></h4>
<p>Главная страница конфигурации параметра логического типа представлена на рисунке 8.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:810px;"><a class="image" href="http://oscada.org/wiki/File:OPC-UALog_prm_ru.png"><img class="thumbimage" height="589" src="../files/OPC-UALog_prm_ru.png" width="808" /></a>  <div class="thumbcaption">Рис.8. Вкладка конфигурации параметра логического типа.</div></div></div></div>
<p>Значение ссылки при конфигурации шаблона (рис.9) записывается в форме "<b>{ns}:{id}</b>".<br />
Где:
</p>
<ul><li> <i>ns</i> — область имён, числом; нулевое значение может быть опущено;</li>
<li> <i>id</i> — идентификатор узла, числом, строкой, строкой байт или GUID.</li></ul>
<p>Примеры:
</p>
<dl><dd><b>84</b> — корневой узел;</dd>
<dd><b>3:"BasicDevices2"</b> — узел базовых устройств в области имён 3 и в виде строки;</dd>
<dd><b>4:"61626364"</b> — узел в области имён 4 и в виде строки байт;</dd>
<dd><b>4:{40d95ab0-50d6-46d3-bffd-f55639b853d4}</b> — узел в области имён 4 и в виде GUID.</dd></dl>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:810px;"><a class="image" href="http://oscada.org/wiki/File:OPC-UALog_tmpl_ru.png"><img class="thumbimage" height="589" src="../files/OPC-UALog_tmpl_ru.png" width="808" /></a>  <div class="thumbcaption">Рис.9. Вкладка "Конфигурация шаблона" параметра логического типа.</div></div></div></div>
<p>Модулем предусмотрена особая обработка ряда атрибутов шаблона:
</p>
<ul><li> <i>f_frq</i> — частота вычисления процедуры шаблона или время после последнего вычисления (отрицательное в секундах) для планирования по CRON, только чтение.</li>
<li> <i>f_start</i> — флаг первого выполнения процедуры шаблона — запуск, только чтение.</li>
<li> <i>f_stop</i> — флаг последнего выполнения процедуры шаблона — останов, только чтение.</li>
<li> <i>f_err</i> — ошибка параметра, полный доступ. Значение этого атрибута шаблона попадает в атрибут ошибки параметра "err". Записать сюда <b>EVAL</b> для возможности установки извне атрибута "err" и всех других в режиме Только для Чтения.</li>
<li> <i>SHIFR</i> — значение шифра параметра, только чтение.</li>
<li> <i>NAME</i> — значение имени параметра, только чтение.</li>
<li> <i>DESCR</i> — значение описания параметра, только чтение.</li>
<li> <i>this</i> — объект данного параметра, позволяет получить доступ к атрибутам параметра, например, для доступа к архивам-истории.</li></ul>
<p>В соответствии с шаблоном, лежащим в основе параметра, мы получаем набор атрибутов параметра (рис.10).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:810px;"><a class="image" href="http://oscada.org/wiki/File:OPC-UALog_prm_atr_ru.png"><img class="thumbimage" height="589" src="../files/OPC-UALog_prm_atr_ru.png" width="808" /></a>  <div class="thumbcaption">Рис.10. Вкладка атрибутов параметра логического типа.</div></div></div></div>
<h3><span class="mw-headline" id="API_.D0.BF.D0.BE.D0.BB.D1.8C.D0.B7.D0.BE.D0.B2.D0.B0.D1.82.D0.B5.D0.BB.D1.8C.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D0.BF.D1.80.D0.BE.D0.B3.D1.80.D0.B0.D0.BC.D0.BC.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F"><span class="mw-headline-number">3.3</span> <span id="UserAPI" title="#UserAPI">API пользовательского программирования</span></span></h3>
<p>В виду поддержки параметров логического типа, имеет смысл предоставление ряда функций пользовательского API для их вызова из шаблона логического параметра.
</p><p><b>Объект "Параметр" [this]</b>
</p>
<ul><li> <i>bool attrAdd( string id, string name, string tp = "real", string selValsNms = "" )</i> [<span style="color: red">для включенного параметра логического типа</span>] — добавление атрибута <i>id</i> с именем <i>name</i> и типом <i>tp</i>. Если атрибут уже присутствует то будут применены свойства, которые возможно изменить "на ходу": имя, режим выбора и параметры выбора.
<ul><li> <i>id, name</i> — идентификатор и имя нового атрибута;</li>
<li> <i>tp</i> — тип атрибута [boolean | integer | real | string | text | object] + режим выбора [sel | seled] + только для чтения [ro];</li>
<li> <i>selValsNms</i> — две строки со значениями в первой и их именами во второй, разделённые ";".</li></ul></li>
<li> <i>bool attrDel( string id )</i> [<span style="color: red">для включенного параметра логического типа</span>] — удаление атрибута <i>id</i>.</li></ul>
<p><br />
</p>
<h2><span class="mw-headline" id=".D0.91.D0.B8.D0.B1.D0.BB.D0.B8.D0.BE.D1.82.D0.B5.D0.BA.D0.B0_libOPC_UA"><span class="mw-headline-number">4</span> Библиотека libOPC_UA</span></h2>
<p>Основываясь на наработках данного модуля, протокольный код OPC-UA был вынесен в отдельную библиотеку и опубликован под лицензией LGPLv3. Данные действия выполнены с целью предоставить возможность простого добавления поддержки протокола OPC-UA сторонними проектами. Библиотека представлена двумя файлами libOPC_UA.h, libOPC_UA.cpp; поддерживается и содержится в составе данного модуля, т.е. актуальную версию Вы можете загрузить здесь: <a class="external free" href="http://oscada.org/svn/trunk/OpenSCADA/src/moduls/daq/OPC_UA/libOPC_UA" rel="nofollow noreferrer noopener" target="_blank">http://oscada.org/svn/trunk/OpenSCADA/src/moduls/daq/OPC_UA/libOPC_UA</a>.
</p><p>Библиотека, как и данный модуль, написан на языке программирования C++. Статическая диаграмма классов, отражающая архитектуру библиотеки, приведена на рисунке 11. Согласно диаграмме классов, библиотека выполнена в области имён "OPC", а архитектурно её можно разделить на клиентскую "Client" и серверную "Server" части, которые унаследованы от общего класса протокола "UA". Кроме непосредственно классов протокола "OPC-UA" библиотека включает в себя набор функций и классов для обработки или хранения данных протокола, отдельно из которых нужно отметить класс узла языка XML "XML_N", используемый для унификации обращений к API библиотеки.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:400px;"><a class="image" href="http://oscada.org/wiki/File:OPC-UA_libOPCUA_class.png"><img class="thumbimage" height="311" src="../../en/files/OPC-UA_libOPCUA_class.png" width="398" /></a>  <div class="thumbcaption">Рис.11. Статическая диаграмма классов библиотеки libOPC_UA.</div></div></div></div>
<p>Использование библиотеки в целом заключается в наследовании от класса "Client" и/или "Server" согласно с функциями конечной программы и последующей реализации виртуальных функций свойств клиента/сервера в контексте протокола OPC-UA, а также транспортной части коммуникации, т.е. — подключение/открытие TCP-сокета и передачу/чтение неструктурированного потока данных. Последующие запросы, и обработка запросов данных (для сервера), осуществляются через вызов функции запроса сервису <i>reqService()</i> и/или обработки виртуальной функции запроса данных <i>reqData()</i>, т.е., по сути, интеграция в модель данных приложения.
</p><p>После добавления к клиенту поддержки асинхронного сервиса опроса данных сервисом "Publish", процесс интеграции дополнился периодическим вызовом функции <i>Client::poll()</i> с целью обработки асинхронного сервиса. Функция <i>Client::poll()</i> также обеспечена поддержкой синхронного режима работы, отдельным аргументом, через унифицированную инфраструктуру подписки-регистрации элементов мониторинга, но функцией "Read". Т.е., на данный момент достаточно зарегистрировать все элементы мониторинга функцией <i>Client::Subscr::monitoredItemAdd()</i> а потом вызывать функцию <i>Client::poll()</i> для получения их данных в нужном режиме.
</p><p>После последнего пересмотра кода в версии 2, интеграция серверной части дополнительно нуждается в обязательном запуске отдельного потока обработки всех подписок, с вызовом из него функции <i>Server::EP::subScrCycle()</i> и аргументом счётчика циклов обработки подписок — периодичность вызова <i>Server::EP::subscrProcPer()</i>.
</p>
<h3><span class="mw-headline" id=".D0.A1.D0.BB.D1.83.D0.B6.D0.B5.D0.B1.D0.BD.D1.8B.D0.B5_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82.D1.8B.2C_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8_.D0.B8_.D0.BA.D0.BB.D0.B0.D1.81.D1.81_UA"><span class="mw-headline-number">4.1</span> Служебные объекты, функции и класс UA</span></h3>
<h4><span class="mw-headline" id=".D0.94.D0.B0.D0.BD.D0.BD.D1.8B.D0.B5"><span class="mw-headline-number">4.1.1</span> Данные</span></h4>
<p>Типы реализаций (enum — SerializerType):
</p>
<ul><li> <i>ST_Binary = 0</i> — бинарный.</li></ul>
<p>Типы запроса открытия канала безопасности (enum — SC_ReqTP):
</p>
<ul><li> <i>SC_ISSUE = 0</i> — вызывающий;</li>
<li> <i>SC_RENEW = 1</i> — обновляющий.</li></ul>
<p>Режимы безопасности сообщения (enum — MessageSecurityMode):
</p>
<ul><li> <i>MS_None = 1</i> — без безопасности;</li>
<li> <i>MS_Sign = 2</i> — подпись;</li>
<li> <i>MS_SignAndEncrypt = 3</i> — подпись и шифрование.</li></ul>
<p>Типы аутентификации (enum — AuthTp):
</p>
<ul><li> <i>A_Anon = 0</i> — анонимно;</li>
<li> <i>A_UserNm = 1</i> — пользователь+пароль;</li>
<li> <i>A_Cert = 2</i> — сертификат.</li></ul>
<p>Классы узлов (enum — NodeClasses):
</p>
<ul><li> <i>NC_Object = 1</i> — объект;</li>
<li> <i>NC_Variable = 2</i> — переменная;</li>
<li> <i>NC_Method = 4</i> — метод;</li>
<li> <i>NC_ObjectType = 8</i> — тип объекта;</li>
<li> <i>NC_VariableType = 16</i> — тип переменной;</li>
<li> <i>NC_ReferenceType = 32</i> — тип ссылки;</li>
<li> <i>NC_DataType = 64</i> — тип данных;</li>
<li> <i>NC_View = 128</i> — вид.</li></ul>
<p>Направления обзора (enum — BrowseDirection):
</p>
<ul><li> <i>BD_FORWARD = 0</i> — вперёд;</li>
<li> <i>BD_INVERSE = 1</i> — назад;</li>
<li> <i>BD_BOTH = 2</i> — вперёд и назад.</li></ul>
<p>Возвратная метка времени (enum — TimestampsToReturn):
</p>
<ul><li> <i>TS_SOURCE = 0</i> — источника;</li>
<li> <i>TS_SERVER = 1</i> — сервера;</li>
<li> <i>TS_BOTH = 2</i> — источника и сервера;</li>
<li> <i>TS_NEITHER = 3</i> — отсутствует.</li></ul>
<p>Доступ (enum — Access):
</p>
<ul><li> <i>ACS_Read = 0x01</i> — чтение;</li>
<li> <i>ACS_Write = 0x02</i> — запись;</li>
<li> <i>ACS_HistRead = 0x04</i> — чтение истории;</li>
<li> <i>ACS_HistWrite = 0x08</i> — запись истории;</li>
<li> <i>ACS_SemChange = 0x10</i> —&nbsp;?.</li></ul>
<p>Элементы маски описания обзорного запроса (enum — RefDscrResMask):
</p>
<ul><li> <i>RdRm_RefType = 0x01</i> — тип ссылки;</li>
<li> <i>RdRm_IsForward = 0x02</i> — направление;</li>
<li> <i>RdRm_NodeClass = 0x04</i> — класс узла;</li>
<li> <i>RdRm_BrowseName = 0x08</i> — имя обзора;</li>
<li> <i>RdRm_DisplayName = 0x10</i> — имя отображения;</li>
<li> <i>RdRm_TypeDef = 0x20</i> — тип определения.</li></ul>
<p>Идентификаторы атрибутов узла (enum — AttrIds):
</p>
<ul><li> <i>Aid_Error = 0</i> — ошибка;</li>
<li> <i>AId_NodeId = 1</i> — идентификатор узла;</li>
<li> <i>AId_NodeClass = 2</i> — класс узла;</li>
<li> <i>AId_BrowseName = 3</i> — имя обзора;</li>
<li> <i>AId_DisplayName = 4</i> — имя отображения;</li>
<li> <i>AId_Descr = 5</i> — описание;</li>
<li> <i>AId_WriteMask = 6</i> — маска записи;</li>
<li> <i>AId_UserWriteMask = 7</i> — маска записи пользователя;</li>
<li> <i>AId_IsAbstract = 8</i> — абстрактность;</li>
<li> <i>AId_Symmetric = 9</i> — симметричность;</li>
<li> <i>AId_InverseName = 10</i> — инверсное имя;</li>
<li> <i>AId_ContainsNoLoops = 11</i> — отсутствие петель;</li>
<li> <i>AId_EventNotifier = 12</i> — уведомление событий;</li>
<li> <i>AId_Value = 13</i> — значение;</li>
<li> <i>AId_DataType = 14</i> — тип данных;</li>
<li> <i>AId_ValueRank = 15</i> — ранг значения;</li>
<li> <i>AId_ArrayDimensions = 16</i> — размерность массива;</li>
<li> <i>AId_AccessLevel = 17</i> — уровень доступа;</li>
<li> <i>AId_UserAccessLevel = 18</i> — уровень доступа пользователя;</li>
<li> <i>AId_MinimumSamplingInterval = 19</i> — минимальный интервал измерений;</li>
<li> <i>AId_Historizing</i> — архивирование;</li>
<li> <i>AId_Executable</i> — исполняемый;</li>
<li> <i>AId_UserExecutable</i> — исполняемый пользователем.</li></ul>
<p>Состояния подписки (enum — SubScrSt):
</p>
<ul><li> <i>SS_CUR = 0</i> — текущее (не менять командой);</li>
<li> <i>SS_CLOSED = 1</i> — закрыто;</li>
<li> <i>SS_CREATING = 2</i> — создание;</li>
<li> <i>SS_NORMAL = 3</i> — нормальный;</li>
<li> <i>SS_LATE = 4</i> — запоздалый;</li>
<li> <i>SS_KEEPALIVE = 5</i> — сохранение живым.</li></ul>
<p>Режимы мониторинга (enum — MonitoringMode):
</p>
<ul><li> <i>MM_CUR = -1</i> — текущее (не менять командой);</li>
<li> <i>MM_DISABLED = 0</i> — отключено;</li>
<li> <i>MM_SAMPLING = 1</i> — измерение;</li>
<li> <i>MM_REPORTING = 2</i> — отчётность.</li></ul>
<h4><span class="mw-headline" id=".D0.92.D0.BD.D0.B5.D1.88.D0.BD.D0.B8.D0.B5_.D1.84.D1.83.D0.BD.D0.BA.D1.86.D0.B8.D0.B8"><span class="mw-headline-number">4.1.2</span> Внешние функции</span></h4>
<p>В библиотеку включен ряд внешних функций объекта <a class="external" href="http://oscada.org/wiki/Documents/API#TSYS" title="Documents/API">TSYS</a> ядра OpenSCADA для упрощения и унификации ряда внутренних операций:
</p>
<ul><li> <i>int64_t curTime( clockid_t clc = CLOCK_REALTIME );</i> — Текущее время в микросекундах для счетчика <i>clc</i>, с начала эпохи Unix (01.01.1970) для CLOCK_REALTIME.</li>
<li> <i>string int2str( int val );</i> — Преобразование целого знакового в строку в десятичном представлении.</li>
<li> <i>int str2int( const string &amp;val );</i> — Преобразование значения строки <i>val</i> в десятичном, шестнадцатеричном или восьмеричном представлении в целое знаковое.</li>
<li> <i>string uint2str( unsigned val );</i> — Преобразования целого беззнакового в строку в десятичном представлении.</li>
<li> <i>unsigned long str2uint( const string &amp;val );</i> — Преобразование значения строки <i>val</i> в десятичном, шестнадцатеричном или восьмеричном представлении в целое беззнаковое.</li>
<li> <i>string ll2str( int64_t val );</i> — Преобразования длинного целого (64бит) в строку в десятичном представлении.</li>
<li> <i>string real2str( double val, int prec = 15, char tp = 'g' );</i> — Преобразования вещественного с точностью <i>prec</i> знаков и типом <i>tp</i> в строку.</li>
<li> <i>double str2real( const string &amp;val );</i> — Преобразование значения строки <i>val</i> в вещественное.</li>
<li> <i>string strParse( const string &amp;path, int level, const string &amp;sep, int *off = NULL, bool mergeSepSymb = false );</i> — Разбор строки <i>path</i> на составляющие, отделённые разделителем <i>sep</i>, объединяя односимвольные <i>mergeSepSymb</i>, начиная со смещения <i>off</i> и контролируя смещение конца элемента в нём же.</li>
<li> <i>string strLine( const string &amp;str, int level, int *off = NULL );</i> — Разбор многострочного текста на отдельные строки, начиная со смещения <i>off</i> и контролируя смещение конца элемента в нём же.</li>
<li> <i>string strMess( const char *fmt, ... );</i> — Формирование стоки по шаблону <i>fmt</i> и аргументам, реализовано на основе "sprintf".</li></ul>
<h4><span class="mw-headline" id=".D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.B0.D0.B2.D1.82.D0.BE.D0.BC.D0.B0.D1.82.D0.B8.D1.87.D0.B5.D1.81.D0.BA.D0.BE.D0.B3.D0.BE_.D1.80.D0.B0.D0.B7.D0.B1.D0.BB.D0.BE.D0.BA.D0.B8.D1.80.D0.BE.D0.B2.D0.B0.D0.BD.D0.B8.D1.8F_POSIX_.D0.BC.D1.8E.D1.82.D0.B5.D0.BA.D1.81.D0.B0_.D0.B4.D0.BB.D1.8F_OPC_.28OPCAlloc.29"><span class="mw-headline-number">4.1.3</span> Объект автоматического разблокирования POSIX мютекса для OPC (OPCAlloc)</span></h4>
<p>Этот объект управления мютексом является копией объекта "MtxAlloc" для ядра OpenSCADA.
</p><p><b>Публичные методы:</b>
</p>
<ul><li> <i>OPCAlloc( pthread_mutex_t &amp;iM, bool ilock = false );</i> — Инициализация объекта автоматического разблокирования мютекса <i>iM</i>, созданного ранее, с блокированием при создании по <i>lock</i>.</li>
<li> <i>int lock( );</i> — Захват ресурса, возврат нуля при успешном выполнении.</li>
<li> <i>int unlock( );</i> — Освобождение ресурса, возврат нуля при успешном выполнении.</li>
<li> <i>int tryLock( );</i> — Проба захвата ресурса без ожидания освобождения, возврат нуля при успешном выполнении.</li></ul>
<h4><span class="mw-headline" id=".D0.9E.D1.88.D0.B8.D0.B1.D0.BA.D0.B0_OPC_.28OPCError.29"><span class="mw-headline-number">4.1.4</span> Ошибка OPC (OPCError)</span></h4>
<p>Объект ошибки "OPCError" является урезанной копией объекта <a class="external" href="http://oscada.org/wiki/Documents/API#TError" title="Documents/API">TError</a> ядра OpenSCADA.
</p><p><b>Публичные методы:</b>
</p>
<ul><li> <i>OPCError( const char *fmt, ... );</i> — Конструктор типовой ошибки без кода.</li>
<li> <i>OPCError( int cod, const char *fmt, ... );</i> — Конструктор типовой ошибки с кодом ошибки.</li></ul>
<p><b>Публичные атрибуты:</b>
</p>
<ul><li> <i>int cod;</i> — Код ошибки.</li>
<li> <i>string  mess;</i> — Текст ошибки.</li></ul>
<h4><span class="mw-headline" id="XML-.D1.82.D0.B5.D0.B3_.28XML_N.29"><span class="mw-headline-number">4.1.5</span> XML-тег (XML_N)</span></h4>
<p>Объект "XML_N" является урезанной копией объекта <a class="external" href="http://oscada.org/wiki/Documents/API#XMLNode" title="Documents/API">XMLNode</a> ядра OpenSCADA.
</p><p><b>Публичные методы:</b>
</p>
<ul><li> <i>XML_N( const string &amp;name = "" );</i> — Инициализация тега с именем <i>name</i>.</li>
<li> <i>XML_N( const XML_N &amp;nd );</i> — Копирующий конструктор.</li>
<li> <i>XML_N &amp;operator=( const XML_N &amp;prm );</i> — Копирование ветки XML-дерева из <i>prm</i>.</li>
<li> <i>string name( ) const;</i> — Имя тега.</li>
<li> <i>XML_N* setName( const string &amp;s );</i> — Установка имени тега в <i>s</i>.</li>
<li> <i>string text( bool childs = false, bool recursive = false ) const;</i> — Текст тега, <i>childs</i> — для получения текста из специализированных узлов текста.</li>
<li> <i>XML_N* setText( const string &amp;s, bool childs = false );</i> — Установка текста тега в <i>s</i>, <i>childs</i> — для установки текста в специализированный узел текста.</li>
<li> <i>void attrList( vector&lt;string&gt; &amp; list ) const;</i> — Список атрибутов <i>list</i> в теге.</li>
<li> <i>XML_N* attrDel( const string &amp;name );</i> — Удаление атрибута <i>name</i>.</li>
<li> <i>void attrClear( );</i> — Очистка атрибутов тега.</li>
<li> <i>string attr( const string &amp;name, bool caseSens = true ) const;</i> — Получение атрибута <i>name</i>.</li>
<li> <i>XML_N* setAttr( const string &amp;name, const string &amp;val );</i> — Установка/создание атрибута <i>name</i> со значением <i>val</i>.</li>
<li> <i>XML_N* clear( );</i> — Очистка тега (рекурсивно, включая все вложения).</li>
<li> <i>bool childEmpty( ) const;</i> — Проверка на отсутствие вложенных тегов.</li>
<li> <i>unsigned childSize( ) const;</i> — Количество вложенных тегов.</li>
<li> <i>void childAdd( XML_N *nd ); XML_N* childAdd( const string &amp;name = "" );</i> — Добавление вложенного тега.</li>
<li> <i>int childIns( unsigned id, XML_N *nd );</i> — Вставка вложенного тега <i>nd</i> в позицию <i>id</i>, отрицательное значение <i>id</i> отсчитывает с конца.</li>
<li> <i>XML_N* childIns( unsigned id, const string &amp;name = "" );</i> — Вставка вложенного тега с именем <i>name</i> в позицию <i>id</i>, отрицательное значение <i>id</i> отсчитывает с конца.</li>
<li> <i>void childDel( const unsigned id );</i> — Удаление вложенного тега <i>id</i>, отрицательное значение <i>id</i> отсчитывает с конца.</li>
<li> <i>void childDel( XML_N *nd );</i> — Удаление вложенного тега по его адресу <i>nd</i>.</li>
<li> <i>XML_N* childClear( const string &amp;name = "" );</i> — Очистка вложенного тега <i>name</i>.</li>
<li> <i>XML_N* childGet( const int, bool noex = false ) const;</i> — Получение вложенного тега по порядковому номеру.</li>
<li> <i>XML_N* childGet( const string &amp;name, const int numb = 0, bool noex = false ) const;</i> — Получение вложенного <i>numb</i> порядкового тега по имени тега <i>name</i>, <i>noex</i> указывает на запрет генерации исключения в случае отсутствия тега.</li>
<li> <i>XML_N* childGet( const string &amp;attr, const string &amp;name, bool noex = false ) const;</i> — Получение вложенного тега по значению <i>name</i> атрибута <i>attr</i>, <i>noex</i> указывает на запрет генерации исключения в случае отсутствия тега.</li>
<li> <i>XML_N* getElementBy( const string &amp;attr, const string &amp;val );</i> — Поиск вложенного узла по значению <i>val</i> атрибута <i>attr</i>.</li>
<li> <i>XML_N* parent( );</i> — Родительский тег данного тега.</li>
<li> <i>XML_N* root( );</i> — Корневой тег данного тега.</li></ul>
<h4><span class="mw-headline" id=".D0.9E.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D1.83.D0.B7.D0.BB.D0.B0_OPC-UA_.28NodeId.29"><span class="mw-headline-number">4.1.6</span> Объект узла OPC-UA (NodeId)</span></h4>
<p><b>Данные:</b><br />
Типы данных (enum — NodeId::Type):
</p>
<ul><li> <i>NodeId::Numeric</i> — номер.</li>
<li> <i>NodeId::String</i> — строка.</li>
<li> <i>NodeId::Guid</i> — глобальный уникальный идентификатор.</li>
<li> <i>NodeId::Opaque</i> — opaque.</li></ul>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>NodeId( uint32_t n, uint16_t ns = 0 );</i> — Численный инициирующий конструктор для числа <i>n</i> в области имён <i>ns</i>.</li>
<li> <i>NodeId( const string &amp;str, uint16_t ns = 0, Type tp = String );</i> — Строковый инициирующий конструктор для строки <i>str</i> в области имён <i>ns</i> с типом <i>tp</i>.</li>
<li> <i>NodeId( const NodeId &amp;node );</i> — Копирующий конструктор объекта.</li>
<li> <i>NodeId( );</i> — Деструктор.</li>
<li> <i>bool operator==( const NodeId &amp;node );</i> — Сравнение объектов.</li>
<li> <i>NodeId &amp;operator=( const NodeId &amp;node );</i> — Копирование объекта.</li>
<li> <i>Type type( ) const;</i> — Тип узла.</li>
<li> <i>bool isNull( ) const;</i> — Узел нулевой — неинициализированный.</li>
<li> <i>uint16_t ns( ) const;</i> — Область имён.</li>
<li> <i>uint32_t numbVal( ) const;</i> — Числовое значение.</li>
<li> <i>string  strVal( ) const;</i> — Строковое значение.</li>
<li> <i>void setNs( uint16_t ns );</i> — Установка области имён в <i>ns</i>.</li>
<li> <i>void setNumbVal( uint32_t n );</i> — Установка числового значения <i>n</i>.</li>
<li> <i>void setStrVal( const string &amp;str, Type tp = String );</i> — Установка строкового значения <i>str</i> с типом <i>tp</i>.</li>
<li> <i>static NodeId fromAddr( const string &amp;strAddr );</i> — Формирование объекта узла из адреса <i>strAddr</i>.</li>
<li> <i>string toAddr( ) const;</i> — Получение адреса объекта узла.</li></ul>
<h4><span class="mw-headline" id=".D0.9A.D0.BE.D1.80.D0.BD.D0.B5.D0.B2.D0.BE.D0.B9_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.BF.D1.80.D0.BE.D1.82.D0.BE.D0.BA.D0.BE.D0.BB.D0.B0_OPC-UA_.28UA.29"><span class="mw-headline-number">4.1.7</span> Корневой объект протокола OPC-UA (UA)</span></h4>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>virtual string lang2CodeSYS( );</i> — Двух-символьный код языка окружения.</li>
<li> <i>virtual void debugMess( const string &amp;mess )</i> — Размещение отладочных сообщений.</li>
<li> <i>virtual uint32_t rcvBufSz( );</i> — Размер буфера приёмника, больше 8192.</li>
<li> <i>virtual uint32_t sndBufSz( );</i> — Размер буфера передатчика, больше 8192.</li>
<li> <i>virtual uint32_t msgMaxSz( );</i> — Максимальный размер сообщения, 0 для отсутствия ограничения.</li>
<li> <i>virtual uint32_t chunkMaxCnt( );</i> — Максимальное количество кусков, 0 для отсутствия ограничения.</li>
<li> <i>static string iErr( const string &amp;buf, int &amp;off );</i> — Чтение ошибки из потока <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static const char *iVal( const string &amp;buf, int &amp;off, char vSz );</i> — Чтение значения размером <i>vSz</i> из потока <i>buf</i> по смещению <i>off</i>, как участок данных.</li>
<li> <i>static int64_t iN( const string &amp;rb, int &amp;off, char vSz );</i> — Чтение знакового целого размером <i>vSz</i> (1, 2, 4, 8) из потока <i>rb</i> по смещению <i>off</i>.</li>
<li> <i>static uint64_t iNu( const string &amp;rb, int &amp;off, char vSz );</i> — Чтение беззнакового целого размером <i>vSz</i> (1, 2, 4, 8) из потока <i>rb</i> по смещению <i>off</i>.</li>
<li> <i>static double iR( const string &amp;rb, int &amp;off, char vSz = 4 );</i> — Чтение вещественного размером <i>vSz</i> (4, 8) из потока <i>rb</i> по смещению <i>off</i>.</li>
<li> <i>static string iS( const string &amp;buf, int &amp;off );</i> — Чтение строки из потока <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static string iSl( const string &amp;buf, int &amp;off, string *locale = NULL );</i> — Чтение локализованной <i>locale</i> строки из потока <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static string iSqlf( const string &amp;buf, int &amp;off, uint16_t *nsIdx = NULL );</i> — Чтение строки с квалификатором <i>nsIdx</i> из потока <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static int64_t iTm( const string &amp;buf, int &amp;off );</i> — Чтение времени из потока <i>buf</i> по смещению <i>off</i>, с преобразованием в эпоху UNIX.</li>
<li> <i>static NodeId iNodeId( const string &amp;buf, int &amp;off );</i> — Чтение идентификатора узла из потока <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static string iVariant( const string &amp;buf, int &amp;off, uint8_t *tp = NULL );</i> — Чтение типа вариант из потока <i>buf</i> по смещению <i>off</i>, возвращает вариант в строковом виде для типа <i>tp</i>.</li>
<li> <i>static void iDataValue( const string &amp;buf, int &amp;off, XML_N &amp;nVal );</i> — Чтение комплексного значения (структура DataValue) в <i>nVal</i> из потока <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static void oN( string &amp;buf, int64_t val, char sz, int off = -1 );</i> — Запись знакового целого <i>val</i> размером <i>sz</i> (1, 2, 4, 8) в поток <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static void oNu( string &amp;buf, uint64_t val, char sz, int off = -1 );</i> — Запись беззнакового целого <i>val</i> размером <i>sz</i> (1, 2, 4, 8) в поток <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static void oR( string &amp;buf, double val, char sz = 4 );</i> — Запись вещественного <i>val</i> размером <i>sz</i> (4, 8) в поток <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static void oS( string &amp;buf, const string &amp;val, int off = -1 );</i> — Запись строки <i>val</i> в поток <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static void oSl( string &amp;buf, const string &amp;val, const string &amp;locale = "" );</i> — Запись локализованной <i>locale</i> строки <i>val</i> в поток <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static void oSqlf( string &amp;buf, const string &amp;val, uint16_t nsIdx = 0 );</i> — Запись строки <i>val</i> с квалификатором <i>nsIdx</i> в поток <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static void oTm( string &amp;buf, int64_t val );</i> — Запись времени <i>val</i> (в эпохе UNIX) в поток <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static void oNodeId( string &amp;buf, const NodeId &amp;val );</i> — Запись идентификатора узла <i>val</i> в поток <i>buf</i> по смещению <i>off</i>.</li>
<li> <i>static void oRef( string &amp;buf, uint32_t resMask, const NodeId &amp;nodeId, const NodeId &amp;refTypeId, bool isForward, const string &amp;name, uint32_t nodeClass, const NodeId &amp;typeDef );</i> — Запись в поток <i>buf</i> описателя обзора (структура ReferenceDescription) для маски результата <i>resMask</i>, узла <i>nodeId</i>, типа ссылки <i>refTypeId</i>, направления <i>isForward</i>, имени <i>name</i>, класса узла <i>nodeClass</i>, типа определения <i>typeDef</i>.</li>
<li> <i>void oDataValue( string &amp;buf, uint8_t eMsk, const string &amp;vl, uint8_t vEMsk = 0, int64_t srcTmStmp = 0 );</i> — Запись комплексного значения (структура DataValue) в поток <i>buf</i> для маски кодирования <i>eMsk</i>, значения <i>vl</i>, маски значения <i>vEMsk</i>, времени источника <i>srcTmStmp</i>.</li>
<li> <i>static string randBytes( int num );</i> — Генерация потока случайных данных в количестве <i>num</i>.</li>
<li> <i>static string certPEM2DER( const string &amp;certPem );</i> — Преобразование сертификата из формата PEM <i>certPem</i> в формат DER.</li>
<li> <i>static string certDER2PEM( const string &amp;certDer );</i> — Преобразование сертификата из формата DER <i>certDer</i> в формат PEM.</li>
<li> <i>static string certThumbprint( const string &amp;certPem );</i> — Получение подписи из сертификата PEM <i>certPem</i>.</li>
<li> <i>static string asymmetricEncrypt( const string &amp;mess, const string &amp;certPem, const string &amp;secPolicy );</i> — асимметричное кодирование потока сообщения <i>mess</i> сертификатом <i>certPem</i> (открытым ключом) для политики <i>secPolicy</i>.</li>
<li> <i>static string asymmetricDecrypt( const string &amp;mess, const string &amp;pvKeyPem, const string &amp;secPolicy );</i> — Асимметричное декодирование потока сообщения <i>mess</i> ключом <i>pvKeyPem</i> для политики <i>secPolicy</i>.</li>
<li> <i>static bool asymmetricVerify( const string &amp;mess, const string &amp;sign, const string &amp;certPem );</i> — Асимметричная верификация подписи <i>sign</i> сообщения <i>mess</i> сертификатом <i>certPem</i>.</li>
<li> <i>static string asymmetricSign( const string &amp;mess, const string &amp;pvPem );</i> — Получение асимметричной подписи закрытым ключом сертификата <i>pvPem</i> для сообщения <i>mess</i>.</li>
<li> <i>static int asymmetricKeyLength( const string &amp;keyCertPem );</i> — Получение длины ключа сертификата <i>keyCertPem</i>.</li>
<li> <i>static string deriveKey( const string &amp;secret, const string &amp;seed, int keyLen );</i> — Извлечение ключа размером <i>keyLen</i> из секрета <i>secret</i> и <i>seed</i>.</li>
<li> <i>static string symmetricEncrypt( const string &amp;mess, const string &amp;keySet, const string &amp;secPolicy );</i> — Симметричное шифрование потока сообщения <i>mess</i> ключом <i>keySet</i> для политики <i>secPolicy</i>.</li>
<li> <i>static string symmetricDecrypt( const string &amp;mess, const string &amp;keySet, const string &amp;secPolicy );</i> — Асимметричное дешифрование потока сообщения <i>mess</i> ключом <i>keySet</i> для политики <i>secPolicy</i>.</li>
<li> <i>static string symmetricSign( const string &amp;mess, const string &amp;keySet, const string &amp;secPolicy );</i> — Получение симметричной подписи ключом <i>keySet</i> для сообщения <i>mess</i> и политики <i>secPolicy</i>.</li></ul>
<h5><span class="mw-headline" id=".D0.92.D0.BA.D0.BB.D1.8E.D1.87.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.BF.D0.B0.D1.80.D0.B0.D0.BC.D0.B5.D1.82.D1.80.D0.BE.D0.B2_.D0.B1.D0.B5.D0.B7.D0.BE.D0.BF.D0.B0.D1.81.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.28SecuritySetting.29"><span class="mw-headline-number">4.1.7.1</span> Включенный объект параметров безопасности (SecuritySetting)</span></h5>
<p><b>Публичные данные:</b>
</p>
<ul><li> <i>string policy</i> — политика безопасности;</li>
<li> <i>MessageSecurityMode messageMode</i> — режим сообщения.</li></ul>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>SecuritySetting( const string &amp;plc, int8_t mMode )</i> — Конструктор объекта с политикой безопасности <i>plc</i> и режимом сообщения <i>mMode</i>.</li>
<li> <i>SecuritySetting( )</i> — Конструктор объекта с политикой безопасности "None" и режимом сообщения <i>MS_None</i>.</li></ul>
<h3><span class="mw-headline" id=".D0.9E.D1.81.D0.BD.D0.BE.D0.B2.D0.BD.D0.BE.D0.B9_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.9A.D0.BB.D0.B8.D0.B5.D0.BD.D1.82.D0.B0_.28Client-.3EUA.29"><span class="mw-headline-number">4.2</span> Основной объект Клиента (Client-&gt;UA)</span></h3>
<p><b>Применение:</b> Непосредственно наследуется пользовательским объектом — Клиент OPC-UA.
</p><p><b>Публичные методы:</b>
</p>
<ul><li> <i>virtual string applicationUri( ) = 0;</i> — URI приложения.</li>
<li> <i>virtual string productUri( ) = 0;</i> — URI продукта.</li>
<li> <i>virtual string applicationName( ) = 0;</i> — Имя приложения.</li>
<li> <i>virtual string sessionName( ) = 0;</i> — Имя сеанса.</li>
<li> <i>virtual string endPoint( ) = 0;</i> — Конечная точка.</li>
<li> <i>virtual string secPolicy( ) = 0;</i> — Политика безопасности.</li>
<li> <i>virtual int secMessMode( ) = 0;</i> — Режим безопасности сообщения.</li>
<li> <i>virtual string cert( ) = 0;</i> — Сертификат.</li>
<li> <i>virtual string pvKey( ) = 0;</i> — Приватный ключ.</li>
<li> <i>virtual string authData( ) = 0;</i> — Данные аутентификации:
<ul><li> "&lt;Empty&gt;" — анонимный;</li>
<li> "{User}\n{Password}" — по пользователю и паролю.</li></ul></li>
<li> <i>virtual uint8_t publishReqsPool( )</i> — Количество <i>Publish</i> запросов обслуживания сервиса публикации, типично <b>2(два)</b>.</li>
<li> <i>virtual string poll( bool byRead = false );</i> — Функция обслуживания сервиса публикации на предмет: читания входного канала на предмет ответов публикации, отслеживания наличия необходимого количества <i>Publish</i> запросов и потери связи из-за отсутствия ответов публикаций в течении определённого времени жизни. Аргументом <i>byRead</i> функция также обеспечивает прямое чтение зарегистрированных элементов мониторингу запросом "Read".</li>
<li> <i>virtual int messIO( const char *oBuf, int oLen, char *iBuf = NULL, int iLen = 0 ) = 0;</i> — обмен сообщениями, передача запроса и ожидание ответа.</li></ul>
<dl><dd> <a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="../../en/files/At.png" width="22" /></a> Смешанный режим запроса и свободного чтения/записи всё ещё решается.</dd></dl>
<ul><li> <i>virtual bool connect( int8_t est = -1 );</i> — Получение статуса подключения, установка подключения для <i>est</i> = 1, отключение для <i>est</i> = 0.</li>
<li> <i>virtual void protIO( XML_N &amp;io );</i> — Обработка запроса к протоколу.</li>
<li> <i>virtual void reqService( XML_N &amp;io );</i> — Комплексный запрос сервиса, который сам отслеживает необходимость вызова вспомогательных запросов открытия/закрытия канала безопасности, открытия/закрытия/активации сеанса и другое.</li></ul>
<p><b>Защищённые атрибуты:</b>
</p>
<ul><li> <i>SClntSess sess;</i> — данные сеанса;</li>
<li> <i>pthread_mutex_t mtxData;</i> — замок доступа к данным.</li></ul>
<h4><span class="mw-headline" id=".D0.9A.D0.BE.D0.BC.D0.BF.D0.BB.D0.B5.D0.BA.D1.81.D0.BD.D1.8B.D0.B9_.D1.81.D0.B5.D0.B0.D0.BD.D1.81_.D0.9A.D0.BB.D0.B8.D0.B5.D0.BD.D1.82.D0.B0_.28Client::SClntSess.29"><span class="mw-headline-number">4.2.1</span> Комплексный сеанс Клиента (Client::SClntSess)</span></h4>
<p><b>Публичные данные:</b>
</p>
<ul><li> <i>uint32_t servRcvBufSz, servSndBufSz, servMsgMaxSz, servChunkMaxCnt;</i> — параметры буфера приёма, передачи, максимального размера сообщения и максимального количества кусков; которые получены от сервера запросом "HELLO";</li>
<li> <i>string endPoint;</i> — конечная точка;</li>
<li> <i>XML_N endPointDscr;</i> — описание активной конечной точки;</li>
<li> <i>uint32_t secChnl, secToken;</i> — индекс и талон канала безопасности;</li>
<li> <i>int secLifeTime;</i> — время жизни канала безопасности;</li>
<li> <i>bool secChnlChanged;</i> — признак изменения канала безопасности для переподключения или повторной активации сеанса;</li>
<li> <i>uint32_t sqNumb, sqReqId, reqHndl;</i> — номер последовательности, порядковый номер запроса и держатель запроса;</li>
<li> <i>string secPolicy;</i> — политика безопасности;</li>
<li> <i>char secMessMode;</i> — режим безопасности сообщения;</li>
<li> <i>int64_t secChnlOpenTm, secLstMessReqTm;</i> — время открытия/обновления канала безопасности и последнего сообщения запроса;</li>
<li> <i>string sesId, authTkId;</i> — идентификатор и талон аутентификации сеанса;</li>
<li> <i>double sesLifeTime;</i> — время жизни сеанса;</li>
<li> <i>string servCert, servNonce, servKey;</i> — сертификат, случайная последовательность и симметричный ключ сервера;</li>
<li> <i>string clKey;</i> — симметричный ключ клиента;</li>
<li> <i>vector&lt;Subscr&gt; mSubScr;</i> — подписки (объект Subscr) клиента;</li>
<li> <i>vector&lt;uint32_t&gt; mPublSeqs;</i> — реестр отправленных запросов публикации по порядковому номеру запроса.</li></ul>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>void clearSecCnl( bool inclEP = false )</i> — Очистка канала безопасности, включая описание конечной точки <i>inclEPdescr</i>.</li>
<li> <i>void clearSess( bool inclSubscr = true )</i> — Очистка сеанса, включая подписки <i>inclSubscr</i>.</li></ul>
<h5><span class="mw-headline" id=".D0.9F.D0.BE.D0.B4.D0.BF.D0.B8.D1.81.D0.BA.D0.B0_.D0.9A.D0.BB.D0.B8.D0.B5.D0.BD.D1.82.D0.B0_.28Client::Subscr.29"><span class="mw-headline-number">4.2.1.1</span> Подписка Клиента (Client::Subscr)</span></h5>
<p><b>Публичные данные:</b>
</p>
<ul><li> <i>bool publEn;</i> — включить публикацию;</li>
<li> <i>double publInterval;</i> — интервал публикации в миллисекундах;</li>
<li> <i>uint32_t subScrId;</i> — идентификатор подписки: &lt;НУЛЬ&gt; — неактивный объект;</li>
<li> <i>uint32_t lifetimeCnt;</i> — счётчик, за которого и отсутствия уведомлений, у клиента удаляется этот объект;</li>
<li> <i>uint32_t maxKeepAliveCnt;</i> — счётчик, за которого необходимо отправлять пустой ответ публикации;</li>
<li> <i>uint32_t maxNtfPerPubl;</i> — максимальное количество уведомлений в одном ответе Публикации;</li>
<li> <i>uint8_t pr;</i> — приоритет;</li>
<li> <i>vector&lt;MonitItem&gt; mItems;</i> — контейнер элементов мониторинга;</li>
<li> <i>vector&lt;uint32_t&gt; mSeqToAcq;</i> — реестр последовательностей ответов Публикации, которые требуют подтверждения ближайшим запросом Публикации;</li>
<li> <i>int64_t lstPublTm;</i> — время последнего ответа публикации;</li>
<li> <i>Client *clnt;</i> — прямая ссылка на объект Клиента.</li></ul>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>Subscr( Client *clnt, double publInterval = 1e3 );</i> — Конструктор Подписки для Клиента <i>clnt</i> с интервалом публикации <i>publInterval</i>.</li>
<li> <i>bool isActivated( );</i> — Возвращает состояние активации подписки.</li>
<li> <i>void activate( bool vl, bool onlyLocally = false );</i> — Активирует (<i>vl</i>=TRUE) или деактивирует (<i>vl</i>=FALSE) Подписку. Активация предусматривает отправку запроса "CreateSubscription" с созданием зарегистрированных, но ещё не активированных элементов мониторинга, сервисным запросом "CreateMonitoredItems". Деактивация предусматривает отправку сервисного запроса "DeleteSubscriptions", если не установлено <i>onlyLocally</i>, с очисткой локальных данных элементов мониторинга.</li>
<li> <i>int monitoredItemAdd( const NodeId &amp;nd, AttrIds aId = AId_Value, MonitoringMode mMode = MM_REPORTING );</i> — Добавляет узел <i>nd</i> на предмет атрибута <i>aId</i>, как элемент мониторинга в режиме мониторинга <i>mMode</i>, и возвращает идентификатор нового элемента. При активном состоянии Подписки также осуществляется сервисный запрос "CreateMonitoredItems". Спеціальное значение "0" узла <i>nd</i> предусматривает осуществление сервисного запроса "CreateMonitoredItems" для всех зарегистрированных и ещё не активированных элементов.</li>
<li> <i>void monitoredItemDel( int32_t mItId, bool localDeactivation = false, bool onlyNoData = false );</i> — Удаляет элемент мониторинга <i>mItId</i>, обозначая его как "СВОБОДНЫЙ" и осуществляя также сервисный вызов "DeleteMonitoredItems" для не <i>localDeactivation</i>. <i>onlyNoData</i> используется вместе с <i>localDeactivation</i> для только маркирования элемента как "НЕТ-ДАННЫХ" после некоторых ошибок подключения. Специальное значение "-1" элемента мониторинга <i>mItId</i> предусматривает осуществление деактивации всех элементов.</li></ul>
<h6><span class="mw-headline" id=".D0.AD.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82_.D0.9C.D0.BE.D0.BD.D0.B8.D1.82.D0.BE.D1.80.D0.B8.D0.BD.D0.B3.D0.B0_.D0.9F.D0.BE.D0.B4.D0.BF.D0.B8.D1.81.D0.BA.D0.B8_.D0.9A.D0.BB.D0.B8.D0.B5.D0.BD.D1.82.D0.B0_.28Client::Subscr::MonitItem.29"><span class="mw-headline-number">4.2.1.1.1</span> Элемент Мониторинга Подписки Клиента (Client::Subscr::MonitItem)</span></h6>
<p><b>Публичные данные:</b>
</p>
<ul><li> <i>MonitoringMode md;</i> — режим мониторинга;</li>
<li> <i>NodeId nd;</i> — целевой узел: &lt;ПУСТО&gt; — свободный элемент мониторинга;</li>
<li> <i>uint32_t aid;</i> — ИД атрибута узла;</li>
<li> <i>double smplItv;</i> — интервал измерения;</li>
<li> <i>uint32_t qSz;</i> — размер очереди;</li>
<li> <i>bool active;</i> — активность элемента;</li>
<li> <i>uint32_t st;</i> — код состояния элемента;</li>
<li> <i>XML_N val;</i> — контекст значения элемента: наличие атрибута "nodata" означает отсутствие данных.</li></ul>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>MonitItem( NodeId nd, uint32_t aid, MonitoringMode md = MM_REPORTING );</i> — Конструктор Элемента Мониторинга для узла <i>nd</i> и его атрибута <i>aid</i> в режиме мониторинга <i>md</i>.</li></ul>
<h3><span class="mw-headline" id=".D0.9E.D1.81.D0.BD.D0.BE.D0.B2.D0.BD.D0.BE.D0.B9_.D0.BE.D0.B1.D1.8A.D0.B5.D0.BA.D1.82_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server-.3EUA.29"><span class="mw-headline-number">4.3</span> Основной объект Сервера (Server-&gt;UA)</span></h3>
<p><b>Применение:</b> Прямо наследуется пользовательским объектом — Сервер OPC-UA.
</p><p><b>Публичные методы:</b>
</p>
<ul><li> <i>virtual bool debug( );</i> — Активирована отладка.</li>
<li> <i>virtual string applicationUri( ) = 0;</i> — URI приложения.</li>
<li> <i>virtual string productUri( ) = 0;</i> — URI продукта.</li>
<li> <i>virtual string applicationName( ) = 0;</i> — Имя приложения.</li>
<li> <i>virtual uint32_t clientRcvBufSz( const string &amp;inPrtId ) = 0;</i> — Размер буфера приёмника, полученный от клиента, для подключения <i>inPrtId</i>.</li>
<li> <i>virtual uint32_t clientSndBufSz( const string &amp;inPrtId ) = 0;</i> — Размер буфера передатчика, полученный от клиента, для подключения <i>inPrtId</i>.</li>
<li> <i>virtual uint32_t clientMsgMaxSz( const string &amp;inPrtId ) = 0;</i> — Максимальный размер сообщения, полученный от клиента, для подключения <i>inPrtId</i>.</li>
<li> <i>virtual uint32_t clientChunkMaxCnt( const string &amp;inPrtId ) = 0;</i> — Максимальное количество кусков, полученное от клиента, для подключения <i>inPrtId</i>.</li>
<li> <i>virtual void discoveryUrls( vector&lt;string&gt; &amp;ls ) = 0;</i> — URLы серверов обзора в <i>ls</i>.</li>
<li> <i>virtual bool inReq( string &amp;request, const string &amp;inPrtId, string *answ = NULL );</i> — Обработчик входящих запросов <i>request</i> экземпляра протокола <i>inPrtId</i> и ответа в <i>answ</i>.</li>
<li> <i>virtual int writeToClient( const string &amp;threadId, const string &amp;data ) = 0;</i> — Прямая запись подключенному клиенту.</li>
<li> <i>virtual string clientAddr( const string &amp;threadId ) = 0;</i> — Адрес клиента.</li>
<li> <i>virtual void clientRcvBufSzSet( const string &amp;inPrtId, uint32_t vl ) = 0;</i> — Установка размера буфера приёмника, полученного от клиента, в значение <i>vl</i> для подключения <i>inPrtId</i>.</li>
<li> <i>virtual void clientSndBufSzSet( const string &amp;inPrtId, uint32_t vl ) = 0;</i> — Установка размера буфера передатчика, полученного от клиента, в значение <i>vl</i> для подключения <i>inPrtId</i>.</li>
<li> <i>virtual void clientMsgMaxSzSet( const string &amp;inPrtId, uint32_t vl ) = 0;</i> — Установка максимального размера сообщения, полученного от клиента, в значение <i>vl</i> для подключения <i>inPrtId</i>.</li>
<li> <i>virtual void clientChunkMaxCntSet( const string &amp;inPrtId, uint32_t vl ) = 0;</i> — Установка максимального количества кусков, полученного от клиента, в значение <i>vl</i> для подключения <i>inPrtId</i>.</li>
<li> <i>int chnlSet( int cid, const string &amp;ep, int32_t lifeTm = 0, const string&amp; clCert = "", const string &amp;secPolicy = "None", char secMessMode = 1, const string &amp;clAddr = "", uint32_t seqN = 1 );</i> — Установка канала безопасности с идентификатором <i>cid</i> (ненулевое значение для обновления) для конечной точки <i>ep</i>, времени жизни <i>lifeTm</i>, клиентского сертификата <i>clCert</i>, политики безопасности <i>secPolicy</i>, режима безопасности сообщения <i>secMessMode</i>, адреса клиента <i>clAddr</i>, номера последовательности пакета <i>seqN</i>.</li>
<li> <i>void chnlClose( int cid );</i> — Закрытие канала безопасности <i>cid</i>.</li>
<li> <i>SecCnl chnlGet( int cid ); SecCnl &amp;chnlGet_( int cid );</i> — Получение копии и доступа к объекту канала безопасности <i>cid</i>.</li>
<li> <i>void chnlSecSet( int cid, const string &amp;servKey, const string &amp;clKey );</i> — Установка для канала безопасности <i>cid</i> серверного <i>servKey</i> и клиентского <i>clKey</i> симметричных ключей.</li>
<li> <i>static string mkError( uint32_t errId, const string &amp;err = "" );</i> — Формирование ошибки с идентификатором <i>errId</i> и сообщением <i>err</i>.</li></ul>
<p><b>Защищённые методы:</b>
</p>
<ul><li> <i>virtual void epEnList( vector&lt;string&gt; &amp;ls ) = 0;</i> — Обработчик запроса перечня конечных узлов.</li>
<li> <i>virtual EP *epEnAt( const string &amp;ep ) = 0;</i> — Обработчик запроса объекта конечной точки.</li></ul>
<p><b>Защищённые атрибуты:</b>
</p>
<ul><li> <i>pthread_mutex_t mtxData;</i> — замок доступа к данным.</li></ul>
<h4><span class="mw-headline" id=".D0.9A.D0.B0.D0.BD.D0.B0.D0.BB_.D0.91.D0.B5.D0.B7.D0.BE.D0.BF.D0.B0.D1.81.D0.BD.D0.BE.D1.81.D1.82.D0.B8_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::SecCnl.29"><span class="mw-headline-number">4.3.1</span> Канал Безопасности Сервера (Server::SecCnl)</span></h4>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>SecCnl( const string &amp;ep, uint32_t tokenId, int32_t lifeTm, const string &amp;clCert, const string &amp;secPolicy, char secMessMode, const string &amp;clAddr, uint32_t secN );</i> — Конструктор объекта Канала Безопасности для: конечной точки <i>ep</i>, талона безопасности <i>tokenId</i>, времени жизни <i>lifeTm</i>, клиентского сертификата <i>clCert</i>, политики безопасности <i>secPolicy</i>, режима безопасности сообщений <i>secMessMode</i>, адреса клиента <i>clAddr</i>, номера последовательности создания канала безопасности <i>secN</i>.</li></ul>
<p><b>Публичные атрибуты:</b>
</p>
<ul><li> <i>string endPoint;</i> — конечная точка;</li>
<li> <i>string secPolicy;</i> — политика безопасности;</li>
<li> <i>char secMessMode;</i> — режим безопасности сообщения;</li>
<li> <i>int64_t tCreate;</i> — время создание;</li>
<li> <i>int32_t tLife;</i> — время жизни;</li>
<li> <i>uint32_t tokenId, tokenIdPrev;</i> — текущий и предыдущий идентификаторы талона;</li>
<li> <i>string clCert, clAddr, clKey;</i> — сертификат, адрес и симметричный ключ клиента;</li>
<li> <i>string servKey;</i> — симметричный ключ сервера;</li>
<li> <i>uint32_t servSeqN, clSeqN, reqId;</i> — текущий номер последовательности пакета сервера, клиента и запроса;</li>
<li> <i>int chCnt;</i> — счётчик кусков пакета в аккумуляции;</li>
<li> <i>string chB;</i> — аккумуляция пакета из кусков.</li></ul>
<h4><span class="mw-headline" id=".D0.A1.D0.B5.D0.B0.D0.BD.D1.81_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::Sess.29"><span class="mw-headline-number">4.3.2</span> Сеанс Сервера (Server::Sess)</span></h4>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>Sess( const string &amp;name, double tInact );</i> — Конструктор объекта Сеанса с именем <i>name</i> и таймаутом неактивности <i>tInact</i>.</li>
<li> <i>bool isSecCnlActive( EP *ep );</i> — Возвращает состояние активности Канала Безопасности, связанного с сеансом.</li></ul>
<p><b>Публичные атрибуты:</b>
</p>
<ul><li> <i>string name, inPrtId;</i> — имя и идентификатор входного протокола;</li>
<li> <i>uint32_t secCnl;</i> — канал безопасности, связанный с сеансом;</li>
<li> <i>double tInact;</i> — время неактивности;</li>
<li> <i>int64_t tAccess;</i> — время доступа;</li>
<li> <i>string servNonce;</i> — случайная последовательность сервера;</li>
<li> <i>map&lt;string, ContPoint&gt; cntPnts;</i> — точки продолжения запроса обзора;</li>
<li> <i>deque&lt;string&gt; publishReqs;</i> — перечень запросов публикации.</li></ul>
<h5><span class="mw-headline" id=".D0.A2.D0.BE.D1.87.D0.BA.D0.B0_.D0.BF.D1.80.D0.BE.D0.B4.D0.BE.D0.BB.D0.B6.D0.B5.D0.BD.D0.B8.D1.8F_.D0.BE.D0.B1.D0.B7.D0.BE.D1.80.D0.B0_.D0.A1.D0.B5.D0.B0.D0.BD.D1.81.D0.B0_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::Sess::ContPoint.29"><span class="mw-headline-number">4.3.2.1</span> Точка продолжения обзора Сеанса Сервера (Server::Sess::ContPoint)</span></h5>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>ContPoint( const string &amp;brNode, const string &amp;lstNode, uint32_t brDir, uint32_t refPerN, const string &amp;refTypeId, uint32_t nClassMask, uint32_t resMask )</i> — Конструктор объекта для узла ветви продолжения обзора <i>brNode</i>, узла списка <i>lstNode</i>, направления обзора <i>brDir</i>, числа ссылок на узел <i>refPerN</i>, идентификатора ссылки <i>refTypeId</i>, маски класса узла <i>nClassMask</i> и маски результата <i>resMask</i>.</li>
<li> <i>bool empty( ) const;</i> — Точка продолжения пуста.</li></ul>
<p><b>Публичные атрибуты:</b>
</p>
<ul><li> <i>uint32_t brDir, refPerN, nClassMask, resMask;</i> — направление обзора, число ссылок на узел, маска класса узла, маска результата;</li>
<li> <i>string brNode, lstNode, refTypeId;</i> — ветвь узлов, список узла и идентификатор типа ссылки.</li></ul>
<h4><span class="mw-headline" id=".D0.9F.D0.BE.D0.B4.D0.BF.D0.B8.D1.81.D0.BA.D0.B0_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::Subscr.29"><span class="mw-headline-number">4.3.3</span> Подписка Сервера (Server::Subscr)</span></h4>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>Subscr copy( bool noWorkData = true );</i> — Копия объекта подписки, без рабочих данных для <i>noWorkData</i>.</li>
<li> <i>SubScrSt setState( SubScrSt st = SS_CUR );</i> — Возврат текущего состояния и установка в <i>st</i>.</li></ul>
<p><b>Публичные атрибуты:</b>
</p>
<ul><li> <i>SubScrSt st;</i> — статус подписки;</li>
<li> <i>int sess;</i> — сеанс подписки;</li>
<li> <i>bool publEn;</i> — включение публикации;</li>
<li> <i>bool toInit;</i> — признак инициации подписки — отправка первого-пустого пакета ответа публикации;</li>
<li> <i>double publInterv;</i> — интервал публикации, миллисекунд;</li>
<li> <i>uint32_t seqN;</i> — номер последовательности для ответов, заворачивается через 1, не инкрементируется на KeepAlive сообщениях;</li>
<li> <i>uint32_t pubCntr, pubCntr_;</i> — счётчик отправки ответов публикации для выявления активности;</li>
<li> <i>uint32_t lifetimeCnt, wLT;</i> — счётчик, по исчерпанию которого в течении отсутствия уведомления от клиента необходимо удалять данный объект;</li>
<li> <i>uint32_t maxKeepAliveCnt, wKA;</i> — счётчик, по исчерпанию которого нужно отправлять пустой ответ публикации и устанавливать <i>StatusChangeNotification</i> в <b>Bad_Timeout</b>;</li>
<li> <i>uint32_t maxNtfPerPubl;</i> — максимальное количество уведомлений на один ответ публикации;</li>
<li> <i>uint8_t pr;</i> — приоритет;</li>
<li> <i>vector&lt;MonitItem&gt; mItems;</i> — перечень элементов мониторинга;</li>
<li> <i>deque&lt;string&gt; retrQueue;</i> — очередь перепосылки; используется запросом перепосылки "RePublish"; очищается на глубину согласно <i>KeepAlive</i> или прямым запросом публикации в наборе подтверждения.</li></ul>
<h5><span class="mw-headline" id=".D0.AD.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82_.D0.9C.D0.BE.D0.BD.D0.B8.D1.82.D0.BE.D1.80.D0.B8.D0.BD.D0.B3.D0.B0_.D0.9F.D0.BE.D0.B4.D0.BF.D0.B8.D1.81.D0.BA.D0.B8_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::Subscr::MonitItem.29"><span class="mw-headline-number">4.3.3.1</span> Элемент Мониторинга Подписки Сервера (Server::Subscr::MonitItem)</span></h5>
<p><b>Публичные атрибуты:</b>
</p>
<ul><li> <i>MonitoringMode md;</i> — режим мониторинга;</li>
<li> <i>NodeId nd;</i> — целевой узел;</li>
<li> <i>uint32_t aid;</i> — идентификатор атрибута узла;</li>
<li> <i>TimestampsToReturn tmToRet;</i> — метки времени для возврата;</li>
<li> <i>double smplItv;</i> — интервал измерений;</li>
<li> <i>uint32_t qSz;</i> — размер очереди;</li>
<li> <i>bool dO;</i> — отбрасывать старые;</li>
<li> <i>uint32_t cH;</i> — указатель клиента;</li>
<li> <i>XML_N fltr;</i> — фильтр;</li>
<li> <i>int vTp;</i> — тип значений;</li>
<li> <i>int64_t dtTm;</i> — время последнего значения;</li>
<li> <i>deque&lt;Val&gt; vQueue;</i> — очередь значений.</li></ul>
<h6><span class="mw-headline" id=".D0.AD.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82_.D0.B7.D0.BD.D0.B0.D1.87.D0.B5.D0.BD.D0.B8.D1.8F_.D0.AD.D0.BB.D0.B5.D0.BC.D0.B5.D0.BD.D1.82.D0.B0_.D0.9C.D0.BE.D0.BD.D0.B8.D1.82.D0.BE.D1.80.D0.B8.D0.BD.D0.B3.D0.B0_.D0.9F.D0.BE.D0.B4.D0.BF.D0.B8.D1.81.D0.BA.D0.B8_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::Subscr::MonitItem::Val.29"><span class="mw-headline-number">4.3.3.1.1</span> Элемент значения Элемента Мониторинга Подписки Сервера (Server::Subscr::MonitItem::Val)</span></h6>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>Val( const string &amp;vl, int64_t tm )</i> — Конструктор объекта значения <i>vl</i> на время <i>tm</i>.</li></ul>
<p><b>Публичные атрибуты:</b>
</p>
<ul><li> <i>string vl;</i> — значение;</li>
<li> <i>int64_t tm;</i> — время значения;</li>
<li> <i>uint32_t st;</i> — код статуса.</li></ul>
<h4><span class="mw-headline" id=".D0.9A.D0.BE.D0.BD.D0.B5.D1.87.D0.BD.D0.B0.D1.8F_.D0.A2.D0.BE.D1.87.D0.BA.D0.B0_.D0.A1.D0.B5.D1.80.D0.B2.D0.B5.D1.80.D0.B0_.28Server::EP.29"><span class="mw-headline-number">4.3.4</span> Конечная Точка Сервера (Server::EP)</span></h4>
<p><b>Публичные методы:</b>
</p>
<ul><li> <i>EP( Server *serv );</i> — Конструктор объекта Конечной Точки к серверу <i>serv</i>.</li>
<li> <i>virtual string id( ) = 0;</i> — Идентификатор.</li>
<li> <i>virtual string url( ) = 0;</i> — URL.</li>
<li> <i>virtual string cert( ) = 0;</i> — Сертификат, текстом формата PEM.</li>
<li> <i>virtual string pvKey( ) = 0;</i> — Приватный ключ, текстом формата PEM.</li>
<li> <i>virtual double subscrProcPer( ) = 0;</i> — Общий минимальный период цикла публикации и обработки его данных.</li>
<li> <i>virtual uint32_t limSubScr( );</i> — Ограничение на количество подписок.</li>
<li> <i>virtual uint32_t limMonitItms( );</i> — Ограничение количества элементов мониторинга.</li>
<li> <i>virtual uint32_t limRetrQueueTm( );</i> — Ограничение времени на глубину очереди повторной передачи.</li>
<li> <i>bool enableStat( );</i> — Состояние "Включено".</li>
<li> <i>virtual void setEnable( bool vl );</i> — Включить.</li>
<li> <i>virtual void setPublish( const string &amp;inPrtId );</i> — Инициировать условия вызова <i>publishCall()</i> во входном потоке — циклический вызов протокола входного транспорта и связывание с Конечной Точкой.</li>
<li> <i>void subScrCycle( unsigned cntr );</i> — Функция вызова цикла обработки подписок на шаге <i>cntr</i> для ответа в функции <i>publishCall()</i> входного потока.</li>
<li> <i>int secN( );</i> — Количество политик безопасности.</li>
<li> <i>string secPolicy( int sec );</i> — Получение описания политики безопасности <i>sec</i>.</li>
<li> <i>MessageSecurityMode secMessageMode( int sec );</i> — Режим безопасности сообщения политики безопасности <i>sec</i>.</li>
<li> <i>unsigned sessN( );</i> — Количество сеансов.</li>
<li> <i>int sessCreate( const string &amp;name, double tInact );</i> — Создание сеанса с именем <i>name</i> и таймаутом неактивности <i>tInact</i>, возвращает идентификатор сеанса.</li>
<li> <i>void sessServNonceSet( int sid, const string &amp;servNonce );</i> — Установка случайной последовательности сервера в <i>servNonce</i> для сеанса <i>sid</i>.</li>
<li> <i>virtual uint32_t sessActivate( int sid, uint32_t secCnl, bool check = false, const string &amp;inPrtId = "", const XML_N &amp;identTkn = XML_N() );</i> — Активация сеанса <i>sid</i> для связывания с каналом безопасности <i>secCnl</i>, с проверкой <i>check</i> на возможность-необходимость переназначения после разрыва предыдущего канала безопасности, возвращает ошибку (0 — ошибки нет).</li>
<li> <i>void sessClose( int sid );</i> — Закрытие сеанса <i>sid</i>.</li>
<li> <i>Sess sessGet( int sid );</i> — Получение экземпляра объекта сеанса для <i>sid</i>.</li>
<li> <i>Sess::ContPoint sessCpGet( int sid, const string &amp;cpId );</i> — Получение точки продолжения обзора <i>cpId</i> сеанса <i>sid</i>.</li>
<li> <i>void sessCpSet( int sid, const string &amp;cpId, const Sess::ContPoint &amp;cp = Sess::ContPoint() );</i> — Установка точки продолжения обзора <i>cp</i> для сеанса <i>sid</i> и идентификатора <i>cpId</i>.</li>
<li> <i>uint32_t subscrSet( uint32_t ssId, SubScrSt st, bool en = false, int sess = -1, double publInterval = 0, uint32_t lifetimeCnt = 0, uint32_t maxKeepAliveCnt = 0, uint32_t maxNotePerPubl = OpcUa_NPosID, int pr = -1 );</i> — Установка-создание подписки <i>ssId</i> для: состояния <i>st</i>, включения публикации <i>en</i>, сеанса <i>sess</i>, интервала публикации <i>publInterv</i>, счётчика времени жизни <i>lifetimeCnt</i>, счётчика сохранения "живым" <i>maxKeepAliveCnt</i>, максимального количества уведомлений в одной публикации <i>maxNotePerPubl</i>, приоритета <i>pr</i>; возвращает идентификатор подписки.</li>
<li> <i>Subscr subscrGet( uint32_t ssId, bool noWorkData = true );</i> — Получение экземпляра подписки <i>ssId</i>, без рабочих данных <i>noWorkData</i>.</li>
<li> <i>uint32_t mItSet( uint32_t ssId, uint32_t mItId, MonitoringMode md = MM_CUR, const NodeId &amp;nd = NodeId(), uint32_t aid = OpcUa_NPosID, TimestampsToReturn tmToRet = TimestampsToReturn(-1), double smplItv = -2, uint32_t qSz = OpcUa_NPosID, int8_t dO = -1, uint32_t cH = OpcUa_NPosID, XML_N *fltr = NULL );</i> — Установка-создание элемента мониторинга <i>mItId</i> сеанса <i>ssId</i> для: режима <i>md</i>, узла <i>nd</i>, атрибута <i>aid</i>, профиля метки времени <i>tmToRet</i>, интервала измерения <i>smplItv</i>, размера очереди <i>qSz</i>, отброса старых <i>dO</i>, указателя клиента <i>cH</i>, фильтра <i>fltr</i>; возвращает идентификатор подписки.</li>
<li> <i>Subscr::MonitItem mItGet( uint32_t ssId, uint32_t mItId );</i> — Получение экземпляра элемента мониторинга <i>mItId</i> для сеанса <i>ssId</i>.</li>
<li> <i>virtual uint32_t reqData( int reqTp, XML_N &amp;req );</i> — Обработчик запроса данных — запрос к дереву узлов сервера.</li></ul>
<p><b>Защищённые методы:</b>
</p>
<ul><li> <i>XML_N *nodeReg( const NodeId &amp;parent, const NodeId &amp;ndId, const string &amp;name, int ndClass, const NodeId &amp;refTypeId, const NodeId &amp;typeDef = 0 );</i> — Регистрация узла <i>ndId</i> в дереве узлов сервера для: родителя <i>parent</i>, класса узла <i>ndClass</i>, идентификатора типа ссылки <i>refTypeId</i> и типа определения <i>typeDef</i>.</li>
<li> <i>Sess *sessGet_( int sid );</i> — Получение ссылки на объект сеанса <i>sid</i>, доступ не защищён захватом ресурса.</li></ul>
<p><b>Защищённые атрибуты:</b>
</p>
<ul><li> <i>char mEn;</i> — состояние "Включен";</li>
<li> <i>uint64_t cntReq;</i> — счётчик запросов;</li>
<li> <i>vector&lt;SecuritySetting&gt; mSec;</i> — перечень политик безопасности конечного узла;</li>
<li> <i>vector&lt;Sess&gt; mSess;</i> — перечень открытых сеансов;</li>
<li> <i>vector&lt;Subscr&gt; mSubScr;</i> — перечень подписок;</li>
<li> <i>XML_N objTree;</i> — дерево узлов сервера;</li>
<li> <i>map&lt;string, XML_N*&gt; ndMap;</i> — карта ссылок на узлы дерева;</li>
<li> <i>pthread_mutex_t&gt; mtxData;</i> — мютекс блокирования многопоточного доступа;</li>
<li> <i>Server *serv;</i> — ссылка на сервер — контейнер объекта конечной точки.</li></ul>
<h2><span class="mw-headline" id=".D0.9F.D1.80.D0.B8.D0.B2.D0.B0.D1.82.D0.BD.D1.8B.D0.B5_.D0.BA.D0.BB.D1.8E.D1.87.D0.B8_.D0.B8_.D1.81.D0.B5.D1.80.D1.82.D0.B8.D1.84.D0.B8.D0.BA.D0.B0.D1.82.D1.8B"><span class="mw-headline-number">5</span> Приватные ключи и сертификаты</span></h2>
<p>Для работы клиентской и серверной-протокольной части OPC-UA необходимо создание и помещение приватного ключа и сертификата в конфигурацию объекта клиента и сервера. В общем случае достаточно создания обычного самоподписанного сертификата и приватного ключа без пароля, однако, для исключения предупредительных сообщений, необходимо добавить ряд служебных полей в сертификат. Это можно сделать взяв <a class="external" href="http://oscada.org/wiki/File:OPC-UA_openssl.cnf" title="File:OPC-UA openssl.cnf">файл конфигурации создания сертификата</a> и выполнить следующую процедуру:
</p>
<pre style="white-space: pre-wrap;">
# Создание приватного ключа:
$ openssl genrsa -out key_c.pem -des3 -rand /var/log/messages 2048
# Создание приватного ключа без пароля:
$ openssl rsa -in key_c.pem -out key_c1.pem
# Создание самоподписанного сертификата:
$ openssl req -x509 -new -key key_c.pem -out cert_c.pem -config ./OPC-UA_openssl.cnf -days 3650
# Поместить содержимое файла key_c1.pem в поле приватного ключа и cert_c.pem в поле сертификата!
</pre>
<h2><span class="mw-headline" id=".D0.97.D0.B0.D0.BC.D0.B5.D1.87.D0.B0.D0.BD.D0.B8.D1.8F"><span class="mw-headline-number">6</span> Замечания</span></h2>
<p>В процессе реализации модулей поддержки OPC-UA был обнаружен ряд несоответствий официального SDK со спецификацией OPC-UA:
</p>
<ul><li> OPC-UA Part 6 на странице 27 содержит изображение процесса рукопожатия для установления безопасного канала. Пакет создания сессии, исходя из этого процесса, подписывается клиентским симметричным ключём, а кодируется серверным. На самом деле и подпись и шифрование осуществляется серверным ключём.</li>
<li> OPC-UA Part 4 на странице 141 содержит описание структуры данных подписи, где первыми идут данные подписи, а затем строка алгоритма. На самом деле реализован обратный порядок.</li></ul>
<h2><span class="mw-headline" id=".D0.A2.D0.B0.D0.B1.D0.BB.D0.B8.D1.86.D0.B0_.D1.81.D0.BE.D0.B2.D0.BC.D0.B5.D1.81.D1.82.D0.B8.D0.BC.D0.BE.D1.81.D1.82.D0.B8_.D1.81_.D1.80.D0.B5.D0.B0.D0.BB.D0.B8.D0.B7.D0.B0.D1.86.D0.B8.D1.8F.D0.BC.D0.B8_OPC-UA_.D0.B4.D1.80.D1.83.D0.B3.D0.B8.D1.85_.D0.BF.D1.80.D0.BE.D0.B8.D0.B7.D0.B2.D0.BE.D0.B4.D0.B8.D1.82.D0.B5.D0.BB.D0.B5.D0.B9"><span class="mw-headline-number">7</span> <span id="TableOfCompat" title="#TableOfCompat">Таблица совместимости с реализациями OPC-UA других производителей</span></span></h2>
<table class="wikitable">

<tr>
<th> ПО </th>
<th> Ядро </th>
<th> Обзор </th>
<th> Чтение </th>
<th> Запись </th>
<th> Публикация </th>
<th> Замечания
</th></tr>
<tr>
<td colspan="7"> <i>OpenSCADA parts</i>
</td></tr>
<tr>
<td> OpenSCADA OPC-UA Client (libOPC_UA client part) </td>
<td> + </td>
<td> + </td>
<td> + </td>
<td> + </td>
<td> + </td>
<td> IO requests by XML implemented: HEL (HELLO), OPN (OpenSecureChannel), CLO (CloseSecureChannel), FindServers, GetEndpoints, CreateSession, ActivateSession, CloseSession, Read, Write, Browse, CreateSubscription, DeleteSubscriptions, CreateMonitoredItems, DeleteMonitoredItems, Publish, Poll (the special empty request of checking the input channel). Chunks implemented.
</td></tr>
<tr>
<td> OpenSCADA OPC-UA Server (libOPC_UA server part) </td>
<td> + </td>
<td> + </td>
<td> + </td>
<td> + </td>
<td> + </td>
<td> The requests implemented: HELF, OPNF, CLOF, MSGF: FindServers, GetEndpoints, CreateSession, ActivateSession, CloseSession, CreateSubscription, ModifySubscription, DeleteSubscriptions, MonitoredItems, ModifyMonitoredItems, SetMonitoringMode, DeleteMonitoredItems, SetPublishingMode, TranslateBrowsePathsToNodeIds, RegisterNodes, UnregisterNodes, Browse, BrowseNext, Read,  Write, Publish, Republish. Chunks implemented.
</td></tr>
<tr>
<td colspan="7"> <i>Clients</i>
</td></tr>
<tr>
<td> UAExpert 1.2, 1.3 </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td>
</td></tr>
<tr>
<td> Indusoft web studio 7.1 </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td>
</td></tr>
<tr>
<td> Iconics genesis64 10.8 </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td>
</td></tr>
<tr>
<td> Insat masterscada 3.7 </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td>
</td></tr>
<tr>
<td> <a class="external text" href="https://opcfoundation.org/developer-tools/developer-kits-unified-architecture/sample-applications" rel="nofollow noreferrer noopener" target="_blank">Sample Applications of Unified Architecture</a> </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> <span style="color: blue">Not tested</span> </td>
<td> Pass </td>
<td>
</td></tr>
<tr>
<td> Wonderware System Platform </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> <span style="color: blue">Not tested</span> </td>
<td> Pass </td>
<td> Result mask processing fix into the service "Browse" for nodes of OpenSCADA data model. ...
</td></tr>
<tr>
<td> Kepware </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Specific value types OpcUa_IntAuto and OpcUa_UIntAuto was added for adaptive integer type selection, mostly for provide integer not fixed as int64. Time stamp was removed from "Write" package but the client tell 0x80730000(OpcUa_BadWriteNotSupported)
</td></tr>
<tr>
<td> UAExpert 1.4 </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Packages sequence number split from it request and set self managing.
</td></tr>
<tr>
<td> UAExpert 1.5 </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> The Server code cleaned from inconsistency of the data types and the types appended for declaration own OpenSCADA types OpcUa_IntAuto and OpcUa_UIntAuto.
</td></tr>
<tr>
<td colspan="7"> <i>Servers</i>
</td></tr>
<tr>
<td> IgnitionOPC_UA </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> <span style="color: blue">Not tested</span> </td>
<td> <span style="color: blue">Not tested</span> </td>
<td>
</td></tr>
<tr>
<td> B&amp;R Embedded OPC-UA Server </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td> Pass </td>
<td>
<ul><li> the authenticate process fixed by the server provides self specific identifiers to its. The string of bytes wrong interpretation fixed;</li>
<li> 2021.05: has limits on direct reading by the service request "Read", so that was an initiator of implementing the service request "Publish" and Chunks for the Client part, UAExpert 1.5 adaption, significant refactoring and the document complete revision.</li></ul>
</td></tr></table>
<p><br />
</p>
<h2><span class="mw-headline" id=".D0.A1.D1.81.D1.8B.D0.BB.D0.BA.D0.B8"><span class="mw-headline-number">8</span> Ссылки</span></h2>
<ul><li> <a class="external" href="http://oscada.org/wiki/File:OPC-UA_libOPCUA_class.odg" title="File:OPC-UA libOPCUA class.odg">Диаграмма: Статическая диаграмма классов библиотеки libOPC_UA.</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:OPC-UA_openssl.cnf" title="File:OPC-UA openssl.cnf">Файл конфигурации создания сертификата для OPC-UA.</a></li></ul>






</div><table style="border-top: dotted 2px #999999; margin-top: 20pt; color: gray;" width="100%"><tr><td style="text-align: left;" width="40%"><a href="http://oscada.org/wiki/Modules/OPC_UA/ru">Modules/OPC_UA/ru</a> - <a href="http://oscada.org/en/main/about-the-project/licenses/">GFDL</a></td><td style="text-align: center;">September 2021</td><td style="text-align: right;" width="40%">OpenSCADA 1+r2769</td></tr></table></body>
</html>