<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html class="client-nojs" dir="ltr" lang="en">
<head>
<meta charset="UTF-8" />
<title>Documents/API - OpenSCADAWiki</title>
<meta content="MediaWiki 1.26.4" name="generator" />
<link href="https://www.gnu.org/copyleft/fdl.html" rel="copyright" />
<link href="files/doc.css" rel="stylesheet" /></head>
<body><div class="floatright"><a href="index.html"><img alt="OpenSCADA" src="../en/files/index.png" /></a></div><div id="mw_header">
			<div class="mw-indicators">
</div>
			<h1 id="firstHeading" lang="en">Documents/API</h1>
		</div><div class="mw-content-ltr" dir="ltr" id="mw-content-text" lang="en"><div class="mw-pt-languages" dir="ltr" lang="en"><div class="mw-pt-languages-list autonym"><span class="mw-pt-languages-ui mw-pt-languages-selected mw-pt-progress mw-pt-progress--complete">English</span>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--stub" href="../ru/API.html" title="Документы/API (2% translated)">mRussian</a>&nbsp;• ‎<a class="mw-pt-progress mw-pt-progress--stub" href="../uk/API.html" title="Документи/API (2% translated)">Українська</a></div></div>
<div style="float:right; border:1px solid gray; width:300px; padding:2px; margin-left: 10pt; margin-bottom: 10pt;">
<ul><li> <b>Author:</b> <a class="external" href="http://oscada.org/wiki/User:RomanSavochenko" title="User:RomanSavochenko">Roman Savochenko</a><br />&nbsp;&nbsp;<font size="-2"><i>Maxim Lysenko (2012) — the page initial translation</i></font></li>
<li> <b>Initially created:</b> in <a class="external text" href="http://wiki.oscada.org/HomePageEn/Doc/API" rel="nofollow noreferrer noopener" target="_blank">the old Wiki</a> </li></ul>
</div>
<p>This page describes an application programming interface (API) of OpenSCADA.
</p><p>OpenSCADA is a project of the open SCADA-system based on the modular principle. The document contains exhaustive information of the internal architecture of the OpenSCADA objects. Additionally there is provided of information about the object's attributes and methods.
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="files/At.png" width="22" /></a> This document is intended for programmers wishing to understand the architecture of OpenSCADA and to develop extensions for it. The document is not intended mostly for users and integrators of OpenSCADA, although some things can be useful to them to understand the work.
</p><p>For the possibility of understanding the document it is necessary for you to know the concept of Object Oriented Programming (OOP) and Universal Modelling Language (UML), and for the possibility of studying the source code of the project it is required the knowledge of the programming language C++. Additionally the document contains of mentioning of the following technologies: relational databases, XML.
</p>
<div class="toc" id="toc"><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Internal_structure"><span class="tocnumber">1</span> <span class="toctext">Internal structure</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Overall_structure_of_the_program_.E2.80.94_modularity"><span class="tocnumber">2</span> <span class="toctext">Overall structure of the program — modularity</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#The_root_object_system_.28TSYS.29"><span class="tocnumber">2.1</span> <span class="toctext"><span>The root object system (TSYS)</span></span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Object_of_the_messages_system_.28TMess.29"><span class="tocnumber">2.2</span> <span class="toctext"><span>Object of the messages system (TMess)</span></span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Object_subsystem_.28TSubSYS.29"><span class="tocnumber">2.3</span> <span class="toctext"><span>Object subsystem (TSubSYS)</span></span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Object_Module_.28TModule.29"><span class="tocnumber">2.4</span> <span class="toctext"><span>Object Module (TModule)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="#Subsystem_.22DB.22"><span class="tocnumber">3</span> <span class="toctext"><span>Subsystem "DB"</span></span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Object_of_subsystem_.22Database.22_.28TBDS.29"><span class="tocnumber">3.1</span> <span class="toctext"><span>Object of subsystem "Database" (TBDS)</span></span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Modular_object_of_types_of_databases_.28TTypeBD.29"><span class="tocnumber">3.2</span> <span class="toctext"><span>Modular object of types of databases (TTypeBD)</span></span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#The_object_of_the_database_.28TBD.29"><span class="tocnumber">3.3</span> <span class="toctext"><span>The object of the database (TBD)</span></span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#The_object_of_the_table_.28TTable.29"><span class="tocnumber">3.4</span> <span class="toctext"><span>The object of the table (TTable)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-12"><a href="#Subsystem_.22Data_acquisition.22"><span class="tocnumber">4</span> <span class="toctext">Subsystem "Data acquisition"</span></a>
<ul>
<li class="toclevel-2 tocsection-13"><a href="#Object_of_subsystem_.22Data_acquisition.22_.28TDAQS.29"><span class="tocnumber">4.1</span> <span class="toctext"><span>Object of subsystem "Data acquisition" (TDAQS)</span></span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Modular_object_of_the_controller.27s_type_.28TTypeDAQ.29"><span class="tocnumber">4.2</span> <span class="toctext"><span>Modular object of the controller's type (TTypeDAQ)</span></span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Controller.27s_object_.28TController.29"><span class="tocnumber">4.3</span> <span class="toctext"><span>Controller's object (TController)</span></span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Parameters.27_type_object_.28TTypeParam.29"><span class="tocnumber">4.4</span> <span class="toctext"><span>Parameters' type object (TTypeParam)</span></span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Object_of_the_physical_level_parameter_.28TParamContr.29"><span class="tocnumber">4.5</span> <span class="toctext"><span>Object of the physical level parameter (TParamContr)</span></span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Object_of_the_value_.28TValue.29"><span class="tocnumber">4.6</span> <span class="toctext"><span>Object of the value (TValue)</span></span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Attribute.27s_object_.28TVal.29"><span class="tocnumber">4.7</span> <span class="toctext"><span>Attribute's object (TVal)</span></span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Object_of_the_templates_library_of_parameters_of_the_.22DAQ.22_subsystem_.28TPrmTmplLib.29"><span class="tocnumber">4.8</span> <span class="toctext"><span>Object of the templates library of parameters of the "DAQ" subsystem (TPrmTmplLib)</span></span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#The_object_of_the_parameter.27s_template_of_the_.22DAQ.22_subsystem_.28TPrmTempl.29"><span class="tocnumber">4.9</span> <span class="toctext"><span>The object of the parameter's template of the "DAQ" subsystem (TPrmTempl)</span></span></a>
<ul>
<li class="toclevel-3 tocsection-22"><a href="#The_object_of_the_implementation_of_the_template.27s_parameters_of_the_.22DAQ.22_subsystem_.28TPrmTempl::Impl.29"><span class="tocnumber">4.9.1</span> <span class="toctext"><span>The object of the implementation of the template's parameters of the "DAQ" subsystem (TPrmTempl::Impl)</span></span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-23"><a href="#Subsystem_.22Archives-History.22"><span class="tocnumber">5</span> <span class="toctext"><span>Subsystem "Archives-History"</span></span></a>
<ul>
<li class="toclevel-2 tocsection-24"><a href="#The_object_of_the_subsystem_.22Archives.22_.28TArchiveS.29"><span class="tocnumber">5.1</span> <span class="toctext"><span>The object of the subsystem "Archives" (TArchiveS)</span></span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#The_object_of_the_values.27_archive_.28TVArchive.29"><span class="tocnumber">5.2</span> <span class="toctext"><span>The object of the values' archive (TVArchive)</span></span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#Object_of_the_values.27_buffer_.28TValBuf.29"><span class="tocnumber">5.3</span> <span class="toctext"><span>Object of the values' buffer (TValBuf)</span></span></a></li>
<li class="toclevel-2 tocsection-27"><a href="#The_modular_object_of_the_archiver.27s_type_.28TTypeArchivator.29"><span class="tocnumber">5.4</span> <span class="toctext"><span>The modular object of the archiver's type (TTypeArchivator)</span></span></a></li>
<li class="toclevel-2 tocsection-28"><a href="#The_object_of_the_messages.27_archiver_.28TMArchivator.29"><span class="tocnumber">5.5</span> <span class="toctext"><span>The object of the messages' archiver (TMArchivator)</span></span></a></li>
<li class="toclevel-2 tocsection-29"><a href="#The_object_of_the_values.27_archiver_.28TVArchivator.29"><span class="tocnumber">5.6</span> <span class="toctext"><span>The object of the values' archiver (TVArchivator)</span></span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#The_object_of_the_archive.27s_element_in_the_archiver_.28TVArchEl.29"><span class="tocnumber">5.7</span> <span class="toctext"><span>The object of the archive's element in the archiver (TVArchEl)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-31"><a href="#Subsystem_.22Transports.22"><span class="tocnumber">6</span> <span class="toctext"><span>Subsystem "Transports"</span></span></a>
<ul>
<li class="toclevel-2 tocsection-32"><a href="#The_object_of_the_.22Transports.22_subsystem_.28TTransportS.29"><span class="tocnumber">6.1</span> <span class="toctext"><span>The object of the "Transports" subsystem (TTransportS)</span></span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#The_modular_object_of_the_transports.27_type_.28TTypeTransport.29"><span class="tocnumber">6.2</span> <span class="toctext"><span>The modular object of the transports' type (TTypeTransport)</span></span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#The_object_of_the_input_transports_.28TTransportIn.29"><span class="tocnumber">6.3</span> <span class="toctext"><span>The object of the input transports (TTransportIn)</span></span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#The_object_of_the_output_transports_.28TTransportOut.29"><span class="tocnumber">6.4</span> <span class="toctext"><span>The object of the output transports (TTransportOut)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-36"><a href="#Subsystem_.22Transport_protocols.22"><span class="tocnumber">7</span> <span class="toctext"><span>Subsystem "Transport protocols"</span></span></a>
<ul>
<li class="toclevel-2 tocsection-37"><a href="#The_object_of_the_.22Communication_interfaces.27_protocols.22_subsystem_.28TProtocolS.29"><span class="tocnumber">7.1</span> <span class="toctext"><span>The object of the "Communication interfaces' protocols" subsystem (TProtocolS)</span></span></a></li>
<li class="toclevel-2 tocsection-38"><a href="#The_modular_object_of_the_protocol_.28TProtocol.29"><span class="tocnumber">7.2</span> <span class="toctext"><span>The modular object of the protocol (TProtocol)</span></span></a></li>
<li class="toclevel-2 tocsection-39"><a href="#The_object_of_the_input_protocol.27s_session_.28TProtocolIn.29"><span class="tocnumber">7.3</span> <span class="toctext"><span>The object of the input protocol's session (TProtocolIn)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-40"><a href="#Subsystem_.22User_interfaces.22"><span class="tocnumber">8</span> <span class="toctext">Subsystem "User interfaces"</span></a>
<ul>
<li class="toclevel-2 tocsection-41"><a href="#The_object_of_the_.22User_interfaces.22_subsystem_.28TUIS.29"><span class="tocnumber">8.1</span> <span class="toctext"><span>The object of the "User interfaces" subsystem (TUIS)</span></span></a></li>
<li class="toclevel-2 tocsection-42"><a href="#The_modular_object_of_the_user_interface_.28TUI.29"><span class="tocnumber">8.2</span> <span class="toctext"><span>The modular object of the user interface (TUI)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-43"><a href="#Subsystem_.22Specials.22"><span class="tocnumber">9</span> <span class="toctext">Subsystem "Specials"</span></a>
<ul>
<li class="toclevel-2 tocsection-44"><a href="#The_object_of_the_.22Specials.22_subsystem_.28TSpecialS.29"><span class="tocnumber">9.1</span> <span class="toctext"><span>The object of the "Specials" subsystem (TSpecialS)</span></span></a></li>
<li class="toclevel-2 tocsection-45"><a href="#The_modular_object_of_the_specials_.28TSpecial.29"><span class="tocnumber">9.2</span> <span class="toctext"><span>The modular object of the specials (TSpecial)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-46"><a href="#Subsystem_.22Security.22"><span class="tocnumber">10</span> <span class="toctext">Subsystem "Security"</span></a>
<ul>
<li class="toclevel-2 tocsection-47"><a href="#The_object_of_the_.22Security.22_subsystem_.28TSe.D1.81urity.29"><span class="tocnumber">10.1</span> <span class="toctext"><span>The object of the "Security" subsystem (TSeсurity)</span></span></a></li>
<li class="toclevel-2 tocsection-48"><a href="#The_user.27s_object_.28TUser.29"><span class="tocnumber">10.2</span> <span class="toctext"><span>The user's object (TUser)</span></span></a></li>
<li class="toclevel-2 tocsection-49"><a href="#The_users.27_group_object_.28TGroup.29"><span class="tocnumber">10.3</span> <span class="toctext"><span>The users' group object (TGroup)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-50"><a href="#Subsystem_.22Modules_scheduler.22"><span class="tocnumber">11</span> <span class="toctext">Subsystem "Modules scheduler"</span></a>
<ul>
<li class="toclevel-2 tocsection-51"><a href="#The_object_of_the_subsystem_.22Modules.27_sheduling.22_.28TModSchedul.29"><span class="tocnumber">11.1</span> <span class="toctext"><span>The object of the subsystem "Modules' sheduling" (TModSchedul)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-52"><a href="#Components_of_the_object_model_of_OpenSCADA"><span class="tocnumber">12</span> <span class="toctext">Components of the object model of OpenSCADA</span></a>
<ul>
<li class="toclevel-2 tocsection-53"><a href="#The_function_object_.28TFunction.29"><span class="tocnumber">12.1</span> <span class="toctext"><span>The function object (TFunction)</span></span></a></li>
<li class="toclevel-2 tocsection-54"><a href="#The_object_of_the_function.27s_parameter_.28IO.29"><span class="tocnumber">12.2</span> <span class="toctext"><span>The object of the function's parameter (IO)</span></span></a></li>
<li class="toclevel-2 tocsection-55"><a href="#The_object_of_the_function.27s_value_.28TValFunc.29"><span class="tocnumber">12.3</span> <span class="toctext"><span>The object of the function's value (TValFunc)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-56"><a href="#Data_in_OpenSCADA_and_their_storage"><span class="tocnumber">13</span> <span class="toctext"><span>Data in OpenSCADA and their storage</span></span></a>
<ul>
<li class="toclevel-2 tocsection-57"><a href="#Data_storing_conception"><span class="tocnumber">13.1</span> <span class="toctext"><span>Data storing conception</span></span></a></li>
<li class="toclevel-2 tocsection-58"><a href="#Data_object_.28TConfig.29"><span class="tocnumber">13.2</span> <span class="toctext"><span>Data object (TConfig)</span></span></a></li>
<li class="toclevel-2 tocsection-59"><a href="#Data_cell_.28TCfg.29"><span class="tocnumber">13.3</span> <span class="toctext"><span>Data cell (TCfg)</span></span></a></li>
<li class="toclevel-2 tocsection-60"><a href="#Data_structure_object_.28TElem.29"><span class="tocnumber">13.4</span> <span class="toctext"><span>Data structure object (TElem)</span></span></a></li>
<li class="toclevel-2 tocsection-61"><a href="#Data_structure_cell_.28TFld.29"><span class="tocnumber">13.5</span> <span class="toctext"><span>Data structure cell (TFld)</span></span></a></li>
<li class="toclevel-2 tocsection-62"><a href="#The_object_which_preacts_about_changing_of_the_structure_.28TValElem.29"><span class="tocnumber">13.6</span> <span class="toctext"><span>The object which preacts about changing of the structure (TValElem)</span></span></a></li>
<li class="toclevel-2 tocsection-63"><a href="#Data_cell_.28TVariant.29"><span class="tocnumber">13.7</span> <span class="toctext"><span>Data cell (TVariant)</span></span></a></li>
<li class="toclevel-2 tocsection-64"><a href="#User_object_.28TVarObj.29"><span class="tocnumber">13.8</span> <span class="toctext"><span>User object (TVarObj)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-65"><a href="#Control_interface_of_OpenSCADA_and_the_dynamic_tree_of_the_control_nodes"><span class="tocnumber">14</span> <span class="toctext"><span>Control interface of OpenSCADA and the dynamic tree of the control nodes</span></span></a>
<ul>
<li class="toclevel-2 tocsection-66"><a href="#The_syntax_of_the_request_and_response_of_the_control_interface"><span class="tocnumber">14.1</span> <span class="toctext">The syntax of the request and response of the control interface</span></a></li>
<li class="toclevel-2 tocsection-67"><a href="#Tag_of_the_information_structure_for_describing_the_groups_of_child_branches_of_the_page"><span class="tocnumber">14.2</span> <span class="toctext">Tag of the information structure for describing the groups of child branches of the page</span></a></li>
<li class="toclevel-2 tocsection-68"><a href="#Tags_of_the_description_of_the_information_structure_of_the_control_interface"><span class="tocnumber">14.3</span> <span class="toctext">Tags of the description of the information structure of the control interface</span></a>
<ul>
<li class="toclevel-3 tocsection-69"><a href="#Area_tag_.22area.22"><span class="tocnumber">14.3.1</span> <span class="toctext">Area tag "area"</span></a></li>
<li class="toclevel-3 tocsection-70"><a href="#Data_tags"><span class="tocnumber">14.3.2</span> <span class="toctext">Data tags</span></a>
<ul>
<li class="toclevel-4 tocsection-71"><a href="#Tag_.22fld.22"><span class="tocnumber">14.3.2.1</span> <span class="toctext">Tag "fld"</span></a></li>
<li class="toclevel-4 tocsection-72"><a href="#Tag_.22list.22"><span class="tocnumber">14.3.2.2</span> <span class="toctext">Tag "list"</span></a></li>
<li class="toclevel-4 tocsection-73"><a href="#Tag_.22table.22"><span class="tocnumber">14.3.2.3</span> <span class="toctext">Tag "table"</span></a></li>
<li class="toclevel-4 tocsection-74"><a href="#Tag_.22img.22"><span class="tocnumber">14.3.2.4</span> <span class="toctext">Tag "img"</span></a></li>
<li class="toclevel-4 tocsection-75"><a href="#Commands_with_the_parameters._Tag_.22comm.22"><span class="tocnumber">14.3.2.5</span> <span class="toctext">Commands with the parameters. Tag "comm"</span></a></li>
<li class="toclevel-4 tocsection-76"><a href="#Branches_.28child_nodes.29"><span class="tocnumber">14.3.2.6</span> <span class="toctext">Branches (child nodes)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-77"><a href="#Hierarchical_dependences_of_the_information_elements_of_the_control_language"><span class="tocnumber">14.4</span> <span class="toctext">Hierarchical dependences of the information elements of the control language</span></a></li>
<li class="toclevel-2 tocsection-78"><a href="#Object_of_the_dynamic_tree_node_.28TCntrNode.29"><span class="tocnumber">14.5</span> <span class="toctext"><span>Object of the dynamic tree node (TCntrNode)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-79"><a href="#Resources_locking"><span class="tocnumber">15</span> <span class="toctext">Resources locking</span></a>
<ul>
<li class="toclevel-2 tocsection-80"><a href="#Resource_R.2FW_lock_object_.28ResRW.29"><span class="tocnumber">15.1</span> <span class="toctext"><span>Resource R/W lock object (ResRW)</span></span></a></li>
<li class="toclevel-2 tocsection-81"><a href="#Automatic_resource_RW_unlock_object_.28ResAlloc.29"><span class="tocnumber">15.2</span> <span class="toctext"><span>Automatic resource RW unlock object (ResAlloc)</span></span></a></li>
<li class="toclevel-2 tocsection-82"><a href="#Template_.28AutoHD.29"><span class="tocnumber">15.3</span> <span class="toctext"><span>Template (AutoHD)</span></span></a></li>
<li class="toclevel-2 tocsection-83"><a href="#Resources_allocation_object.2C_by_mutex_.28ResMtx.29"><span class="tocnumber">15.4</span> <span class="toctext"><span>Resources allocation object, by mutex (ResMtx)</span></span></a></li>
<li class="toclevel-2 tocsection-84"><a href="#Object_of_the_string_with_the_access_shared_by_the_resource_.28ResString.29"><span class="tocnumber">15.5</span> <span class="toctext"><span>Object of the string with the access shared by the resource (ResString)</span></span></a></li>
<li class="toclevel-2 tocsection-85"><a href="#Conditional_variable_object.2C_by_mutex_.28CondVar.29"><span class="tocnumber">15.6</span> <span class="toctext"><span>Conditional variable object, by mutex (CondVar)</span></span></a></li>
<li class="toclevel-2 tocsection-86"><a href="#Object_of_automatic_unlock_POSIX_mutex_.28MtxAlloc.29"><span class="tocnumber">15.7</span> <span class="toctext"><span>Object of automatic unlock POSIX mutex (MtxAlloc)</span></span></a></li>
<li class="toclevel-2 tocsection-87"><a href="#Object_of_the_string_with_the_access_shared_by_the_global_the_data_resource_.28mutex.29_.28MtxString.29"><span class="tocnumber">15.8</span> <span class="toctext"><span>Object of the string with the access shared by the global the data resource (mutex) (MtxString)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-88"><a href="#Other_generic_objects"><span class="tocnumber">16</span> <span class="toctext">Other generic objects</span></a>
<ul>
<li class="toclevel-2 tocsection-89"><a href="#XML-tag_.28XMLNode.29"><span class="tocnumber">16.1</span> <span class="toctext"><span>XML-tag (XMLNode)</span></span></a></li>
<li class="toclevel-2 tocsection-90"><a href="#Error_exception_.28TError.29"><span class="tocnumber">16.2</span> <span class="toctext"><span>Error exception (TError)</span></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-91"><a href="#Organization_and_structure_of_the_database_of_the_system_components"><span class="tocnumber">17</span> <span class="toctext">Organization and structure of the database of the system components</span></a>
<ul>
<li class="toclevel-2 tocsection-92"><a href="#System_tables"><span class="tocnumber">17.1</span> <span class="toctext">System tables</span></a></li>
<li class="toclevel-2 tocsection-93"><a href="#Tables_of_the_.22Data_acquisition.22_subsystem"><span class="tocnumber">17.2</span> <span class="toctext">Tables of the "Data acquisition" subsystem</span></a></li>
<li class="toclevel-2 tocsection-94"><a href="#Tables_of_the_.22Transports.22_subsystem"><span class="tocnumber">17.3</span> <span class="toctext">Tables of the "Transports" subsystem</span></a></li>
<li class="toclevel-2 tocsection-95"><a href="#Tables_of_the_.22Archives.22_subsystem"><span class="tocnumber">17.4</span> <span class="toctext">Tables of the "Archives" subsystem</span></a></li>
<li class="toclevel-2 tocsection-96"><a href="#Tables_of_the_.22Security.22_subsystem"><span class="tocnumber">17.5</span> <span class="toctext">Tables of the "Security" subsystem</span></a></li>
<li class="toclevel-2 tocsection-97"><a href="#The_structure_of_the_databases_of_the_modules"><span class="tocnumber">17.6</span> <span class="toctext">The structure of the databases of the modules</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-98"><a href="#Service_functions_of_the_OpenSCADA_control_interface"><span class="tocnumber">18</span> <span class="toctext"><span>Service functions of the OpenSCADA control interface</span></span></a>
<ul>
<li class="toclevel-2 tocsection-99"><a href="#Group_access_to_the_values_of_the_parameter.27s_attributes_of_the_subsystem_.22Data_acquisition.22.2C_as_well_as_to_the_detailed_information"><span class="tocnumber">18.1</span> <span class="toctext">Group access to the values of the parameter's attributes of the subsystem "Data acquisition", as well as to the detailed information</span></a></li>
<li class="toclevel-2 tocsection-100"><a href="#Access_to_archived_data_of_the_archives_of_messages"><span class="tocnumber">18.2</span> <span class="toctext">Access to archived data of the archives of messages</span></a></li>
<li class="toclevel-2 tocsection-101"><a href="#Access_to_archived_data_of_the_values.27_archive"><span class="tocnumber">18.3</span> <span class="toctext">Access to archived data of the values' archive</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-102"><a href="#API_of_modules_of_the_modular_subsystems"><span class="tocnumber">19</span> <span class="toctext"><span>API of modules of the modular subsystems</span></span></a></li>
<li class="toclevel-1 tocsection-103"><a href="#Debugging_and_Testing_OpenSCADA"><span class="tocnumber">20</span> <span class="toctext">Debugging and Testing OpenSCADA</span></a></li>
<li class="toclevel-1 tocsection-104"><a href="#Rules_for_design_and_commenting_of_the_sources_of_OpenSCADA_and_its_modules"><span class="tocnumber">21</span> <span class="toctext">Rules for design and commenting of the sources of OpenSCADA and its modules</span></a></li>
<li class="toclevel-1 tocsection-105"><a href="#Conventional_signs_in_the_text_and_source_code"><span class="tocnumber">22</span> <span class="toctext">Conventional signs in the text and source code</span></a></li>
<li class="toclevel-1 tocsection-106"><a href="#Links"><span class="tocnumber">23</span> <span class="toctext">Links</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Internal_structure"><span class="mw-headline-number">1</span> Internal structure</span></h2>
<p>For the purpose of visual and affordable perception of OpenSCADA architecture in general the Figure 1 shows the static class diagram of OpenSCADA on the universal modeling language (UML). Based on the chart it is clear that OpenSCADA contains modular subsystems: "Archives", "Databases", "Transports", "Transport protocols", "User interfaces", "Data acquisition" and "Special", as well as subsystems: "Safety" and "Module's management". The chart graphically presents the relationship between modular subsystems and modules.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:718px;"><a class="image" href="http://oscada.org/wiki/File:API_uml_classdep.png"><img class="thumbimage" height="836" src="files/API_uml_classdep.png" width="716" /></a>  <div class="thumbcaption">Fig. 1. Static class diagram.</div></div></div></div>
<h2><span class="mw-headline" id="Overall_structure_of_the_program_.E2.80.94_modularity"><span class="mw-headline-number">2</span> Overall structure of the program — modularity</span></h2>
<p>The root, from which we construct the whole system is the object of TSYS. The root contains a subsystem (TSubSYS). Subsystems can be: the ordinary and modular. The difference between the modular subsystems is clearly shown in Fig. 1. Thus, the modular subsystems necessarily contain a list of modular structures (TModule), such as subsystem TArchiveS contain modular objects TTypeArchivator. At the same time, the normal subsystem does not contain such objects. For example TSecurity  subsystem (Figure 2).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:703px;"><a class="image" href="http://oscada.org/wiki/File:Oscada_struct.png"><img class="thumbimage" height="360" src="files/Oscada_struct.png" width="701" /></a>  <div class="thumbcaption">Fig. 2. Hierarchical structure of OpenSCADA.</div></div></div></div>
<p>In the process of initializing the root (TSYS) the global variable SYS is defined. The variable SYS can be used for direct access to the root of the system from any of its node. Initialization of the root is performed only one time from the main calling function. After starting the management is captured by the  system object till stop. The root object concentrate all system functions of OpenSCADA.
</p><p>Extension of the root object (TSYS) is the object TMess, which performs the functions of service of the flow of system messages. The object is accessible through the global variable Mess, which is initialized by the root of the system. The object contains the functions of encoding, decoding, and localization of messages.
</p><p>In the subsystems (TSubSYS) the functions typical for each subsystem individually with the general access for all subsystems are carried out through the object TSubSYS. Modular subsystem is able to extend its functionality by means of modules. For this purpose, modular subsystem provides access to the modules of its type in the form of modular objects.
</p><p>Module is the component of the modular subsystem. In general, for all modules and subsystems, the module provides information about itself, its origin and export functions. Individual module implements the functionality according to its own needs.
</p>
<h3><span class="mw-headline" id="The_root_object_system_.28TSYS.29"><span class="mw-headline-number">2.1</span> <span id="TSYS" title="#TSYS">The root object system (TSYS)</span></span></h3>
<table class="wikitable">

<tr>
<td> <b>Inherits:</b> </td>
<td> <a href="#TCntrNode">TCntrNode</a>.
</td></tr></table>
<p><b>Data:</b><br />
Information variables of the program:
</p>
<ul><li> <i>PACKAGE_LICENSE</i> — Distribution license of the program </li>
<li> <i>PACKAGE_DESCR</i> — Brief description of the program</li>
<li> <i>PACKAGE_AUTHOR</i> — Author of the program</li>
<li> <i>PACKAGE_SITE</i> — Web site of the program support</li></ul>
<p>Methods for coding of symbol sequences (enum — TSYS::Code):
</p>
<ul><li> <i>PathEl</i> — element of the path (the characters: '/' and '%' to the form '%2f');</li>
<li> <i>HttpURL</i> — address of the browser (http url);</li>
<li> <i>Html</i> — special characters for use in html;</li>
<li> <i>JavaSc</i> — end of line character for JavaScript;</li>
<li> <i>SQL</i> — SQL-query value;</li>
<li> <i>Custom</i> — selective coding of the specified characters;</li>
<li> <i>base64</i> — encoding in the standard Base64;</li>
<li> <i>FormatPrint</i> — coding/masking of the formating elements for functions like "printf";</li>
<li> <i>oscdID</i> — coding of the nodes' identifiers;</li>
<li> <i>Bin</i> — encoding of the binary data in text and vice versa;</li>
<li> <i>Reverse</i> — invert the order of characters in the line;</li>
<li> <i>ShieldSimb</i> — shielded symbols like to "\n" encoding to real code;</li>
<li> <i>ToLower</i> — convert to the lower case;</li>
<li> <i>ShieldBin</i> — shield the binary symbols [\x0-\x8\xB-\xC\x0E-\x1F].</li></ul>
<p>Types of representations of the integer in the function TSYS::int2str(), and TSYS::ll2str() (enum — TSYS::IntView):
</p>
<ul><li> <i>Dec</i> — decimal;</li>
<li> <i>Oct</i> — octal;</li>
<li> <i>Hex</i> — hexadecimal.</li></ul>
<p>Structure of redundant station (class — TSYS::SStat):
</p>
<ul><li> <i>int8_t lev;</i> — station level;</li>
<li> <i>bool isLive;</i> — flag "Station Alive";</li>
<li> <i>float cnt;</i> — counter of requests to the remote station or timer of a re-connection try;</li>
<li> <i>ResMtx reqM;</i> — the station requesting functional lock;</li>
<li> <i>SStat( int8_t ilev, bool iisLive = false, float icnt = 0 )</i> — station object constructor with level <i>ilev</i>, initiated as "Alive" <i>iisLive</i> and counter <i>icnt</i>;</li>
<li> <i>SStat( )</i> — constructor by default, initiated as as a missed and an inactive station;</li>
<li> <i>bool isActive( )</i> — station is active.</li></ul>
<p>Structure of OpenSCADA task (class — TSYS::STask):
</p>
<ul><li> <i>STask( pthread_t ithr, char ipolicy, char iprior );</i> — constructor of the task's descriptor for thread <i>ithr</i>, it's scheduling policy <i>ipolicy</i> and priority <i>iprior</i>.</li>
<li> <i>float consumpt( ) const;</i> — the task's last CPU time consumption, in seconds.</li>
<li> <i>float period( );</i> — the task's call instant periodicity, in seconds.</li>
<li> <i>string path;</i> — path.</li>
<li> <i>pthread_t thr;</i> — thread handler.</li>
<li> <i>uint8_t policy, phase;</i> — scheduling policy and phase. </li>
<li> <i>int16_t prior;</i> — scheduling priority. </li>
<li> <i>pid_t tid;</i> — thread's identifier as a Linux process's ID.</li>
<li> <i>ResString cpuSet;</i> — used processors/cores list.</li>
<li> <i>void *(*task) (void *);</i> — pointer to the task.</li>
<li> <i>void *taskArg;</i> — arguments of the task.</li>
<li> <i>unsigned flgs;</i> — flags, "enum Flgs { Detached = 0x01, FinishTask = 0x02; }".</li>
<li> <i>int64_t tm_beg, tm_end, tm_per, tm_pnt, cycleLost, lagMax, consMax;</i> — statistic variables of the task execution.</li></ul>
<p><b>Templates/definitions:</b>
</p>
<ul><li> <i>NSTR_BUF_LEN</i> — Length of string buffers for numbers (50 symbols).</li>
<li> <i>DAQ_APER_FRQ</i> — Frequency of representing the aperiodic invokes, like to "f_start", of the periodic processes in Hz (1000000).</li>
<li> <i>RECURS_DET_HOPS</i> — Hops/depth number of the recursion detection.</li>
<li> <i>ARCH_BUF</i> — Name of requesting the messages buffer ("&lt;buffer&gt;").</li>
<li> <i>ARCH_ALRM</i> — Name of requesting the actual alarms table ("&lt;alarms&gt;").</li>
<li> <i>ARCH_ALRM_CH</i> — Name of requesting for records change of the the actual alarms table ("&lt;alarmsChange&gt;").</li>
<li> <i>ARCH_NOALRM</i> — Name of requesting for the buffer and archivers and without the actual alarms table ("&lt;noalarms&gt;").</li>
<li> <i>__func__</i> — The full name of the calling function.</li>
<li> <i>vmin (a,b)</i> — Determination of the minimum value.</li>
<li> <i>vmax (a,b)</i> — Definition of the maximum value.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TSYS( int argi, char **argb, char **env );</i> — The initialisation constructor.</li>
<li> <i>bool isRunning( );</i> — Sign of the station running state — executing the main threaded module or waiting the stop signal.</li>
<li> <i>bool isFinalKill( );</i> — Sign "The final killing of". It is used for forced disconnection of blocked objects on the the final stage of shutdown.</li>
<li> <i>int stopSignal( );</i> — The return code in the case of system shutdown. Can be used as a sign of "System shutdown" of the various subsystems. </li>
<li> <i>void unload( );</i> — Unload subsystems.</li>
<li> <i>int start(  );</i> — Start of the system. The function is finished only with the finishing of the system. The return code is returned.</li>
<li> <i>void stop( int sig = SIGUSR1 );</i> — Stop program by the signal <i>sig</i>, by default it is SIGUSR1 and SIGUSR2 reserved for projects manager.</li>
<li> <i>string id( );</i> — station ID.</li>
<li> <i>string name( );</i> — Localized name of the station.</li>
<li> <i>string user( );</i> — The system user on behalf of which the system is running .</li>
<li> <i>string host( );</i> — Host name for the station run.</li>
<li> <i>void list( vector&lt;string&gt; &amp;list ) const;</i> — A list of registered subsystems in the system.</li>
<li> <i>bool present( const string &amp;name ) const;</i> — Check the availability of the subsystem.</li>
<li> <i>void add( TSubSYS *sub );</i> — Add/registration of the subsystem.</li>
<li> <i>void del( const string &amp;name );</i> — Removing the subsystem.</li>
<li> <i>AutoHD&lt;TSubSYS&gt; at( const string &amp;name ) const;</i> — Connection to the specified subsystem.</li>
<li> <i>AutoHD&lt;TUIS&gt; ui( );</i> — Direct access to the subsystem "User interfaces".</li>
<li> <i>AutoHD&lt;TArchiveS&gt; archive( );</i> — Direct access to the subsystem "Archives".</li>
<li> <i>AutoHD&lt;TBDS&gt; db( );</i> — Direct access to the subsystem "Databases".</li>
<li> <i>AutoHD&lt;TControllerS&gt; daq( );</i> — Direct access to the subsystem "Data acquisition".</li>
<li> <i>AutoHD&lt;TProtocolS&gt; protocol( );</i> — Direct access to the subsystem "Protocols".</li>
<li> <i>AutoHD&lt;TTransportS&gt; transport( );</i> — Direct access to the subsystem "Transports".</li>
<li> <i>AutoHD&lt;TSpecialS&gt; special( );</i> — Direct access to the subsystem "Special".</li>
<li> <i>AutoHD&lt;TModSchedul&gt; modSchedul( );</i> — Direct access to the subsystem "Module".</li>
<li> <i>AutoHD&lt;TSesurity&gt; sesurity( );</i> — Direct access to the subsystem "Security".</li>
<li> <i>string workDir( );</i> — Working directory of the station.</li>
<li> <i>string modDir( );</i> — Directories with the modules of OpenSCADA, separated by ';', they can include a files' template into the end (/my/modules/path/lib*.so).</li>
<li> <i>string icoDir( );</i> — Directory of the icons of OpenSCADA.</li>
<li> <i>string docDir( );</i> — Directory of the documents of OpenSCADA.</li>
<li> <i>void setWorkDir( const string &amp;wdir, bool init = false );</i> — Setting the working directory of the station.</li>
<li> <i>void setModDir( const string &amp;mdir, bool init = false );</i> — Specifying the directories of the modules of OpenSCADA.</li>
<li> <i>void setIcoDir( const string &amp;idir, bool init = false );</i> — Specifying of the directory of icons of OpenSCADA.</li>
<li> <i>void setDocDir( const string &amp;idir, bool init = false );</i> — Specifying of the directory of documents of OpenSCADA.</li>
<li> <i>string cfgFile( );</i> — Name of configuration file of the system.</li>
<li> <i>XMLNode &amp;cfgRoot( );</i> — Parsed structure of the configuration file.</li>
<li> <i>XMLNode *cfgNode( const string &amp;path, bool create = false );</i> — Node of configuration getting by it path <i>path</i>. Elements of the path creation by it miss <i>create</i>.</li>
<li> <i>void modifCfg( bool chkPossibleWR = false );</i> — Configuration mark to modification or write possibility <i>chkPossibleWR</i>, for next saving to file.</li>
<li> <i>ResRW &amp;cfgRes( );</i> — Lock of the access to the config file tree.</li>
<li> <i>string workDB( );</i> — The full name of the working database.</li>
<li> <i>string mainCPUs( );</i> — Used processors list.</li>
<li> <i>bool clockRT( );</i> — The Real-time clock selection for the tasks planning, else used the monotonic one (by defaults).</li>
<li> <i>int taskInvPhs( );</i> — Number of the tasks invoking phases.</li>
<li> <i>bool saveAtExit( );</i> — Sign - "Save configuration on exit".</li>
<li> <i>int savePeriod( );</i> — Frequency of the automatically saving the station in the database (seconds).</li>
<li> <i>bool modifCalc( );</i> — Set modification for the calculated objects.</li>
<li> <i>void setSelDB( const string &amp;vl );</i> — Installation of the selected database for the specified  boot.</li>
<li> <i>void setMainCPUs( const string &amp;vl );</i> — Setting of used processors list.</li>
<li> <i>void setClockRT( bool vl );</i> — Setting of the Real-time clock selection for the tasks planning.</li>
<li> <i>void setTaskInvPhs( int vl );</i> — Setting number of the tasks invoking phases.</li>
<li> <i>void setSaveAtExit( bool vl );</i> — Setting of the sign - "Save configuration on exit".</li>
<li> <i>void setSavePeriod( int vl );</i> — Set the frequency of the automatically saving of the station to the database (seconds).</li>
<li> <i>void setModifCalc( bool vl );</i> — Set of setting the modification for the calculated objects.</li>
<li> <i>string selDB( );</i> — Chosen DB. Used for selective loading from the specified database in the subsystem "DB".</li>
<li> <i>void setWorkDB( const string &amp;wdb );</i> — Setting of  the full name of the working database.</li>
<li> <i>bool chkSelDB( const string &amp;wDB );</i> — The function of checking for compliance of the specified database <i>wDB</i>  with the selected "selDB()".</li>
<li> <i>XMLNode *cfgCtx( bool last = false );</i> — The global configuration context of the interstation copying or the <i>last</i> setting link, for the access lock used <i>cfgLoadSaveM()</i>.</li>
<li> <i>void setCfgCtx( XMLNode *vl, bool last = false );</i> — Set the global configuration context of the interstation copying or the <i>last</i> setting link, for the access lock used <i>cfgLoadSaveM()</i>. At any operation with the global configuration context the last setting link is cleared.</li>
<li> <i>ResMtx &amp;cfgLoadSaveM( );</i> — Lock of the loading and saving configuration.</li>
<li> <i>static void sighandler( int signal );</i> — Function of the  default handler of the signals of the system as a whole.</li>
<li> <i>unsigned long long sysClk( );</i> — The estimated frequency of the processor on which the system works (Hz). </li>
<li> <i>void clkCalc( );</i> — Calculation of frequency of the processor on which the system works. It is called periodically for the systems with variable CPU  frequency.</li>
<li> <i>unsigned long long shrtCnt( );</i> — The function of the measurement of small intervals of time by the counter of the CPU cycles. Returns the value of the counter of CPU cycles.</li>
<li> <i>static long HZ( );</i> — Time of the system teak  of the CPU.</li>
<li> <i>void taskCreate( const string &amp;path, int priority, void *(*start_routine)(void *), void *arg, int wtm = 5, pthread_attr_t *pAttr = NULL, bool *startSt = NULL );</i> — Create task (thread) with id <i>path</i>, <i>priority</i> (-1...99), task's function <i>start_routine</i> and it argument <i>arg</i>, and also wait for user's code start by flag <i>startSt</i>.</li>
<li> <i>void taskDestroy( const string &amp;path, bool *endrunCntr = NULL, int wtm = 5, bool noSignal = false );</i> — Destroy task with id <i>path</i>, start control flag <i>startCntr</i>. Use <i>noSignal</i> for exclude signal <i>SIGALRM</i> send to the task.</li>
<li> <i>void taskSendSIGALRM( const string &amp;path );</i> — Sending the termination signal "ALARM" to a task with id <i>path</i>.</li>
<li> <i>double taskUtilizTm( const string &amp;path, bool max = false );</i> — Utilization of CPU time, in seconds, for task <i>path</i> or it's maximum <i>max</i>.</li>
<li> <i>static bool taskEndRun( );</i> — Check for the task endrun by signal <i>SIGUSR1</i>.</li>
<li> <i>static const STask&amp; taskDescr( );</i> — Get reference to the task's descriptor.</li>
<li> <i>static int sysSleep( float tm );</i> — System sleep in seconds up to nanoseconds (1e-9).</li>
<li> <i>time_t sysTm( );</i> — System time fast access, from updated cell</li>
<li> <i>static int64_t curTime( clockid_t clc = CLOCK_REALTIME );</i> — The clock <i>clc</i> time in microseconds from the beginning of the era (01.01.1970).</li>
<li> <i>static uint64_t curTimeN( clockid_t clc = CLOCK_REALTIME );</i> — The clock <i>clc</i> time in nanoseconds from the beginning of the era (01.01.1970).</li>
<li> <i>string prjUserDir( );</i> — Directory of the user projects.</li>
<li> <i>bool prjCustMode( );</i> — Custom mode of projects.</li>
<li> <i>void setPrjCustMode( bool vl );</i> — Set for custom mode of projects.</li>
<li> <i>string prjNm( );</i> — Project name of the configuration.</li>
<li> <i>void setPrjNm( const string &amp;vl );</i> — Set project name of the configuration.</li>
<li> <i>bool prjSwitch( const string &amp;prj, bool toCreate = false );</i> — Switch to project <i>prj</i>.</li>
<li> <i>int prjLockUpdPer( );</i> — Get project lock updating period, zero for the lock disable.</li>
<li> <i>bool prjLock( const char *cmd );</i> — Project lock process for the command <i>cmd</i> ("hold", "free", "update").</li>
<li> <i>static void taskSleep( int64_t per, const string &amp;cron = "", int64_t *lag = NULL );</i> — The function of the flow sleep by the grid of absolute time with the period <i>per</i> in the nanosecond or for the scheduled time <i>cron</i>. If set <i>lag</i> then to it will return different value from real and planed wake up time (lost cycles).</li>
<li> <i>static time_t cron( const string &amp;vl, time_t base=0 );</i> — Planning the execution time on the format of the standard Cron <i>vl</i> beginning at the basic time <i>base</i> or at the current time if the base is not specified.</li>
<li> <i>static bool eventWait( bool &amp;m_mess_r_stat, bool exempl, const string &amp;loc, time_t time=0 );</i> — Function of the event waiting <i>exempl</i> for the variable <i>m_mess_r_stat</i> within a specified time interval <i>time</i> for the source <i>loc</i>.</li>
<li> <i>bool cntrEmpty( );</i> — Debug counters checking to empty.</li>
<li> <i>double cntrGet( const string &amp;id );</i> — Debug counter <i>id</i> getting.</li>
<li> <i>void cntrSet( const string &amp;id, double vl );</i> — Debug counter <i>id</i> setting to value <i>vl</i>.</li>
<li> <i>void cntrIter( const string &amp;id, double vl );</i> — Debug counter <i>id</i> iteration to value <i>vl</i>.</li>
<li> <i>bool rdEnable( );</i> — Redundancy enabled, at least one redundancy station presented.</li>
<li> <i>bool rdActive( );</i> — Redundancy active, at least one active station presented.</li>
<li> <i>void rdStList( vector&lt;string&gt; &amp;ls );</i> — List of <i>ls</i> stations into the redundancy.</li>
<li> <i>SStat rdSt( const string &amp;id );</i> — Get copy of state structure of the redundancy station <i>id</i>.</li>
<li> <i>map&lt;string, SStat&gt; rdSts( );</i> — Get copy of list of state structures of redundancy stations.</li>
<li> <i>int rdStLevel( );</i> — Current station level into the redundancy system.</li>
<li> <i>void setRdStLevel( int vl );</i> — Set current station level into the redundancy system.</li>
<li> <i>float rdTaskPer( );</i> — Period of execution of the redundancy processing task.</li>
<li> <i>void setRdTaskPer( float vl );</i> — Set period of execution of the redundancy processing task.</li>
<li> <i>int rdRestConnTm( );</i> — Time of the retry attempts to reconnect to the backup station after its loss in seconds.</li>
<li> <i>void setRdRestConnTm( int vl );</i> — Set time of the retry attempts to reconnect to the backup station after its loss in seconds.</li>
<li> <i>string rdStRequest( XMLNode &amp;req, const string &amp;st = "" );</i> — Common request <i>req</i> to pointed redundancy station <i>st</i>.</li>
<li> <i>static string int2str( int val, IntView view=Dec );</i> — Transformation of a signed integer to the string of the type of view <i>view</i>. </li>
<li> <i>static string uint2str( unsigned val, IntView view=Dec );</i> — Transformation of unsigned integer to the string type of view <i>view</i>.</li>
<li> <i>static string ll2str( long long val, IntView view=Dec );</i> — Transformation of a long integer (64bit) to the string type of view <i>view</i>.</li>
<li> <i>static string real2str( double val, int prec=15, char tp='g');</i> — Real transformation with an accuracy <i>prec</i> signs and type <i>tp</i> to the string.</li>
<li> <i>static double realRound( double val, int dig=0, bool toint=false );</i> — Rounding the real number to the specified digit <i>dig</i> after the decimal point with the possibility of transformation to integer after rounding <i>toint</i>.</li>
<li> <i>static string atime2str( time_t tm, const string &amp;format = "", bool gmt = false );</i> — Astronomic UNIX time <i>tm</i> conversion to a string, in the <i>format</i> of the POSIX-function "strftime()" or "gmtime()", for <i>gmt</i>.</li>
<li> <i>static string time2str( double tm );</i> — Convert time interval, in seconds, to string like "1hour 23min 10sec".</li>
<li> <i>static string cpct2str( double cnt );</i> — Traffic counter <i>cnt</i> (bytes) convert to string like "12.5KiB".</li>
<li> <i>static double str2real( const string &amp;val );</i> — String transformation to the real.</li>
<li> <i>static time_t str2atime( const string &amp;val, const string &amp;format = "", bool gmt = false )</i> — String time <i>val</i> conversion to an astronomic UNIX time, in the <i>format</i> of the POSIX-function "strptime()", and by the function "mktime()" or "timegm()", for <i>gmt</i>.</li>
<li> <i>static string addr2str( void *addr );</i> — Convert addresses into string.</li>
<li> <i>static void *str2addr( const string &amp;str );</i> — Convert string into the address.</li>
<li> <i>static string strTrim( const string &amp;val, const string &amp;cfg = " \n\t\r" );</i> — Deletes from the original string <i>val</i> pointed into <i>cfg</i> (mostly empty) characters at the beginning and end of it.</li>
<li> <i>static string strSepParse( const string &amp;path, int level, char sep, int *off = NULL );</i> — Parsing of the string <i>path</i> into the components separated by the dividing symbol <i>sep</i>, beginning with the offset <i>off</i> and controlling the offset of the element end in itself.</li>
<li> <i>static string {strParse,strParseEnd}( const string &amp;str, int level, const string &amp;sep, int *off = NULL, bool mergeSepSymb = false );</i> — Parse function's "strSepParse()" expanded version which allow using multi-symbols separators and one symbol merging. <i>strParseEnd</i> does the same but from the end.</li>
<li> <i>static string strLine( const string &amp;str, int level, int *off = NULL );</i> — Parsing text lines for different ways to the end of a line (CR, LF and CR/LF).</li>
<li> <i>static string pathLev( const string &amp;path, int level, bool decode = true, int *offCmtbl = NULL, int *off = NULL );</i> — Obtaining of the element/token <i>level</i> of the <i>path</i> with the ability of their decode, starting with the offset <i>off</i> (stopping on the next token begin) or <i>offCmtbl</i> (stopping on next symbol of the current token end — for compatibility).</li>
<li> <i>static string pathLevEnd( const string &amp;path, int level, bool decode = true, int *off = NULL );</i> — Obtaining of the element/token <i>level</i> of the <i>path</i> from the end with the ability of their decode, starting with the offset <i>off</i> (stopping on the next token end).</li>
<li> <i>static string path2sepstr( const string &amp;path, char sep = '.' );</i> — Transformation the path into string with the separator <i>sep</i> of the elements.</li>
<li> <i>static string sepstr2path( const string &amp;str, char sep = '.' );</i> — Transformation of the string with the separator <i>sep</i> of the elements into the path.</li>
<li> <i>static string strEncode( const string &amp;in, Code tp, const string &amp;opt1 = "" );</i> — Encoding of the string by the specified rule <i>tp</i> and option <i>opt1</i> (symbols by "Custom"). </li>
<li> <i>static string strDecode( const string &amp;in, Code tp = Custom, const string &amp;opt1 = "" );</i> — Decoding of the string <i>in</i> by the specified rule <i>tp</i> and option <i>opt1</i> (separator or "&lt;text&gt;" for "Bin"). </li>
<li> <i>static string strMess( const char *fmt, ... );</i> — Formation of the string by the template <i>fmt</i> and arguments. It is implemented on the basis of "printf".</li>
<li> <i>static string strLabEnum( const string &amp;base );</i> — Individual string labels from <i>base</i> forming by increment at end. Supported numbering into decimal, hexadecimal (prefix "0x") or octal (prefix "0") notation.</li>
<li> <i>string strCompr( const string &amp;in, int lev=-1);</i> — Compression of the string <i>in</i> with the compression level <i>lev</i>.</li>
<li> <i>string strUncompr( const string &amp;in );</i> — Decompression of the string <i>in</i>.</li>
<li> <i>static inline uint16_t getUnalign16( const void *p ); static inline uint32_t getUnalign32( const void *p ); static inline uint64_t getUnalign64( const void *p );</i> — Unaligned read for unsigned </li>
<li> <i>static inline int getUnalignInt( const void *p );</i> — Unaligned read for integer from buffer by offset.</li>
<li> <i>static inline float getUnalignFloat( const void *p );</i> — Unaligned read by real "float" from buffer by offset.</li>
<li> <i>static inline double getUnalignDbl( const void *p );</i> — Unaligned read by real "double" from buffer by offset.</li>
<li> <i>static uint16_t i16_LE( uint16_t in ); static uint32_t i32_LE( uint32_t in ); static uint64_t i64_LE( uint64_t in );</i> — Byte order conversion for integer <i>in</i> from Little-Endian (LE) to internal represent.</li>
<li> <i>static uint16_t i16_BE( uint16_t in ); static uint32_t i32_BE( uint32_t in ); static uint64_t i64_BE( uint64_t in );</i> —Byte order conversion for integer <i>in</i> from Big-Endian (BE) to internal represent.</li>
<li> <i>static float floatLE( float in ); static double doubleLE( double in );</i> — Real number <i>in</i> conversion from internal to format IEEE754 Little-Endian (LE).</li>
<li> <i>static float floatLErev( float in ); static double doubleLErev( double in );</i> — Real number <i>in</i> conversion from format IEEE754 Little-Endian (LE) to internal.</li>
<li> <i>static float floatBE( float in ); static double doubleBE( double in );</i> — Real number <i>in</i> conversion from internal to format IEEE754 Big-Endian (BE).</li>
<li> <i>static float floatBErev( float in ); static double doubleBErev( double in );</i> — Real number <i>in</i> conversion from format IEEE754 Big-Endian (BE) to internal.</li>
<li> <i>string optDescr( );</i> — Full localized help on the options of the command line and parameters of the configuration file.</li>
<li> <i>string getCmdOpt( int &amp;curPos, string *argVal = NULL ); static string getCmdOpt_( int &amp;curPos, string *argVal, int argc, char **argv );</i> — Command line parameters parsing by cursor scanning <i>curPos</i>. Return argument name and it's possible value into <i>argVal</i>. Implement formats for short keys: "-v", "-v val", "-abcv", "-abcv val"; and long keys: "--var", "--var=val", "--var val".</li>
<li> <i>bool cmdOptPresent( const string &amp;opt );</i> — Check the command-line option <i>opt</i> for presence.</li>
<li> <i>string cmdOpt( const string &amp;opt, const string &amp;setVl = "" );</i> — Get command-line option <i>opt</i>. Set it at <i>setVl</i> if pointing.</li>
<li> <i>int permCrtFiles( bool exec = false );</i> — get permission for files created OpenSCADA in form 0777 (RWXRWXRWX), where <i>exec</i> is not mask the bit 01.</li>
<li> <i>ResMtx *commonLock( const string &amp;nm );</i> — creates and gets a lock for the name <i>nm</i> — for non multithread system functions, typically.</li>
<li> <i>static void ctrListFS( XMLNode *nd, const string &amp;fsBase, const string &amp;fileExt = "" );</i> — Browsing list for file system's items from base <i>fsBase</i>, for the files with extensions <i>fileExt</i> in list "png;jpeg;gif;".</li></ul>
<p><b>Public attributes:</b>
</p>
<ul><li> <i>AutoHD&lt;TModule&gt; mainThr;</i> — Connection to a module executing in the main thread.</li></ul>
<p><b>Short calls for global functions into "OSCADA" namespace:</b>
</p>
<ul><li> <i>template &lt;class fVal&gt; fVal fmin( fVal a, fVal b ); template &lt;class fVal&gt; fVal fmax( fVal a, fVal b );</i> — functional templates for obtain of two values minimum and maximum.</li>
<li> <i>inline string i2s( int val, TSYS::IntView view = TSYS::Dec )</i> —&gt; TSYS::int2str(val, view);</li>
<li> <i>inline string u2s( unsigned val, TSYS::IntView view = TSYS::Dec )</i> —&gt; TSYS::uint2str(val, view);</li>
<li> <i>inline string ll2s( long long val, TSYS::IntView view = TSYS::Dec )</i> —&gt; TSYS::ll2str(val, view);</li>
<li> <i>inline string r2s( double val, int prec = 15, char tp = 'g' )</i> —&gt; TSYS::real2str(val, prec, tp);</li>
<li> <i>inline double rRnd( double val, int dig = 0, bool toint = false )</i> —&gt; TSYS::realRound(val, dig, toint);</li>
<li> <i>inline string atm2s( time_t tm, const string &amp;format = "", bool gmt = false )</i> —&gt; TSYS::atime2str(tm, format, gmt);</li>
<li> <i>inline string tm2s( double tm )</i> —&gt; TSYS::time2str(tm);</li>
<li> <i>inline int s2i( const string &amp;val )</i> —&gt; atoi(val.c_str());</li>
<li> <i>inline long s2l( const string &amp;val, int base = 10 )</i> —&gt; strtol(val.c_str(), NULL, base);</li>
<li> <i>inline unsigned long s2u( const string &amp;val, int base = 10 )</i> —&gt; strtoul(val.c_str(), NULL, base);</li>
<li> <i>inline long long s2ll( const string &amp;val )</i> —&gt; atoll(val.c_str());</li>
<li> <i>inline double s2r( const string &amp;val )</i> — TSYS::str2real(val);</li>
<li> <i>inline string sTrm( const string &amp;val, const string &amp;cfg = " \n\t\r")</i> —&gt; TSYS::strTrim(val, cfg);</li></ul>
<h3><span class="mw-headline" id="Object_of_the_messages_system_.28TMess.29"><span class="mw-headline-number">2.2</span> <span id="TMess" title="#TMess">Object of the messages system (TMess)</span></span></h3>
<p><b>Data:</b><br />
Types (levels) of messages (enum — TMess::Type):
</p>
<ul><li> <i>Debug</i> (0) — debug;</li>
<li> <i>Info</i> (1) — information;</li>
<li> <i>Notice</i> (2) — the notification;</li>
<li> <i>Warning </i> (3) — warning;</li>
<li> <i>Error</i> (4) — error;</li>
<li> <i>Crit</i> (5) — critical situation;</li>
<li> <i>Alert</i> (6) — alert;</li>
<li> <i>Emerg</i> (7) — emergency;</li>
<li> <i>MaxLev</i> (79) — maximum message level, where [0...7] are the generic named levels and the second digit is them sub-levels.</li></ul>
<p>Direction for the messages (enum — TMess::Direct):
</p>
<ul><li> <i>DIR_SYSLOG</i> (0x1) — to SYSLOG;</li>
<li> <i>DIR_STDOUT</i> (0x2) — to standard output;</li>
<li> <i>DIR_STDERR</i> (0x4) — to standard errors output;</li>
<li> <i>DIR_ARCHIVE</i> (0x8) — to messages archive.</li></ul>
<p>The structure of the message (class — TMess::SRec):
</p>
<ul><li> <i>SRec( ); SRec( time_t itm, int iutime = 0, const string &amp;icat = "", int8_t ilev = 0, const string &amp;imess = "" );</i> — the class constructors;</li>
<li> <i>bool operator==( SRec &amp;vl );</i> — the object comparing;</li>
<li> <i>time_t time; </i> — time of the message;</li>
<li> <i>int utime;</i> — microsecond of the message time;</li>
<li> <i>string categ;</i> — category of messages (usually the way inside the system);</li>
<li> <i>int8_t level;</i> — the level of the message;</li>
<li> <i>string mess;</i> — message.</li></ul>
<p><b>Templates:</b>
</p>
<ul><li> <i>_(mess); trS(mess)</i> — Wrappers over the translation of the messages function for the provision of the accepted by the most of the programs translation of the messages. trS() also provides the prestoring, when the base message stored together the catalogue, that is "{base}\000{cat}" and what is translated really in second call inward the translation context or _().</li>
<li> <i>trD(base)</i> — Wrapper over the text variables dynamic translation using the translation context to the function <i>translGet()</i>.</li>
<li> <i>trD_L(base,lng); trD_U(base,usr); trD_LU(base,lng,usr)</i> — Wrappers over the text variables dynamic translation functions by language and user.</li>
<li> <i>trDSet(base,mess)</i> — Wrapper over the text variables dynamic translation set using the translation context to the function <i>translSet()</i>.</li>
<li> <i>trDSet_L(base,lng,mess); trDSet_U(base,usr,mess); trDSet_LU(base,lng,usr,mess)</i> — Wrapper over the text variables dynamic translation set functions by language and user.</li>
<li> <i>FTM(rec); FTM2(tm, utm)</i> — Get a full time of the message, in microseconds, using the two fields of time of the message structure. </li>
<li> <i>mess_lev()</i> — The system's messages level. Often used for debug mode check (=Debug).</li>
<li> <i>message( cat, lev, fmt, args ... )</i> — Formation of the the full message. </li>
<li> <i>mess_debug( cat, fmt, args ... )</i> — Formation of the debug message. </li>
<li> <i>mess_info( cat, fmt, args ... )</i> — Formation of the information message. </li>
<li> <i>mess_note( cat, fmt, args ... )</i> — Formations of the message - notification. </li>
<li> <i>mess_warning( cat, fmt, args ... )</i> — Formation of the warning message. </li>
<li> <i>mess_err( cat, fmt, args ... )</i> — Formation of the error message. </li>
<li> <i>mess_crit( cat, fmt, args ... )</i> — Formation of the critical condition message. </li>
<li> <i>mess_alert( cat, fmt, args ... )</i> — Formation of the alarm message. </li>
<li> <i>mess_emerg( cat, fmt, args ... )</i> — Formation of the emergency message. </li>
<li> <i>message_( cat, lev, fmt, args ... )</i> — Formation of the the full message (selected level and debug categories are ignored). </li>
<li> <i>mess_debug_( cat, fmt, args ... )</i> — Formation of the debug message (selected level and debug categories are ignored). </li>
<li> <i>mess_info_( cat, fmt, args ... )</i> — Formation of the information message (selected level is ignored). </li>
<li> <i>mess_note_( cat, fmt, args ... )</i> — Formations of the message - notification (selected level is ignored). </li>
<li> <i>mess_warning_( cat, fmt, args ... )</i> — Formation of the warning message (selected level is ignored). </li>
<li> <i>mess_err_( cat, fmt, args ... )</i> — Formation of the error message (selected level is ignored). </li>
<li> <i>mess_crit_( cat, fmt, args ... )</i> — Formation of the critical condition message (selected level is ignored). </li>
<li> <i>mess_alert_( cat, fmt, args ... )</i> — Formation of the alarm message (selected level is ignored). </li>
<li> <i>mess_emerg_( cat, fmt, args ... )</i> — Formation of the emergency message (selected level is ignored). </li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>void load( );</i> — Download. </li>
<li> <i>void save( );</i> — Saving. </li>
<li> <i>string codeConv( const string &amp;fromCH, const string &amp;toCH, const string &amp;mess);</i> — Conversion of the codepage of the messages. </li>
<li> <i>string codeConvIn( const string &amp;fromCH, const string &amp;mess);</i> — Conversion the codepage of the messages into the internal system codepage. </li>
<li> <i>string codeConvOut ( const string &amp;toCH, const string &amp;mess);</i> — Conversion of the message from the internal system codepage.</li>
<li> <i>string I18N( const string &amp;mess, const char *mLang = NULL, const char *d_name = NULL );</i> — Getting the message <i>mess</i> in the language <i>mLang</i> for the system translation from the directory <i>d_name</i>, NULL for the OpenSCADA core.</li>
<li> <i>string lang( );</i> — Language of the system, as en_US.UTF-8. </li>
<li> <i>string langCode( const string &amp;user = "", bool onlyUser = false );</i> — Language code of the system. Specify <i>user</i> for obtaining its language and <i>onlyUser</i> for only that.</li>
<li> <i>string &amp;charset( );</i> — The system codepage. </li>
<li> <i>int logDirect( );</i> — Receivers to whom the system messages (stdout, stderr, syslog, archive) are sent.</li>
<li> <i>int messLevel( );</i> — The level below which the messages are ignored.</li>
<li> <i>static bool messLevelTest( int8_t condLev, int8_t messLev );</i> — The message level testing for <i>messLev</i> &gt;= <i>condLev</i> counting the message sub-levels — the second digit, where <i>condLev</i> is ±[0...7] and <i>messLev</i> is ±[0...79].</li>
<li> <i>string selDebCats( );</i> — Selected debug categories (by separated ';' list).</li>
<li> <i>bool isUTF8( );</i> — Internal codepage is UTF-8.</li>
<li> <i>void setLang( const string &amp;lang, bool init = false );</i> — Setting of the system language (localization). </li>
<li> <i>void setLogDirect( int dir );</i> — Setting receivers to which the system messages are sent. For <i>dir</i> the bit mask is used. Where: </li></ul>
<dl><dd>1 — to syslog;</dd>
<dd>2 — to stdout;</dd>
<dd>4 — to stderr;</dd>
<dd>8 — to the archive.</dd></dl>
<ul><li> <i>void setMessLevel( int level );</i> — Setting a minimum level of processed messages. </li>
<li> <i>void setSelDebCats( const string &amp;vl );</i> — Debug categories set (by separated ';' list).</li>
<li> <i>void put( const char *categ, int8_t level, const char *fmt,  ... );</i> — The message forming for the current time with the category <i>categ</i>, the <i>level</i>, the formatted message <i>fmt</i> and the followed arguments.</li>
<li> <i>void put_( const char *categ, int8_t level, const char *fmt, ... ); void putArg( const char *categ, int8_t level, const char *fmt, va_list ap );</i> — The message forming for the current time (selected level and debug categories are ignored) with the category <i>categ</i>, the <i>level</i>, the formatted message <i>fmt</i> and the followed arguments.</li>
<li> <i>void get( time_t b_tm, time_t e_tm, vector&lt;TMess::SRec&gt; &amp;recs, const string &amp;category = "", int8_t level = Debug );</i> — Get the message from the archive for the period of time <i>b_tm</i> — <i>e_tm</i> under the category template <i>category</i> and minimum level <i>level</i>. </li>
<li> <i>string langCodeBase( );</i> — The language of basic variables of the text messages.</li>
<li> <i>string langBase( );</i> — The language-locale of basic variables and the locales list used in the project translation, separated by ';'.</li>
<li> <i>string langToLocale( const string &amp;lang );</i> — Getting the complete locale from <i>langBase()</i> at the language <i>lang</i>.</li>
<li> <i>bool translCfg( );</i> — The configuration translation sign, combined as "<b>langCodeBase().size() &amp;&amp; langCode()&nbsp;!= langCodeBase()</b>".</li>
<li> <i>bool translDyn( bool plan = false );</i> — Mode "Dynamic translation" or the <i>plan</i> to next start.</li>
<li> <i>bool translEnMan( );</i> — The sign "Enabled translations manager", for activation of the built translation messages index and the translation manager.</li>
<li> <i>string translLangs( );</i> — List of translation languages, into the manager.</li>
<li> <i>string translFld( const string &amp;lng, const string &amp;fld, bool isCfg = false );</i> — Representing the translated field name by the field name <i>fld</i> and language <i>lng</i> for configuration <i>isCfg</i> or DB.</li>
<li> <i>bool isMessTranslable( const string &amp;vl );</i> — Checking the message <i>vl</i> for availability of it translation, has no only space, digit and punctuation symbols.</li>
<li> <i>void setLangBase( const string &amp;vl );</i> — Setting the language-locale of basic variables and the locales list used in the project translation.</li>
<li> <i>void setTranslDyn( bool val, bool plan = true );</i> — Setting the mode "Dynamic translation" or the <i>plan</i> to value <i>val</i> for next start.</li>
<li> <i>void setTranslEnMan( bool vl, bool passive = false );</i> — Setting "Enabled translation manager" to value <i>vl</i> and passive mode <i>passive</i>.</li>
<li> <i>void setTranslLangs( const string &amp;vl );</i> — Setting a list of translation languages.</li>
<li> <i>string translGet( const string &amp;base );</i> — Getting translation for <i>base</i> text variable using the translation context.</li>
<li> <i>string translGet( const string &amp;base, const string &amp;lang, const string &amp;src = "" ); string translGetU( const string &amp;base, const string &amp;user, const string &amp;src = "" ); string translGetLU( const string &amp;base, const string &amp;lang, const string &amp;user, const string &amp;src = "" );</i> — Getting translation for <i>base</i> text variable for language <i>lang</i> or <i>user</i> and optional source <i>src</i>.</li>
<li> <i>string translSet( const string &amp;base, const string &amp;mess );</i> — Setting translation for <i>base</i> text variable to value <i>mess</i> using the translation context.</li>
<li> <i>string translSet( const string &amp;base, const string &amp;lang, const string &amp;mess, bool *needReload = NULL ); string translSetU( const string &amp;base, const string &amp;user, const string &amp;mess, bool *needReload = NULL ); string translSetLU( const string &amp;base, const string &amp;lang, const string &amp;user, const string &amp;mess, bool *needReload = NULL );</i> — Setting translation for <i>base</i> text variable for language <i>lang</i> or <i>user</i> and optional source <i>src</i> to value <i>mess</i>.</li>
<li> <i>void translReg( const string &amp;mess, const string &amp;src, const string &amp;prms = "" );</i> — Registering the translated message <i>mess</i> with source <i>src</i> and appended parameters <i>prms</i> into the translations index.</li>
<li> <i>string translCacheGet( const string &amp;key, bool *ok = NULL );</i> — Getting the translation message at the <i>key</i> in the form "{lang}#{base}[\000{cat}]" from the translation cache. Where <i>cat' can be: EMPTY — for dynamic messages, "sys" — for system messages and "user" — for the users used in the dynamic language obtaining. You can pass </i>ok<i> for detection the message really placing in the cache.</i></li>
<li> <i>void translCacheSet( const string &amp;key, const string &amp;val );</i> — Setting the translation message <i>val</i> at the <i>key</i> to the translation cache.</li>
<li> <i>void translCacheLimits( time_t tmLim = 0, const char *clrCat = NULL );</i> — Processing the translation cache limits at the size <i>trMessCache</i> and the nonzero time <i>tmLim</i>. Also that can clear the messages in the category <i>clrCat</i>.</li>
<li> <i>void translIdxCacheUpd( const string &amp;base, const string &amp;lang, const string &amp;mess, const string &amp;src );</i> — Updating the operative translation messages' index and cache in the MULTILANGUAGE-DYNAMIC mode.</li>
<li> <i>bool translItSplit( const string &amp;base, const string &amp;srcFltr = "" );</i> — Splitting the BASE message <i>base</i> per it sources and only for matched ones to <i>srcFltr</i>.</li>
<li> <i>bool translItRemTrs( const string &amp;base, const string &amp;srcFltr = "" );</i> — Removing the BASE message <i>base</i> from the individual messages table "Trs" and only for matched sources to <i>srcFltr</i>.</li>
<li> <i>string trCtx( const string &amp;user_lang = mess_TrModifMark, bool *hold = NULL );</i> — Getting (by default) and registering(no empty)/clearing(empty) the translation context <i>user_lang</i> bound to the call pthread. <i>hold</i> can be pointed to detect the context already registered and do not clear that.</li>
<li> <i>static string labStor( bool nogen = false ); static string labStorRemGenStor( ); static string labSecCRON( ); static string labSecCRONsel( ); static string labTaskPrior( ); static string labMessCat( );</i> — Common help labels.</li>
<li> <i>int getUTF8( const string &amp;str, int off = 0, int32_t *symb = NULL );</i> — Get and parse a UTF-8 symbol.</li>
<li> <i>static string setUTF8( int32_t symb );</i> — Set, form and return a UTF-8 symbol from their code <i>symb</i>.</li></ul>
<h3><span class="mw-headline" id="Object_subsystem_.28TSubSYS.29"><span class="mw-headline-number">2.3</span> <span id="TSubSYS" title="#TSubSYS">Object subsystem (TSubSYS)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td><i><a href="#TArchiveS">TArchiveS</a>, <a href="#TProtocolS">TProtocolS</a>, <a href="#TBDS">TBDS</a>, <a href="#TFunctionS">TFunctionS</a>, <a href="#TSesurity">TSesurity</a>, <a href="#TModShedul">TModShedul</a>, <a href="#TTransportS">TTransportS</a>, <a href="#TUIS">TUIS</a>, <a href="#TSpecialS">TSpecialS</a>, <a href="#TControllerS">TControllerS</a>.</i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TSubSYS( const string &amp;id, bool mod = false );</i> — Initialize the constructor. Sign <i>mod</i> indicates that subsystem is module one. </li>
<li> <i>string subId( ) const;</i> — ID of the subsystem. </li>
<li> <i>virtual string subName( );</i> — Localized name of the subsystem.</li>
<li> <i>bool subStartStat( );</i> — Sign of the subsystem execution. </li>
<li> <i>bool subModule( ) const;</i> — Sign of the modularity of the subsystem.</li>
<li> <i>virtual int subVer( ) const;</i> — Version of the subsystems. </li>
<li> <i>virtual void subStart( );</i> — Start of the the subsystem. </li>
<li> <i>virtual void subStop( );</i> — Stop of the subsystem. </li>
<li> <i>void modList( vector &lt;string&gt; &amp;list );</i> — List <i>list</i> of the modules of the modular subsystem. </li>
<li> <i>bool modPresent( const string &amp;name );</i> — Check for the availability of the module <i>name</i>. </li>
<li> <i>void modAdd( TModule *modul );</i> — Add/registration of the module <i>modul</i>. </li>
<li> <i>void modDel( const string &amp;name );</i> — Deleting of the module <i>name</i>. </li>
<li> <i>AutoHD &lt;TModule&gt; modAt( const string &amp;name ) const;</i> — Connection to the module <i>name</i>. </li>
<li> <i>virtual void perSYSCall( unsigned int cnt );</i> —  Periodic call from system thread, with period 10 seconds and seconds counter <i>cnt</i>.</li>
<li> <i>virtual bool rdProcess( XMLNode *reqSt = NULL );</i> — Processing of redundancy of the subsystem, calls from the system's task of redundancy. <i>reqSt</i> pass a result of a state request to the redundancy station for this subsystem.</li>
<li> <i>virtual string optDescr( );</i> — Localized help on the options of the command line and parameters of the configuration file for the whole subsystem, includes its modules.</li>
<li> <i>TSYS &amp;owner( ) const;</i> — The system - the owner of the subsystem. </li></ul>
<h3><span class="mw-headline" id="Object_Module_.28TModule.29"><span class="mw-headline-number">2.4</span> <span id="TModule" title="#TModule">Object Module (TModule)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td><i><a href="#TProtocol">TProtocol</a>, <a href="#TTypeBD">TTypeBD</a>, <a href="#TTypeArchive">TTypeArchive</a>, <a href="#TTypeTransport">TTypeTransport</a>, <a href="#TUI">TUI</a>, <a href="#TSpecial">TSpecial</a>, <a href="#TTypeDAQ">TTypeDAQ</a></i>
</td></tr></table>
<p><b>Data:</b><br />
The data structure which identifies the module (class — TModule::SAt):
</p>
<ul><li> <i>SAt( const string &amp;iid, const string &amp;itype = "", int itver = 0 );</i> — initialize the constructor; </li>
<li> <i>bool operator ==(const TModule::SAt &amp;amst ) const;</i> — comparison function identifiers modules;</li>
<li> <i>string id;</i> — the identifier of the module; </li>
<li> <i>string type;</i> — the type of module (subsystem); </li>
<li> <i>int tVer;</i> — version of the type of module (subsystem) to which the module is designed. </li></ul>
<p>The structure of exported functions (class — TModule::ExpFunc):
</p>
<ul><li> <i>string prot;</i> — a prototype of the function; </li>
<li> <i>string dscr;</i> — localized description of the function; </li>
<li> <i>void (TModule::*ptr) ();</i> — relative address of the function (with respect to the object module). </li></ul>
<p><b>Public methods</b>:
</p>
<ul><li> <i>TModule( const string &amp;id );</i> — Initialize the constructor of module <i>id</i>.</li>
<li> <i>string modId( );</i> — ID of the module.</li>
<li> <i>string modName( );</i> — Localized name of the module. </li>
<li> <i>virtual void modStart( );</i> — Start of the module. </li>
<li> <i>virtual void modStop( );</i> — Stop of the module. </li>
<li> <i>virtual void modInfo( vector&lt;string&gt; &amp;list );</i> — A list of information items <i>list</i> of the module.</li>
<li> <i>virtual string modInfo (const string &amp;name );</i> — Getting the contents of the specified information item <i>name</i>. For get the item on different language, at [../ProgrammManual#h932-1 dynamic messages translation], you can set the name in way "{Name}:{lang}".</li>
<li> <i>virtual void perSYSCall( unsigned int cnt );</i> —  Periodic call from system thread, with period 10 seconds and seconds counter <i>cnt</i>.</li>
<li> <i>void modFuncList( vector&lt;string&gt; &amp;list );</i> — The list of exported functions <i>list</i> of the module.</li>
<li> <i>bool modFuncPresent( const string &amp;prot );</i> — Check the availability of the specified function by its prototype <i>prot</i>.</li>
<li> <i>ExpFunc &amp;modFunc (const string &amp; prot);</i> — Get the information about exported function of the module <i>prot</i>.</li>
<li> <i>bool modFunc( const string &amp;prot, void (TModule::**offptr)(), bool noex = false );</i> — Getting the relative address <i>offptr</i> of the exported function <i>prot</i>. Returns "true" for successful and the non-exceptional mode <i>noex</i>.</li>
<li> <i>string I18N( const string &amp;mess, const char *mLang = NULL );</i> — Localisation of modular message <i>mess</i> in accordance with the current locale and user language <i>mLang</i> in the MULTILANGUAGE modes.</li>
<li> <i>virtual string optDescr( );</i> — Localized help on the options of the command line and parameters of the configuration file for the module.</li>
<li> <i>TSubSYS &amp;owner( ) const;</i> — Subsystem - the owner of the module.</li></ul>
<p><b>Protected Attributes:</b>
</p>
<ul><li> <i>string mModName;</i> — Name of the module. </li>
<li> <i>string mModDescr;</i> — Description of the module. </li>
<li> <i>string mModType;</i> — Type of module. </li>
<li> <i>string mModVers;</i> — Version of the module. </li>
<li> <i>string mModAutor;</i> — Author of the module. </li>
<li> <i>string mModLicense;</i> — License of the module. </li>
<li> <i>string mModSource;</i> — Source/origin of the module. </li></ul>
<p><b>Protected methods are:</b>
</p>
<ul><li> <i>void modInfoMainSet( const string &amp;name, const string &amp;type, const string &amp;vers, const string &amp;author, const string &amp;descr, const string &amp;license, const string &amp;source );</i> — Main module information set.</li>
<li> <i>void modFuncReg (ExpFunc * func);</i> — Registration of the exported by module functions.</li></ul>
<h2><span class="mw-headline" id="Subsystem_.22DB.22"><span class="mw-headline-number">3</span> <span id="TBDS" title="#TBDS">Subsystem "DB"</span></span></h2>
<p>Subsystem "Databases" is represented by the object <i>TBDS</i>, which contains a modular objects of the following types of DB <i>TTypeBD</i>. Each type of database contains objects of individual databases of that type <i>TBD</i>. Each database in its turn, contains the objects of their tables <i>TTable</i> (Fig. 3).
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:370px;"><a class="image" href="http://oscada.org/wiki/File:Oscada_subsys_db_str.png"><img class="thumbimage" height="297" src="files/Oscada_subsys_db_str.png" width="368" /></a>  <div class="thumbcaption">Fig. 3. Hierarchical structure of the subsystem "DB".</div></div></div></div>
<p>The subsystem provides the basic functions to access the type of database, as well as generalized functions for the manipulation of the databases and tables. For example, to hide the source of data, which may be a configuration file, the functions of an abstract access to the data source are provided. For the storage system-wide data the system table and the function of the abstract to access it are provided. Consequently, system-wide data can be stored in the configuration file and in the database table. More about the data organisation conception you can read in the <a href="#Data">Data in OpenSCADA and their storage</a> section.
</p><p>Being a modular object, the type of database (TTypeBD) provides access to the implementation of the mechanism of one or another database. Access is made through a public databases of the module of a given type of database. Open/registered database is described in the table of databases to be opened or in the configuration file. There is, the so-called, the working database, which is always opens and is shown in the configuration file. DB which support the SQL-queries can grant access based on direct SQL-queries.
</p><p>While working, the components of OpenSCADA open tables (TTable) available in the database and work with them.
</p>
<h3><span class="mw-headline" id="Object_of_subsystem_.22Database.22_.28TBDS.29"><span class="mw-headline-number">3.1</span> <span id="TBDS" title="#TBDS">Object of subsystem "Database" (TBDS)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TSubSYS">TSubSYS</a></i>
</td></tr></table>
<p><b>Data:</b><br />
Flags of the function <i>dbList()</i> (enum – TDBS::DBLsFlg):
</p>
<ul><li> <i>LsNoFlg</i> (0) — no list flag;</li>
<li> <i>LsCheckSel</i> (0x01) —  points to the necessity of verifying the fact of boot from the selected database and to insert to the db list the only selected one;</li>
<li> <i>LsInclGenFirst</i> (0x02) — include the Generic Storage "<b>*.*</b>" in the first.</li></ul>
<p>Flags of the queries to the storage (enum – TDBS::ReqGenFlg):
</p>
<ul><li> <i>NoFlg</i> (0) — no query flag;</li>
<li> <i>NoException</i> (0x01) — do not generate the exceptions, return error result;</li>
<li> <i>OnlyCfg</i> (0x02) — force request to the configuration file, in genPrmGet(), genPrmSet() and dataSet() only;</li></ul>
<dl><dd> <i>Specific flags</i></dd></dl>
<ul><li> <i>UseTranslation</i> (0x04) — use the translation of the text variable, in genPrmGet() and genPrmSet() only;</li>
<li> <i>UseCache</i> (0x04) — use the cache, in dataSeek() only, defines the seek cache using — preloading the result in whole and significant acceleration, as the unique cacheKey this function uses the <i>cfg</i> address.</li>
<li> <i>UseAllKeys</i> (0x04) — use all keys, in dataDel() only, is used to indicate the necessity of the all keys set fro their using while deleting with the restoration of the original state of the keys selection when the function is finished. If this flag is not set, the early selected keys are used to perform the operation.</li></ul>
<p><b>Public generic static methods:</b>
</p>
<ul><li> <i>static string fullDBSYS( );</i> — The full name of the system table.</li>
<li> <i>static string fullDB( );</i> — The full name of the table with a description of the registered databases.</li>
<li> <i>static string realDBName( const string &amp;bdn, bool back = false );</i> — Conversion of the full template name of the database or table (of view *.*.myTbl) in the real name. Actually the replacement of the special elements '*' by the elements of the working DB. Use <i>back</i> for the backward conversion.</li>
<li> <i>static string dbPart( const string &amp;bdn, bool tbl = false );</i> — Getting the generic storage address part or the table at <i>tbl</i> from the common storage name <i>bdn</i>.</li>
<li> <i>static void dbList( vector&lt;string&gt; &amp;ls, char flags = LsNoFlg );</i> — List of available databases with the DBLsFlg <i>flags</i>.</li>
<li> <i>static AutoHD&lt;TTable&gt; tblOpen( const string &amp;bdn, bool create = false );</i> — Opening the table <i>bdn</i> of the storage by it full path with the creation <i>create</i> at absence.</li>
<li> <i>static void tblClose( const string &amp;bdn, bool del = false );</i> — Closing the table <i>bdn</i> of the storage by it full path with deleting at <i>del</i>.</li>
<li> <i>static bool dataSeek( const string &amp;bdn, const string &amp;path, int lev, TConfig &amp;cfg, char flags = NoFlg, XMLNode *localCfgCtx = NULL );</i> — Complete scanning of the records on the storage according to the ReqGenFlg <i>flags</i>. If the DB name <i>bdn</i> or path <i>path</i> to the Configuration File are not pointed, their processing is skipped. More about conditions of using the Configuration File and the Data Bases read in the <a href="#DataConcept">Data storing conception</a>. <i>localCfgCtx</i> is used for loading from the local configuration context, prepared in <i>dataSet()</i>, and it missing causes for checking and using, at presence, the global configuration context <i>SYS-&gt;cfgCtx()</i>.</li>
<li> <i>static bool dataGet( const string &amp;bdn, const string &amp;path, TConfig &amp;cfg, char flags = NoFlg, XMLNode *localCfgCtx = NULL );</i> — Getting the record from the storage according to the ReqGenFlg <i>flags</i>. If the DB name <i>bdn</i> or path <i>path</i> to the configuration file are not pointed, their processing is skipped. More about conditions of using the Configuration File and the Data Bases read in the <a href="#DataConcept">Data storing conception</a>. <i>localCfgCtx</i> is used for loading from the local configuration context, prepared in <i>dataSet()</i>, and it missing causes for checking and using, at presence, the global configuration context <i>SYS-&gt;cfgCtx()</i>.</li>
<li> <i>static bool dataSet( const string &amp;bdn, const string &amp;path, TConfig &amp;cfg, char flags = NoFlg, XMLNode *localCfgCtx = NULL );</i> — Setting/Saving the record to the storage according to the ReqGenFlg <i>flags</i>. If the DB name <i>bdn</i> or path <i>path</i> to the configuration file are not pointed, their processing is skipped. More about conditions of using the Configuration File and the Data Bases read in the <a href="#DataConcept">Data storing conception</a>. <i>localCfgCtx</i> is used for saving to the local configuration context, is prepared for <i>dataSeek()</i> and <i>dataGet()</i>, and it missing causes for checking and using, at presence, the global configuration context <i>SYS-&gt;cfgCtx()</i>.</li>
<li> <i>static bool dataDel( const string &amp;bdn, const string &amp;path, TConfig &amp;cfg, char flags = NoFlg );</i> — Deleting the record in the storage according to the ReqGenFlg <i>flags</i>. If the DB name <i>bdn</i> or path <i>path</i> to the configuration file are not pointed, their processing is skipped. More about conditions of using the Configuration File and the Data Bases read in the <a href="#DataConcept">Data storing conception</a>.</li>
<li> <i>static bool dataDelTbl( const string &amp;bdn, const string &amp;path = "", char flags = NoFlg );</i> — The data container table common removing from the storage <i>bbn</i> and the configuration file <i>path</i>, according to the ReqGenFlg <i>flags</i>.</li>
<li> <i>static string genPrmGet( const string &amp;path, const string &amp;oval = "", const string &amp;user = "root", char flags = NoFlg );</i> — Getting the generic parameter <i>path</i> from the Generic Storage "<b>*.*.SYS</b>" on behalf of the <i>user</i> and according to the ReqGenFlg <i>flags</i>. If the data are not available the value <i>oval</i> is returned. On the Configuration File there are used the object parameters by the tags "prm" and on the Data Base there is used the table "SYS".</li>
<li> <i>static void genPrmSet( const string &amp;path, const string &amp;val, const string &amp;user = "root", char flags = NoFlg );</i> — Setting/Saving the generic parameter <i>path</i> to the Generic Storage "<b>*.*.SYS</b>" of the <i>user</i> and according to the ReqGenFlg <i>flags</i>.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>int subVer( );</i> — Subsystem version.</li>
<li> <i>int tblLifeTime( );</i> — Lifetime of the inactive tables closing, in seconds.</li>
<li> <i>void setTblLifeTime( int vl );</i> — Sets lifetime of the inactive tables closing in <i>vl</i> seconds.</li>
<li> <i>TElem &amp;openDB_E( )</i> — The structure of the table of registered databases.</li>
<li> <i>AutoHD&lt;TTypeBD&gt; at( const string &amp;iid )</i> — Referencing to the DB module(DB type).</li></ul>
<h3><span class="mw-headline" id="Modular_object_of_types_of_databases_.28TTypeBD.29"><span class="mw-headline-number">3.2</span> <span id="TTypeBD" title="#TTypeBD">Modular object of types of databases (TTypeBD)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TModule">TModule</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By root objects of the modules of subsystem "DB".
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>string features( );</i> — Keyword list of features supported by the DB.</li>
<li> <i>virtual int lsPr( )</i> — The DB priority base [0...9] in the generic storages list.</li>
<li> <i>bool fullDeleteDB( );</i> — Sign of the complete removal of the database.</li>
<li> <i>void list( vector&lt;string&gt; &amp;list ) const;</i> — The list of registered (opened) databases.</li>
<li> <i>bool openStat( const string &amp;idb ) const;</i> — Check the availability of the specified opened database.</li>
<li> <i>string open( const string &amp;id );</i> — Opening of the database. Returns the end created identifier.</li>
<li> <i>void close( const string &amp;id, bool erase = false );</i> — Closing the database. If the sign <i>erase</i> is set, the database will be completely removed.</li>
<li> <i>AutoHD&lt;TBD&gt; at( const string &amp;id ) const;</i> — Connection to the opened database.</li>
<li> <i>TBDS &amp;owner( ) const;</i> — Subsystem - the owner of the module.</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_database_.28TBD.29"><span class="mw-headline-number">3.3</span> <span id="TBD" title="#TBD">The object of the database (TBD)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a>, <a href="#TConfig">TConfig</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By the database objects of the modules of subsystem "DB".
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TBD( const string &amp;iid, TElem *cf_el );</i> — Initializing constructor.</li>
<li> <i>string id( );</i> — DB identifier.</li>
<li> <i>string fullDBName( );</i> — Full name a storage-DB.</li>
<li> <i>string name( );</i> — DB name.</li>
<li> <i>string dscr( );</i> — DB description.</li>
<li> <i>string addr( ) const;</i> — Address of the database. The form of recording is different for each type of database.</li>
<li> <i>string codePage( );</i> — Codepage in which the data of the database are stored.</li>
<li> <i>int lsPr( );</i> — The DB priority in the generic storages list, in the range [0...99].</li>
<li> <i>double trTm_ClsOnOpen( );</i> — Transaction closing: after opening, seconds.</li>
<li> <i>double trTm_ClsOnReq( );</i> — Transaction closing: after request, seconds.</li>
<li> <i>int trPr_ClsTask( );</i> — Transaction closing: separate task priority.</li>
<li> <i>bool enableStat( ) const;</i> — The state of the database: "Enabled".</li>
<li> <i>bool toEnable( );</i> — Sign of the DB: "To Enable".</li>
<li> <i>bool disabledByUser( );</i> — Sign of the node disabling by user, to prevent its enabling restore.</li>
<li> <i>void setName( const string &amp;inm );</i> — Setting the DB name.</li>
<li> <i>void setDscr( const string &amp;idscr );</i> — Setting the DB description.</li>
<li> <i>void setAddr( const string &amp;iaddr );</i> — Setting the DB address.</li>
<li> <i>void setCodePage( const string &amp;icp );</i> — Setting of the codepage for the storage of the DB data.</li>
<li> <i>void setLsPr( int vl );</i> — Setting the DB priority in the generic storages list, in the range [0...99].</li>
<li> <i>void setToEnable( bool ivl );</i> — Setting of the sign: "To Enable".</li>
<li> <i>virtual void enable( );</i> — Enabling of the DB.</li>
<li> <i>virtual void disable( );</i> — Disabling of the DB.</li>
<li> <i>virtual void allowList( vector&lt;string&gt; &amp;list ) const;</i> — The list of the tables in this DB.</li>
<li> <i>void list( vector&lt;string&gt; &amp;list ) const;</i> — The list of opened tables.</li>
<li> <i>bool openStat( const string &amp;table ) const;</i> — The sign that indicates of the fact that the requested table is opened.</li>
<li> <i>virtual void open( const string &amp;table, bool create );</i> — Opening of the table. If the sign <i>create</i> is set, in the case of absence the table will be created.</li>
<li> <i>virtual void close( const string &amp;table, bool del = false, long tm = -1 );</i> — Closing of the table. If the sign <i>del</i> is set, the table will be completely removed.</li>
<li> <i>AutoHD&lt;TTable&gt; at( const string &amp;name ) const;</i> — Connection to the table.</li>
<li> <i>virtual void sqlReq( const string &amp;req, vector&lt; vector&lt;string&gt; &gt; *tbl = NULL, char intoTrans = EVAL_BOOL );</i> — Sending the SQL-request <i>req</i> to the DB and receiving the result in tabular form <i>tbl</i>. If set <i>intoTrans</i> to true then will open transaction for the request, else if set to false then transaction will close.</li>
<li> <i>virtual void transCloseCheck( )</i> — The function call periodic for opened transaction check to close for old transaction or overloaded.</li>
<li> <i>TTypeBD &amp;owner( ) const;</i> — DB type – the owner of the DB.</li></ul>
<p><b>Protected attributes:</b>
</p>
<ul><li> <i>ResMtx resTbls, connRes;</i> — locks of the table and connection resources.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>virtual TTable *openTable( const string &amp;table, bool create );</i> — The modular method for opening the table.</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_table_.28TTable.29"><span class="mw-headline-number">3.4</span> <span id="TTable" title="#TTable">The object of the table (TTable)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By tables objects of the modules of subsystem "DB".
</td></tr></table>
<p><b>Data:</b><br />
Flags of the SQL requests (enum – TTable::SQLFeqFlag):
</p>
<ul><li> <i>SQLNoFlg</i> (0) — no list flag;</li>
<li> <i>SQLOrderForSeek</i> (0x01) — sort-order the records at all requested fields, needed for PostgreSQL in the limiting SEEK requests;</li>
<li> <i>SQLFirstSkipForSeek</i> (0x02) — use the FIRST and SKIP SELECT operators, needed for FireBird in the limiting SEEK requests.</li></ul>
<p>Item of the table structure (class — TTable::TStrIt):
</p>
<ul><li> <i>string nm, tp, def;</i> — field name, type and the default value;</li>
<li> <i>int key;</i> — field key;</li>
<li> <i>TStrIt( )</i> — constructor by default;</li>
<li> <i>TStrIt( const string &amp;inm, const string itp, int ikey, const string &amp;idef = "" )</i> — the main parametric constructor.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TTable( const string &amp;name );</i> — Initializing constructor.</li>
<li> <i>string name( );</i> — Table name.</li>
<li> <i>string fullDBName( );</i> — Full name a storage-table into DB.</li>
<li> <i>virtual void fieldStruct( TConfig &amp;cfg );</i> — Getting the structure of the table.</li>
<li> <i>virtual bool fieldSeek( int row, TConfig &amp;cfg, const string &amp;cacheKey = "" );</i> — Scanning the records <i>cfg</i> of the table by <i>row</i>, where <i>cacheKey</i> defines the seek cache using — preloading the result in whole and significant acceleration.</li>
<li> <i>virtual void fieldGet( TConfig &amp;cfg );</i> — Request the specified record. The requested record is determined by the values of key cells of the original record <i>cfg</i>.</li>
<li> <i>virtual void fieldSet( TConfig &amp;cfg );</i> — Setting the values of the specified record. In the case of absence the record will be removed.</li>
<li> <i>virtual void fieldDel( TConfig &amp;cfg );</i> — Deleting of the specified record.</li>
<li> <i>virtual void fieldFix( TConfig &amp;cfg, const string &amp;langLs = "" );</i> — Internal request declaration of fixing fields, for the SQL request mostly. Use <i>langLs</i> for the languages list separated by ';' to create the corresponded translation columns.</li>
<li> <i>TBD &amp;owner( ) const;</i> — DB – the owner of the table.</li>
<li> <i>virtual string getSQLVal( TCfg &amp;cf, uint8_t RqFlg = 0 );</i> — Get the SQL encoded value from <i>cf</i> for placing to the SQL request.</li>
<li> <i>virtual void setSQLVal( TCfg &amp;cf, const string &amp;vl, bool tr = false );</i> — Set the SQL encoded value to <i>cf</i> from the SQL response table.</li>
<li> <i>bool fieldSQLSeek( int row, TConfig &amp;cfg, const string &amp;cacheKey, int flags = SQLNoFlg );</i> — Unified-ANSI SQL variant of the fieldSeek() request with the TTable::SQLFeqFlag <i>flags</i>, which implements also the OpenSCADA multilaguage translation (the "TR" feature).</li>
<li> <i>void fieldSQLGet( TConfig &amp;cfg );</i> — Unified-ANSI SQL variant of the fieldGet() request, which implements also the OpenSCADA multilaguage translation (the "TR" feature).</li>
<li> <i>void fieldSQLSet( TConfig &amp;cfg );</i> — Unified-ANSI SQL variant of the fieldSet() request, which implements also the OpenSCADA multilaguage translation (the "TR" feature).</li>
<li> <i>void fieldSQLDel( TConfig &amp;cfg );</i> — Unified-ANSI SQL variant of the fieldDel() request.</li></ul>
<p><b>Protected attributes:</b>
</p>
<ul><li> <i>time_t mLstUse;</i> — time of the last usage;</li>
<li> <i>vector&lt;TStrIt&gt; tblStrct;</i> — table structure, list of the table items;</li>
<li> <i>map&lt;string, vector&lt; vector&lt;string&gt; &gt; &gt;</i> — container of the SEEK sessions in the PRELOAD mode;</li></ul>
<h2><span class="mw-headline" id="Subsystem_.22Data_acquisition.22"><span class="mw-headline-number">4</span> Subsystem "Data acquisition"</span></h2>
<p>The subsystem "Data acquisition" is represented by the <i>TDAQS</i> object which contains modular objects of the data sources' types <i>TTypeDAQ</i> and the objects of the libraries of parameters' templates of subsystem "Data acquisition" <i>TPrmTmplLib</i>. Object of the data sources types contains objects of the controllers TController and objects of the  parameters' types <i>TTypeParam</i>. Parameters' types objects are provided by the controller module and contain the DB structure of the separate parameters' types (analog, digital ...). Controllers' objects contain parameters' objects <i>TParamContr</i>. Each parameter is associated with only one type of the parameter. For the attribute storage parameter is inherited from the values object <i>TValue</i>, which contains the attributes' values <i>TVal</i>. The library of the parameters' templates of this subsystem contains templates' objects <i>TPrmTmpl</i>. An example of the described hierarchical structure is shown in Fig. 4.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:309px;"><a class="image" href="http://oscada.org/wiki/File:Oscada_subsys_daq_str.png"><img class="thumbimage" height="335" src="files/Oscada_subsys_daq_str.png" width="307" /></a>  <div class="thumbcaption">Fig. 4. Hierarchical structure of the subsystem "Data acquisition".</div></div></div></div>
<p>Subsystem contains the types of data sources. The source may be virtually any substance providing any data. Type of source can be divided into individual sources (controllers) within the limits of the particular type. For example, if we take the data from the operating system (OS), then the single source can be the separate operating system of the separate PC.
</p><p>Data source (controller) is further divided (contains) into the parameters. The parameter is the part of the data source. In the case of the OS it will be, for example,: used RAM, the processor's frequency and many other parts.
</p><p>Parameter, in its turn, contains the attributes, which provide the data. In addition to the basic data attributes can provide the related or detailing data. In the case of the same operating system and the memory usage, the attributes may not only provide the used memory, and also how much it all, how much in the swap, etc.
</p><p>Some of the implementation of the data sources may provide the possibility of setting the structure of the parameter based on previously developed parameters' templates. For this purpose subsystem contains templates' libraries, which, in their turn, provide the parameters' templates . The example shows a library of templates "base" with the templates "digAlrm" and "smplBrd".
</p><p>At the level of the subsystem the redundancy mechanism for data sources is provided. Redundancy means the possibility of coordinated work of several OpenSCADA stations to perform common task of data acquisition from the same data sources.
</p>
<h3><span class="mw-headline" id="Object_of_subsystem_.22Data_acquisition.22_.28TDAQS.29"><span class="mw-headline-number">4.1</span> <span id="TDAQS" title="#TDAQS">Object of subsystem "Data acquisition" (TDAQS)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TSubSYS">TSubSYS</a></i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>int subVer( );</i> — Version of the subsystem.</li>
<li> <i>void subStart( );</i> — Start the subsystem.</li>
<li> <i>void subStop( );</i> — Stop the subsystem.</li>
<li> <i>AutoHD&lt;TTypeDAQ&gt; at( const string &amp;name ) const;</i> — Connection to the type of data source.</li>
<li> <i>AutoHD&lt;TValue&gt; prmAt( const string &amp;path, char sep = 0, bool noex = false ) const;</i> — Connection to the parameter by <i>path</i> or separated by <i>sep</i> string. Do not throw an exceptions if set <i>noex</i>.</li>
<li> <i>AutoHD&lt;TVal&gt; attrAt( const string &amp;path, char sep = 0, bool noex = false ) const;</i> — Connection to the parameter's attribute by <i>path</i> or separated by <i>sep</i> string. Do not throw an exceptions if set <i>noex</i>.</li>
<li> <i>void ctrListPrmAttr( XMLNode *nd, const string &amp;addrBase, bool toPrm = false, char sep = 0, const string &amp;pref = "" );</i> — Browsing list for items of attributes of parameters or only the parameters DAQ by <i>toPrm</i> with prefix <i>pref</i> from path or separated by <i>sep</i> string from base address <i>addrBase</i>. </li>
<li> <i>string tmplLibTable( );</i> — Name of table to store the parameters' templates  of the subsystem "Data acquisition".</li>
<li> <i>void tmplLibList( vector&lt;string&gt; &amp;list ) const;</i> — The list of available parameters' templates.</li>
<li> <i>bool tmplLibPresent( const string &amp;id ) const;</i> — Check the availability of the parameter's template <i>id</i>.</li>
<li> <i>void tmplLibReg( TPrmTmplLib *lib );</i> — Registration of the parameter's template <i>lib</i>.</li>
<li> <i>void tmplLibUnreg( const string &amp;id, int flags = NodeNoFlg );</i> — Deleting/removing of the registration of the parameter's template <i>id</i>, according to the <i>flags</i>.</li>
<li> <i>AutoHD&lt;TPrmTmplLib&gt; tmplLibAt( const string &amp;id ) const;</i> — Connection to the parameter's template <i>id</i>.</li>
<li> <i>double rdRestDtTm( );</i> — Maximum depth of the archive data recovery when starting in hours.</li>
<li> <i>void setRdRestDtTm( double vl );</i> — Set of the maximum depth of the archive data recovery when starting in hours.</li>
<li> <i>void rdActCntrList( vector&lt;string&gt; &amp;ls, bool isRun = false );</i> — The list of active controllers working in the redundancy scheme. When we indicate <i>isRun</i> there will be in the list only running controllers in this station.</li>
<li> <i>string rdStRequest( const string &amp;cntr, XMLNode &amp;req, const string &amp;prevSt = "", bool toRun = true );</i> — Request <i>req</i> to the redundant station on behalf of the controller <i>cntr</i>. The station for the request is selected after specified in <i>prevSt</i> for the running remote controller when indicating <i>toRun</i>.</li>
<li> <i>TElem &amp;elLib( );</i> — The structure of the table of the libraries if parameters' templates.</li>
<li> <i>TElem &amp;elTmpl( );</i> — The structure of the table of  parameters' templates.</li>
<li> <i>TElem &amp;elTmplIO( );</i> — The structure of the attributes of parameters' templates.</li>
<li> <i>TElem &amp;elErr( );</i> — The structure of the attribute(s) of parameters' errors.</li></ul>
<h3><span class="mw-headline" id="Modular_object_of_the_controller.27s_type_.28TTypeDAQ.29"><span class="mw-headline-number">4.2</span> <span id="TTypeDAQ" title="#TTypeDAQ">Modular object of the controller's type (TTypeDAQ)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TModule">TModule</a>, <a href="#TElem">TElem</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>Root object of the modules of subsystem "Data acquisition".
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>string DAQPath( );</i> — Getting for DAQ-address of the element.</li>
<li> <i>void modStart( );</i> — Start of the module.</li>
<li> <i>void modStop( );</i> — Stop of the module.</li>
<li> <i>void list( vector&lt;string&gt; &amp;list ) const;</i> — The list of the controllers.</li>
<li> <i>bool present( const string &amp;id ) const;</i> — Check for the availability of the specified controller object.</li>
<li> <i>string add( const string &amp;id, const string &amp;daq_db = "*.*" );</i> — Add the controller object. Returns the end created identifier.</li>
<li> <i>void del( const string &amp;id );</i> — Delete the controller object.</li>
<li> <i>AutoHD&lt;TController&gt; at( const string &amp;id, const string &amp;who = "" ) const;</i> — Connect to the controller object.</li>
<li> <i>bool tpPrmPresent( const string &amp;name_t );</i> — Check for the availability of the specified controller type.</li>
<li> <i>unsigned tpPrmToId( const string &amp;name_t );</i> — Getting of the index of the parameters' types by their names.</li>
<li> <i>int tpParmAdd( const char *id, const char *n_db, const char *name );</i> — Addition/registration of the parameters' types.</li>
<li> <i>unsigned tpPrmSize( );</i> — Quantity of the parameters' types.</li>
<li> <i>TTypeParam &amp;tpPrmAt( unsigned id );</i> — Get the object of the parameters' type.</li>
<li> <i>virtual bool compileFuncLangs( vector&lt;string&gt; *ls = NULL );</i> — Request of the list of languages for which it is realized the possibility of formation of user procedures in this module, and check for it support fact.</li>
<li> <i>virtual void compileFuncSnthHgl( const string &amp;lang, XMLNode &amp;shgl );</i> — The rules of syntax highlight request for specifying language.</li>
<li> <i>virtual string compileFunc( const string &amp;lang, TFunction &amp;fnc_cfg, const string &amp;prog_text, const string &amp;usings = "", int maxCalcTm = 0 );</i> — Compiling/setup of the user function on the supported programming language <i>lang</i> and on the source code of procedure <i>prog_text</i>, based on the parameters of procedure <i>fnc_cfg</i>. The result is the address to the prepared function object.</li>
<li> <i>virtual bool redntAllow( );</i> — The indication of support of redundancy mechanisms by the module. It must be simply overridden and return <b>true</b>.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>virtual TController *ContrAttach( const string &amp;name, const string &amp;daq_db );</i> — Connecting of the controller. It must be obligatory overridden in the descendant of the module.</li></ul>
<h3><span class="mw-headline" id="Controller.27s_object_.28TController.29"><span class="mw-headline-number">4.3</span> <span id="TController" title="#TController">Controller's object (TController)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a>, <a href="#TConfig">TConfig</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>Objects of the modules of subsystem "Data acquisition".
</td></tr></table>
<p><b>Data:</b><br />
Redundancy modes (enum TController::Redundant):
</p>
<ul><li> <i>Off (0)</i> — Turned off;</li>
<li> <i>Asymmetric (1)</i> — asymmetric;</li>
<li> <i>OnlyAlarms (2)</i> — only alarms, suppressing on the reserve.</li></ul>
<dl><dd><i>Command specific</i></dd></dl>
<ul><li> <i>Any (0)</i> — any mode.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TController( const string &amp;name_c, const string &amp;daq_db, TElem *cfgelem );</i> — Initializing constructor of the controller.</li>
<li> <i>string DAQPath( );</i> — Getting for DAQ-address of the element.</li>
<li> <i>string id( );</i> — Controller ID.</li>
<li> <i>string workId( );</i> — Work ID of the controller, including the ID of the module.</li>
<li> <i>string name( );</i> — Controller's name.</li>
<li> <i>string descr( );</i> — Controller's description.</li>
<li> <i>int64_t timeStamp( );</i> — Timestamp of the object changing as maximum of timestamps of the included parameter objects.</li>
<li> <i>virtual string getStatus( );</i> — Request function of the controller's status.</li>
<li> <i>string DB( bool qTop = false ) const;</i> — Storage name of the controller's instance, <i>qTop</i> for the storage queue top.</li>
<li> <i>string tbl( ) const;</i> — The name of the table of DB of the controller's instance.</li>
<li> <i>string fullDB( bool qTop = false ) const;</i> — The full name of the table of storage of the controller's instance, <i>qTop</i> for the storage queue top.</li>
<li> <i>void setName( const string &amp;nm );</i> — Set the controller's name.</li>
<li> <i>void setDescr( const string &amp;dscr );</i> — Set the controller's description.</li>
<li> <i>void setDB( const string &amp;vl, bool qTop = false );</i> — Setting of the storage name of the controller's instance, <i>qTop</i> for the storage queue top.</li>
<li> <i>bool toEnable( );</i> — Sign "To enable the controller".</li>
<li> <i>bool toStart( );</i> — Sign "To start the controller".</li>
<li> <i>bool enableStat( ) const;</i> — Status "Enable".</li>
<li> <i>bool startStat( );</i> — Status "Run".</li>
<li> <i>int messLev( );</i> — Messages level of diagnostic information.</li>
<li> <i>void start( );</i> — Controller's start.</li>
<li> <i>void stop( );</i> — Controller's stop.</li>
<li> <i>void enable( );</i> — Controller's enabling.</li>
<li> <i>void disable( );</i> — Controller's stopping.</li>
<li> <i>void list( vector&lt;string&gt; &amp;list ) const;</i> — Parameter's list in the controller.</li>
<li> <i>bool present( const string &amp;id ) const;</i> — Check for the availability of the parameter <i>id</i>.</li>
<li> <i>string add( const string &amp;id, unsigned type );</i> — Addition the parameter <i>id</i> of the type <i>type</i>. Returns the end created identifier.</li>
<li> <i>void del( const string &amp;id, int flags = NodeNoFlg );</i> — Deleting the parameter <i>id</i>, according the {TCntrNode,TParamContr}::EnDisFlag <i>flags</i>.</li>
<li> <i>AutoHD&lt;TParamContr&gt; at( const string &amp;id, const string &amp;who = "th_contr" ) const;</i> — Connection to the controller's parameter <i>id</i>.</li>
<li> <i>bool redntUse( Redundant md = Asymmetric );</i> — Redundancy state for mode <i>md</i>.</li>
<li> <i>void setRedntUse( bool vl );</i> — Changing of the getting the data from the backup station mode.</li>
<li> <i>Redundant redntMode( );</i> — Redundancy mode ("&lt;high&gt;", "&lt;low&gt;", "&lt;optimal&gt;", {ForceStation}), enabling.</li>
<li> <i>void setRedntMode( Redundant vl );</i> — Setting of the redundancy mode, enabling.</li>
<li> <i>string redntRun( );</i> — Configuration of the preferred execution.</li>
<li> <i>void setRedntRun( const string &amp;vl );</i> — Setting the configuration of the preferred execution.</li>
<li> <i>virtual void redntDataUpdate( );</i> — An operation of the data receiving from the backup station execution. It is called automatically by the service procedure of the redundancy scheme of the subsystem.</li>
<li> <i>virtual string catsPat( );</i> — regular expression rules separated '|' list for the object's generated messages math by category.</li>
<li> <i>virtual void messSet( const string &amp;mess, int lev, const string &amp;type2Code = "OP", const string &amp;prm = "", const string &amp;cat = "" );</i> — Formation of the DAQ-sourced messages for the parameter object <i>prm</i> (<b>{PrmId}</b>), or the controller object in whole if the object is not specified, the message <i>mess</i>, level <i>lev</i> and for the type code <i>type2Code</i>. This function generates the messages with the unified DAQ-transparency category <b>{type2Code}{ModId}:{CntrId}[.{prm}][:{cat}]</b>.</li>
<li> <i>void alarmSet( const string &amp;mess, int lev = -TMess::Crit, const string &amp;prm = "", bool force = false );</i> — Formation of alarms (a violation) for the parameter object <i>prm</i> (<b>{PrmId}\n{PrmNm}</b>), or the controller object in whole if the object is not specified, the message <i>mess</i> and level <i>lev</i>. The negative value of the level <i>lev</i> is used to set and positive for removal of the violation. This function generates the violation and message with the category <b>al{ModId}:{CntrId}[.{prm}]</b> and the text <b>{CntrNm} &gt; {PrmNm}: {MessText}</b>. The alarms clearance, as the setting also, works in the toggling mode, so means of passing the clearance messages to the message buffer, and the same clearance, only at the according violations presence, what may be disabled setting <i>force</i>.</li>
<li> <i>TTypeDAQ &amp;owner( ) const;</i> — The type of the data source (module) - the owner of the controller.</li></ul>
<p><b>Protected attributes:</b>
</p>
<ul><li> <i>bool enSt;</i> — The sign "Enable".</li>
<li> <i>bool runSt;</i> — The sign "Running".</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>virtual void enable_(  );</i> — Enabling of the controller. Intercepted by the child.</li>
<li> <i>virtual void disable_(  );</i> — Disabling of the controller. Intercepted by the child.</li>
<li> <i>virtual void start_( );</i> — Starting of the controller. Intercepted by the child.</li>
<li> <i>virtual void stop_( );</i> — Stopping of the controller. Intercepted by the child.</li>
<li> <i>virtual TParamContr *ParamAttach( const string &amp;name, int type );</i> — Modular method of the creation/opening of the new parameter.</li></ul>
<h3><span class="mw-headline" id="Parameters.27_type_object_.28TTypeParam.29"><span class="mw-headline-number">4.4</span> <span id="TTypeParam" title="#TTypeParam">Parameters' type object (TTypeParam)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TElem">TElem</a></i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TTypeParam( const char *iid, const char *iname, const char *idb = "", bool i_isPrmCntr = false );</i> — Initializing constructor.</li>
<li> <i>virtual void create( TParamContr *prm );</i> — Create or set the parameter <i>prm</i> type.</li>
<li> <i>virtual void destroy( TParamContr *prm );</i> — Remove or clean the parameter <i>prm</i> type.</li>
<li> <i>virtual string DB( TController *cntr );</i> — Get table name of the parameters of the controller <i>cntr</i>.</li>
<li> <i>void setDB( TController *cntr, const string &amp;vl );</i> — Set the table name of the parameters of the controller <i>cntr</i>.</li>
<li> <i>virtual void enable( TParamContr *prm );</i> — To enable the parameter <i>prm</i>.</li>
<li> <i>virtual void disable( TParamContr *prm );</i> — To disable the parameter <i>prm</i>.</li>
<li> <i>virtual bool cfgChange( TParamContr *prm, TCfg &amp;cfg );</i> — The configuration filed <i>cfg</i> of the parameter <i>prm</i> change.</li>
<li> <i>virtual void vlGet( TParamContr *prm, TVal &amp;vo );</i> — Predicting function of the value getting, through the parameter <i>prm</i>. It is used for direct (synchronous) reading.</li>
<li> <i>virtual void vlSet( TParamContr *prm, TVal &amp;vo, const TVariant &amp;vl, const TVariant &amp;pvl );</i> — Predicting function of the value setting, through the parameter <i>prm</i>. It is used for direct (synchronous) writing <i>vl</i> with the previous value into <i>pvl</i>.</li>
<li> <i>bool vlSetRednt( TVal &amp;vo, const TVariant &amp;vl, const TVariant &amp;pvl );</i> — Processing of the values setting, mostly in the predicting function, under the redundancy. Returns true at processing the setting in the redundancy.</li>
<li> <i>virtual void vlArchMake( TParamContr *prm, TVal &amp;val );</i> — Notifying function of the creation of the archive for the <i>val</i> attribute, through parameter <i>prm</i>. It is used to configure the created archive in accordance with the peculiarities of the data source.</li>
<li> <i>virtual void getVals( TParamContr *prm );</i> — Asynchronous mode internal realization, called into the controller object cycle for parameter <i>prm</i>.</li>
<li> <i>virtual bool cntrCmdProc( TParamContr *prm, XMLNode *opt );</i> — Function of requests' processing of the control interface, from parameter <i>prm</i>.</li></ul>
<p><b>Public attributes:</b>
</p>
<ul><li> <i>string name;</i> — Parameter's type name.</li>
<li> <i>string descr;</i> — Parameter's type description.</li>
<li> <i>string db;</i> — DB of the parameter's type.</li></ul>
<h3><span class="mw-headline" id="Object_of_the_physical_level_parameter_.28TParamContr.29"><span class="mw-headline-number">4.5</span> <span id="TParamContr" title="#TParamContr">Object of the physical level parameter (TParamContr)</span></span></h3>
<table class="wikitable">

<tr>
<td> <b>Inherits:</b> </td>
<td> <i><a href="#TConfig">TConfig</a>, <a href="#TValue">TValue</a></i>
</td></tr>
<tr>
<td> <b>Inherited:</b> </td>
<td> Objects of the module's parameters of subsystem "Data acquisition".
</td></tr></table>
<p><b>Data:</b><br />
Flags of the enabling/disabling modes of the node (enum TParamContr::EnDisFlag):
</p>
<ul><li> <i>TParamContr::NodeRemove_NoArch</i> (TCntrNode::NodeSpecific) — do not remove archives at the DAQ-Parameter node removing.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TParamContr( const string &amp;name, TTypeParam *tpprm );</i> — Initializing constructor.</li>
<li> <i>string DAQPath( );</i> — Getting for DAQ-address of the element.</li>
<li> <i>string ownerPath( bool inclSelf = false );</i> — The parameter-owner path, include <i>inclSelf</i> the parameter.</li>
<li> <i>bool operator==( TParamContr &amp; PrmCntr );</i> — Parameter's comparison.</li>
<li> <i>string id( );</i> — Parameter's ID (key).</li>
<li> <i>string name( );</i> — Parameter's name.</li>
<li> <i>string descr( );</i> — Parameter's description.</li>
<li> <i>bool toEnable( );</i> — Sign "To enable parameter".</li>
<li> <i>int64_t timeStamp( );</i> — Timestamp of the object changing accounting the included parameter objects.</li>
<li> <i>bool enableStat( ) const;</i> — Status "Enable".</li>
<li> <i>void setName( const string &amp;inm );</i> — Setting of the parameter's name.</li>
<li> <i>void setDescr( const string &amp;idsc );</i> — Setting of the parameter's description.</li>
<li> <i>void setToEnable( bool vl );</i> — Setting of the sign "To enable the parameter".</li>
<li> <i>void list( vector&lt;string&gt; &amp;list ) const;</i> — Parameter's list in the parameter.</li>
<li> <i>bool present( const string &amp;id ) const;</i> — Check for the availability of the parameter <i>id</i>.</li>
<li> <i>string add( const string &amp;id, unsigned type = 0 );</i> — Addition of the parameter <i>id</i> of the type <i>type</i>. Returns the end created identifier.</li>
<li> <i>void del( const string &amp;id, int flags = NodeNoFlg );</i> — Deleting the parameter <i>id</i>, according the {TCntrNode,TParamContr}::EnDisFlag <i>flags</i>.</li>
<li> <i>AutoHD&lt;TParamContr&gt; at( const string &amp;id, const string &amp;who = "th_prm" ) const;</i> — Connection to the controller's parameter <i>id</i>.</li>
<li> <i>TTypeParam &amp;type( ) const;</i> — Parameter's type.</li>
<li> <i>virtual TElem *dynElCntr( );</i> — Container of the dynamic elements of the DAQ attributes.</li>
<li> <i>virtual void enable( );</i> — To enable parameter.</li>
<li> <i>virtual void disable( );</i> — To disable parameter.</li>
<li> <i>TController &amp;owner( ) const;</i> — Controller – the parameter's owner.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>virtual void setType( const string &amp;tpId );</i> — is called to change the parameter type <i>tpId</i> and can be processed in the object module for self data change.</li></ul>
<h3><span class="mw-headline" id="Object_of_the_value_.28TValue.29"><span class="mw-headline-number">4.6</span> <span id="TValue" title="#TValue">Object of the value (TValue)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a>, <a href="#TValElem">TValElem</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td><i><a href="#TParamContr">TParamContr</a></i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>bool dataActive( );</i> — Activity (updatable) flag of data.</li>
<li> <i>virtual string DAQPath( );</i> — Getting for DAQ-address of the element.</li>
<li> <i>void vlList( vector&lt;string&gt; &amp;list ) const;</i> — Getting the attributes' list.</li>
<li> <i>bool vlPresent( const string &amp;name ) const;</i> — Check for the availability of the specified attribute.</li>
<li> <i>AutoHD&lt;TVal&gt; vlAt( const string &amp;name ) const;</i> — Connection to the attribute.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>TConfig *vlCfg( )</i> — Getting of the associated configuration object. If NULL is returned then there is no associated configuration object.</li>
<li> <i>void setVlCfg( TConfig *cfg );</i> — Setting of the associated configuration object <i>cfg</i>.</li>
<li> <i>bool vlElemPresent( TElem *ValEl );</i> — Check for the availability if the attributes' elements <i>ValEl</i>.</li>
<li> <i>void vlElemAtt( TElem *ValEl );</i> — Attach of the data structure <i>ValEl</i>.</li>
<li> <i>void vlElemDet( TElem *ValEl );</i> — Detach of the data structure <i>ValEl</i>.</li>
<li> <i>TElem &amp;vlElem( const string &amp;name );</i> — Get the data structure by its name <i>name</i>.</li>
<li> <i>virtual TVal* vlNew( );</i> — Creation of the TVal instance. It can be overridden in the module for the creation of derived objects of the parameters' attributes of the subsystem "Data acquisition".</li>
<li> <i>virtual void vlGet( TVal &amp;vo );</i> — Predicting function of the value getting. It is used for direct (synchronous) reading.</li>
<li> <i>virtual void vlSet( TVal &amp;vo, const TVariant &amp;vl, const TVariant &amp;pvl );</i> — Predicting function of the value setting. It is used for direct (synchronous) writing <i>vl</i> with the previous value into  <i>pvl</i>.</li>
<li> <i>virtual void vlArchMake( TVal &amp;val );</i> — Notifying function of the creation of the archive for the <i>val</i> attribute. It is used to configure the created archive in accordance with the peculiarities of the data source.</li></ul>
<h3><span class="mw-headline" id="Attribute.27s_object_.28TVal.29"><span class="mw-headline-number">4.7</span> <span id="TVal" title="#TVal">Attribute's object (TVal)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a></i>
</td></tr></table>
<p><b>Data:</b><br />
Additional flags to the object TFld (enum TVal::AttrFlag):
</p>
<ul><li> <i>TVal::DirRead(0x100)</i> — Flag for the direct reading of the value;</li>
<li> <i>TVal::DirWrite(0x200)</i> — Flag for the direct writing of the value;</li>
<li> <i>TVal::Dynamic(0x400)</i> — Flag of the dynamic attribute, creates in typical from user procedures.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TVal( );</i> — Default constructor.</li>
<li> <i>TVal( TFld &amp;fld );</i> — Initialization as the repository of dynamic data.</li>
<li> <i>TVal( TCfg &amp;cfg );</i> — Initialization as the reflection of static data (DB).</li>
<li> <i>string DAQPath( );</i> — Getting for DAQ-address of the element.</li>
<li> <i>void setFld( TFld &amp;fld );</i> — Initialization as the repository of dynamic data.</li>
<li> <i>void setCfg( TCfg &amp;cfg );</i> — Initialization as the reflection of static data (DB).</li>
<li> <i>string name( );</i> — Attribute's name.</li>
<li> <i>int64_t time( );</i> — Time marker of the the last/current value (10<sup>-6</sup>s).</li>
<li> <i>bool isCfg( );</i> — Sign of the value object created in base of a configuration element.</li>
<li> <i>bool dataActive( );</i> — Activity (updatable) flag of data.</li>
<li> <i>string getSEL( long long *tm = NULL, bool sys = false );</i> — Request of the selected type value for the specified time <i>tm</i>. If NULL then it will be returned the last value.</li>
<li> <i>TVariant get( long long *tm = NULL, bool sys = false );</i> — Request of the value for the specified time <i>tm</i>. If NULL then it will be returned the last value.</li>
<li> <i>string getS( long long *tm = NULL, bool sys = false );</i> — Request of the string type value for the specified time <i>tm</i>. If NULL then it will be returned the last value.</li>
<li> <i>double getR( long long *tm = NULL, bool sys = false );</i> — Request of the real type value for the specified time <i>tm</i>. If NULL then it will be returned the last value.</li>
<li> <i>int64_t getI( long long *tm = NULL, bool sys = false );</i> — Request of the integer type value for the specified time <i>tm</i>. If NULL then it will be returned the last value.</li>
<li> <i>char getB( long long *tm = NULL, bool sys = false );</i> — Request of the boolean type value for the specified time <i>tm</i>. If NULL then it will be returned the last value.</li>
<li> <i>AutoHD&lt;TVarObj&gt; getO( int64_t *tm = NULL, bool sys = false );</i> — Request of the object type value.</li>
<li> <i>void setSEL( const string &amp;value, long long tm = 0, bool sys = false );</i> — Setting of the selected type value <i>value</i>.</li>
<li> <i>void set( const TVariant &amp;value, long long tm = 0, bool sys = false );</i> — Setting of the value <i>value</i>.</li>
<li> <i>void setS( const string &amp;value, long long tm = 0, bool sys = false );</i> — Setting of the string type value <i>value</i>.</li>
<li> <i>void setR( double value, long long tm = 0, bool sys = false );</i> — Setting of the real type value <i>value</i>.</li>
<li> <i>void setI( int64_t value, long long tm = 0, bool sys = false );</i> — Setting of the integer type value <i>value</i>.</li>
<li> <i>void setB( char value, long long tm = 0, bool sys = false );</i> — Setting of the boolean type value <i>value</i>.</li>
<li> <i>void setO( AutoHD&lt;TVarObj&gt; value, int64_t tm = 0, bool sys = false );</i> — Setting of the object type value <i>value</i>.</li>
<li> <i>AutoHD&lt;TVArchive&gt; arch( );</i> — Getting the associated with the value archive.</li>
<li> <i>void setArch( const AutoHD&lt;TVArchive&gt; &amp;vl );</i> — Setting the associated with the value archive.</li>
<li> <i>string setArch( const string &amp;nm = "" );</i> — Setting/creation new archive with proposed name <i>nm</i> or automatic, if name empty.</li>
<li> <i>bool reqFlg( ); bool resB1( ); bool resB2( )</i> — Get some realisation-specific flags.</li>
<li> <i>void setReqFlg( bool vl ); void setResB1( bool vl ); void setResB2( bool vl )</i> — Set some realization-specific flags.</li>
<li> <i>TFld &amp;fld( );</i> — Descriptor of the attribute's structure.</li></ul>
<h3><span class="mw-headline" id="Object_of_the_templates_library_of_parameters_of_the_.22DAQ.22_subsystem_.28TPrmTmplLib.29"><span class="mw-headline-number">4.8</span> <span id="TPrmTmplLib" title="#TPrmTmplLib">Object of the templates library of parameters of the "DAQ" subsystem (TPrmTmplLib)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a>, <a href="#TConfig">TConfig</a></i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TPrmTmplLib( const char *id, const char *name, const string &amp;lib_db );</i> — Initializing constructor.</li>
<li> <i>string id( );</i> — Library ID.</li>
<li> <i>string name( );</i> — Library name.</li>
<li> <i>string descr( );</i> — Library description.</li>
<li> <i>string DB( bool qTop = false ) const;</i> — DB of the library instance, <i>qTop</i> for the storage queue top.</li>
<li> <i>string tbl( ) const;</i> — DB table of the library instance.</li>
<li> <i>string fullDB( bool qTop = false ) const;</i> — Full address of the DB table of the library instance, <i>qTop</i> for the storage queue top.</li>
<li> <i>bool startStat( );</i> — Sign "Library started".</li>
<li> <i>void start( bool val );</i> — Satart/stop of the library.</li>
<li> <i>void setName( const string &amp;vl );</i> — Setting of the library name.</li>
<li> <i>void setDescr( const string &amp;vl );</i> — Setting of the library description.</li>
<li> <i>void setDB( const string &amp;vl, bool qTop = false );</i> — Setting of the storage name of the library, <i>qTop</i> for the storage queue top.</li>
<li> <i>void setFullDB( const string &amp;vl );</i> — Setting of the full address of the DB table of the library instance.</li>
<li> <i>void list( vector&lt;string&gt; &amp;ls ) const;</i> — Templates list in the library.</li>
<li> <i>bool present( const string &amp;id ) const;</i> — Check for the presence of the template <i>id</i> in the library.</li>
<li> <i>AutoHD&lt;TPrmTempl&gt; at( const string &amp;id ) const;</i> — Connection to the template <i>id</i>.</li>
<li> <i>void add( const char *id, const char *name = "" );</i> — Addition of the template <i>id.name</i> into the library.</li>
<li> <i>void del( const char *id, bool full_del = false );</i> — Deleting of the template <i>id</i> from the library.</li>
<li> <i>TDAQS &amp;owner( ) const;</i> — Object subsystem "DAQ", owner of the library.</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_parameter.27s_template_of_the_.22DAQ.22_subsystem_.28TPrmTempl.29"><span class="mw-headline-number">4.9</span> <span id="TPrmTempl" title="#TPrmTempl">The object of the parameter's template of the "DAQ" subsystem (TPrmTempl)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TFunction">TFunction</a>, <a href="#TConfig">TConfig</a></i>
</td></tr></table>
<p><b>Data:</b><br />
Additional flags to the attribute's object of the function IO (enum TPrmTempl::IOTmplFlgs):
</p>
<ul><li> <i>TPrmTempl::AttrRead</i> (0x10) — Read only attribute;</li>
<li> <i>TPrmTempl::AttrFull</i> (0x20) — Full access attribute;</li>
<li> <i>TPrmTempl::CfgPublConst</i> (0x40) — Public constant;</li>
<li> <i>TPrmTempl::CfgLink</i> (0x80) — External link;</li>
<li> <i>TPrmTempl::LockAttr</i> (0x100) — Blocked attribute.</li>
<li> <i>reserves up to 0x800 and 0x1000 is already used by <a href="#IO">TFunction::IO</a></i></li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TPrmTempl( const char *id, const char *name = "" );</i> —  Initializing constructor of the template.</li>
<li> <i>string id( );</i> — Parameter's template ID.</li>
<li> <i>string name( );</i> — Parameter's template name.</li>
<li> <i>string descr( );</i> — Parameter's template description.</li>
<li> <i>int maxCalcTm( );</i> — The limit on the maximum time calculation of procedure template.</li>
<li> <i>string progLang( );</i> — Parameter's template programming language.</li>
<li> <i>bool progTr( );</i> — Parameter's template program transaltion. </li>
<li> <i>string prog( );</i> — Parameter's template program.</li>
<li> <i>int64_t timeStamp( );</i> — Timestamp for the object changes into DB.</li>
<li> <i>void setName( const string &amp;inm );</i> — Setting the name of the parameter's template.</li>
<li> <i>void setDescr( const string &amp;idsc );</i> — Setting the description of the parameter's template.</li>
<li> <i>void setMaxCalcTm( int vl );</i> — Setting the limit on the maximum time calculation of procedure template.</li>
<li> <i>void setProgLang( const string &amp;ilng );</i> — Setting the programming language of the parameter's template.</li>
<li> <i>void setProgTr( bool vl );</i> — Setting the program of the parameter's template translation.</li>
<li> <i>void setProg( const string &amp;iprg );</i> — Setting the program of the parameter's template.</li>
<li> <i>void setStart( bool val );</i> — Start/stop of the parameter's template.</li>
<li> <i>AutoHD&lt;TFunction&gt; func( );</i> — Connection to the function formed by the template.</li>
<li> <i>TPrmTmplLib &amp;owner( ) const;</i> — Object of the templates' library - the owner of the template.</li></ul>
<h4><span class="mw-headline" id="The_object_of_the_implementation_of_the_template.27s_parameters_of_the_.22DAQ.22_subsystem_.28TPrmTempl::Impl.29"><span class="mw-headline-number">4.9.1</span> <span id="TPrmTempl_Impl" title="#TPrmTempl_Impl">The object of the implementation of the template's parameters of the "DAQ" subsystem (TPrmTempl::Impl)</span></span></h4>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TValFunc">TValFunc</a></i>
</td></tr></table>
<p><b>Data:</b><br />
Structure of template links (class — TPrmTempl::Impl::SLnk):
</p>
<ul><li> <i>int objOff;</i> — offset of an Object part to direct accessing by it;</li>
<li> <i>string addr, addrSpec;</i> — original and special (like to ModBus final address) link address;</li>
<li> <i>AutoHD&lt;TVal&gt; con;</i> — connection to the destination, DAQ attribute;</li>
<li> <i>SLnk( const string &amp;iaddr = "" )</i> — structure constructor.</li></ul>
<p><b>Public methods:</b><br />
</p>
<ul><li> <i>Impl( TCntrNode *iobj, const string &amp;iname = "", bool blked = true );</i> — Constructs for the template implementation with the control node <i>iobj</i> and the name <i>iname</i>.</li>
<li> <i>int  lnkId( const string &amp;nm );</i> — Returns the link <i>nm</i> (function's IO) identifier/number.</li>
<li> <i>bool lnkPresent( int num );</i> — Checks the link number <i>num</i> to presence, returns "true" for accessibility the link.</li>
<li> <i>void lnkList( vector&lt;int&gt; &amp;ls ) const</i> — Gets for list of the linked attributes ID.</li>
<li> <i>virtual void lnkAdd( int num, const SLnk &amp;l );</i> — Adds a link with the number <i>num</i> and the "SLnk" structure <i>l</i>.</li>
<li> <i>string lnkAddr( int num, bool spec = false ) const;</i> — Returns the link address for the number <i>num</i> and the special link address for <i>spec</i>.</li>
<li> <i>void lnkAddrSet( int num, const string &amp;vl, bool spec = false );</i> — Sets the link address to <i>vl</i> for number <i>num</i> and the special link address for <i>spec</i>.</li>
<li> <i>virtual bool lnkInit( int num, bool toRecnt = false );</i> — Inits/connects the link for the number <i>num</i>, which means reading "addr" and forming "con" or "addrSpec". Set <i>toRecnt</i> to force the re-linking. Returns "true" at the need for the initialization/activation repeating.</li>
<li> <i>virtual bool lnkActive( int num );</i> — Checks the link number <i>num</i> initialization/activation state.</li>
<li> <i>virtual TVariant lnkInput( int num );</i> — Returns a value by the link number <i>num</i>.</li>
<li> <i>virtual bool lnkOutput( int num, const TVariant &amp;vl );</i> — Sets the value <i>vl</i> by the link number <i>num</i>. Returns "true" at correct setting.</li>
<li> <i>void addLinksAttrs( TElem *attrsCntr = NULL );</i> — Adds links and DAQ parameter's attributes, at <i>attrsCntr</i> presence.</li>
<li> <i>bool initLnks( bool toRecnt = false );</i> — Inits/connects all the links. Set <i>toRecnt</i> to force the re-linking. Returns "true" at presence at last one not initiated link — needs for the initialization/activation repeating.</li>
<li> <i>virtual void cleanLnks( bool andFunc = false );</i> — Cleans all the links and the function, for <i>andFunc</i>.</li>
<li> <i>void inputLinks( );</i> — Gets for values of all the links.</li>
<li> <i>void outputLinks( );</i> — Sets for values of all the links.</li>
<li> <i>virtual bool cntrCmdProc( XMLNode *opt, const string &amp;pref = "/cfg" );</i> — Calls for control interface of the links with the prefix "pref".</li></ul>
<p><b>Protected attributes:</b><br />
</p>
<ul><li> <i>map&lt;int,SLnk&gt; lnks;</i> — links contatiner;</li>
<li> <i>TCntrNode *obj;</i> — associated control node;</li></ul>
<p><b>Protected methods:</b><br />
</p>
<ul><li> <i>virtual string lnkHelp( );</i> — Returns help for the links address' syntax.</li></ul>
<h2><span class="mw-headline" id="Subsystem_.22Archives-History.22"><span class="mw-headline-number">5</span> <span id="TArchiveS" title="#TArchiveS">Subsystem "Archives-History"</span></span></h2>
<p>Subsystem "Archives" is represented by an object TArchiveS, which contains at the subsystem level the modular objects of the archivers types TTypeArchivator. Each object of the archiver type contains objects of the messages' archivers  TMArchivator and values' archivers TVArchivator. In addition, the subsystem object contains the methods of the messages archive and objects of the values' archives TVArchive. The object of the values' archive TVArchive contains the buffer of values through the inheritance of the buffer object TValBuf. To connect the archive of values with the archivers the object of the value element TVArchEl is provided. This object is contained in the archiver and it is referenced by the archive. Structure of the subsystem "Archives" is presented in Fig. 5.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:221px;"><a class="image" href="http://oscada.org/wiki/File:Oscada_subsys_arch_str.png"><img class="thumbimage" height="251" src="files/Oscada_subsys_arch_str.png" width="219" /></a>  <div class="thumbcaption">Fig. 5. Hierarchical structure of the subsystem "Archives".</div></div></div></div>
<p>Subsystem "Archives" contains the mechanisms for archiving of messages and values. It directly contains the messages' archive together with its buffer. Contains methods for accessing the archives of the values and for the archivers of values and messages. Besides it performs the actively data acquisition from sources of values for the archives of values, as well as archiving the archive of messages by the archivers.
</p><p>Archive of values (TVArchive) contains the buffer (TValBuf) for intermediate values' accumulation before archiving. It is connected with the source of values in the person of OpenSCADA parameters in active or passive mode, as well as with other sources in the passive mode. To archive to the physical storage it is connected with the values' archivers of various types.
</p><p>Object of the buffer TValBuf contains an array of values of the main types of OpenSCADA: string, integer, real and boolean. It is supported the storage of values in the modes of hard, soft grid and in the free access mode. It is also provided the mode of high-resolution time (microseconds). It is used for direct storage of large arrays of values, and for the exchange of large arrays by the frame-accurate method of access. 
</p><p>Root object of the module of subsystem "Archives" (TTypeArchivator) contains information about the specific type of module. Within the individual modules it can implement their own module-wide functions. In general, for modules of this type it contains methods to access the repositories of values and messages.
</p><p>Object of the messages' archiver (TMArchivator) contains the specific implementation of the message storage. In general, for messages' archivers the interface of access to the implementation of an archiving mechanism in modules is provided.
</p><p>Object of the values' archiver (TVArchivator) contains the specific implementation of the repository of values. In general, for the values' archivers the access interface to implementation of the archiving mechanism and the appointment of archives of values for service by archiver are provided.
</p><p>Object of the archive element TVArchEl links the archive objects  with the archivers. It is used to access the archiver from the archive, as well as to archives from the archiver, ie for cross-calls.
</p>
<h3><span class="mw-headline" id="The_object_of_the_subsystem_.22Archives.22_.28TArchiveS.29"><span class="mw-headline-number">5.1</span> <span id="TArchiveS" title="#TArchiveS">The object of the subsystem "Archives" (TArchiveS)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TSubSYS">TSubSYS</a></i>
</td></tr></table>
<p>Modes of forming ID of the automatic created archives:
</p>
<ul><li> <i>BothPrmAttrId</i> — combining the parameter and the attribute ID.</li>
<li> <i>OnlyPrmId</i> — only the parameter ID.</li>
<li> <i>OnlyAttrId</i> — only the attribute ID.</li>
<li> <i>AllCntrPrmAttrId</i> — all controller, parameter and attribute ID.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>int subVer( );</i> — Subsystem's version.</li>
<li> <i>int messPeriod( );</i> — Period of archiving of messages from the buffer (seconds).</li>
<li> <i>int valPeriod( );</i> — Acquisition of values period for the active archivers (milliseconds).</li>
<li> <i>int valPrior( );</i> — Priority of the tasks of the values acquisition for the active archivers.</li>
<li> <i>bool valForceCurTm( );</i> — Points to force of current time as the time-stamp of the getting values.</li>
<li> <i>AutoIdMode autoIdMode( );</i> — Gets the mode of forming ID of the automatic created archives.</li>
<li> <i>void setMessPeriod( int ivl );</i> — Setting the period of the archiving of messages from the buffer (seconds).</li>
<li> <i>void setValPeriod( int ivl );</i> — Setting the values' acquisition period for active archivers (milliseconds).</li>
<li> <i>void setValPrior( int ivl );</i> — Setting the priority of the values' acquisition task for the active archivers.</li>
<li> <i>void setValForceCurTm( bool vl );</i> — Force of current time as the time-stamp of the getting values.</li>
<li> <i>void setAutoIdMode( AutoIdMode vl );</i> — Sets the mode <i>vl</i> of forming ID of the automatic created archives.</li>
<li> <i>void setToUpdate( );</i> — Planing update flag set.</li>
<li> <i>void subStart( );</i> — Start of the subsystem.</li>
<li> <i>void subStop( );</i> — Stop of the system.</li>
<li> <i>void valList( vector&lt;string&gt; &amp;list ) const;</i> — The list of the values'archives in the subsystem.</li>
<li> <i>bool valPresent( const string &amp;id ) const;</i> — Check for the availability of the values' archive <i>id</i>.</li>
<li> <i>string valAdd( const string &amp;id, const string &amp;idb = "*.*" );</i> — Addition of the new values' archive <i>id</i>. Returns the end created identifier.</li>
<li> <i>void valDel( const string &amp;id, bool db = false );</i> — Deleting of the values' archive <i>id</i>.</li>
<li> <i>AutoHD&lt;TVArchive&gt; valAt( const string &amp;id ) const;</i> — Connection/addressing to the values' archive <i>id</i>.</li>
<li> <i>void setActMess( TMArchivator *a, bool val );</i> — Setting of the messages archivator <i>a</i> into the active status <i>val</i>. Active archivator will be provided by the subsystem with the flow of messages.</li>
<li> <i>void setActVal( TVArchive *a, bool val );</i> — Setting of the value archive <i>a</i> into the active status <i>val</i>. Active archive will be provided by the subsystem with the periodic flow of values (is determined by the periodicity of the archive).</li>
<li> <i>AutoHD&lt;TTypeArchivator&gt; at( const string &amp;name );</i> — Connection/addressing to the archiver's type (module) <i>name</i>.</li>
<li> <i>void messPut( time_t tm, int utm, const string &amp;categ, int8_t level, const string &amp;mess, const string &amp;arch = "" ); void messPut( const TMess::SRec &amp;rec, const string &amp;arch = "" );</i> — Location of the message <i>mess</i> with the <i>level</i> of the category <i>categ</i> and time <i>tm+utm</i>, or the complete TMess::SRec structure <i>rec</i>, into the buffer, and then into the messages' archive or direct to the pointed archivators <i>arch</i> (separated by symbol ';').</li>
<li> <i>void messPut( const vector&lt;TMess::SRec&gt; &amp;recs, const string &amp;arch = "" );</i> — Location of the group of values <i>recs</i> into the buffer, and then into the messages' archive or direct to the pointed archivators <i>arch</i> (separated by symbol ';').</li>
<li> <i>time_t messGet( time_t bTm, time_t eTm, vector&lt;TMess::SRec&gt; &amp;recs, const string &amp;category = "", int8_t level = TMess::Debug, const string &amp;arch = "", time_t upTo = 0 );</i> — Values' request <i>reqs</i> for the specified period of time <i>bTm, eTm</i> for the specified category (by the template) <i>category</i> and level <i>level</i> from the archivators <i>arch</i> (separated by symbol ';'). Return time of the request stop, useful for continue from the point.</li>
<li> <i>time_t messBeg( const string &amp;arch = "" );</i> — Beginning of the messages' archive as a whole or for the specified archiver <i>arch</i>.</li>
<li> <i>time_t messEnd( const string &amp;arch = "" );</i> — End of the messages' archive as a whole or for the specified archiver <i>arch</i>.</li>
<li> <i>time_t rdTm( );</i> — Time of the last redundancy operation, maximum for message archivers in the active redundancy.</li>
<li> <i>double rdRestDtOverTm( );</i> — Overtime of the reserve history reload at start in days.</li>
<li> <i>void setRdRestDtOverTm( double vl );</i> — Setting of overtime of the reserve history reload at start in days.</li>
<li> <i>void rdActArchMList( vector&lt;string&gt; &amp;ls, bool isRun = false );</i> — The list of active message archivators working in the redundancy scheme. When we indicate <i>isRun</i> there will be in the list only running message archvators in this station.</li>
<li> <i>string rdStRequest( const string &amp;arch, XMLNode &amp;req, const string &amp;prevSt = "", bool toRun = true );</i> — Request <i>req</i> to the redundant station on behalf of the message archivator <i>arch</i>. The station for the request is selected after specified in <i>prevSt</i> for the running remotely message archivators when indicating <i>toRun</i>.</li>
<li> <i>TElem &amp;messE( );</i> — DB structure of the messages' archivers.</li>
<li> <i>TElem &amp;valE( );</i> — DB structure of the values' archivers.</li>
<li> <i>TElem &amp;aValE( );</i> — DB structure of the values' archives.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>bool SubStarting;</i> — The subsystem starting flag.</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_values.27_archive_.28TVArchive.29"><span class="mw-headline-number">5.2</span> <span id="TVArchive" title="#TVArchive">The object of the values' archive (TVArchive)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a>, <a href="#TValBuf">TValBuf</a>, <a href="#TConfig">TConfig</a></i>
</td></tr></table>
<p><b>Data:</b><br />
The data acquisition mode/source (struct — TVArchive::SrcMode):
</p>
<ul><li> <i>Passive</i> — passive mode of the data acquisition, the source puts the data into the archive itself;</li>
<li> <i>PassiveAttr</i> — passive mode of the data acquisition from the parameter's attribute, the parameter's attribute puts the data into the archive itself;</li>
<li> <i>ActiveAttr</i> — active mode of the data acquisition from the parameter's attribute, the parameter's attribute is periodically polled by the subsystem "Archives";</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TVArchive( const string &amp;id, const string &amp;db, TElem *cf_el );</i> — Initializing constructor of the archive, where <i>id</i> — archive ID, <i>db</i> — DB for storage and <i>cf_el</i> — DB structure of the values' archives.</li>
<li> <i>string id( );</i> — Archive's ID.</li>
<li> <i>string name( );</i> — Archive's name.</li>
<li> <i>string dscr( );</i> — Archive's description.</li>
<li> <i>SrcMode srcMode( );</i> — Linkage mode with the data source.</li>
<li> <i>AutoHD&lt;TVal&gt; srcPAttr( bool force = false, const string &amp;ipath = "" );</i> — Connect to associated attribute of parameter of data source.</li>
<li> <i>string srcData( );</i> — Parameters of the data source, in the case of access mode to the parameter this is the address of the parameter.</li>
<li> <i>bool toStart( );</i> — Sign: "Start the archive when starting the system".</li>
<li> <i>bool startStat( );</i> — Status: "Archive started".</li>
<li> <i>string DB( bool qTop = false ) const;</i> — Storage address of the values' archive, <i>qTop</i> for the storage queue top.</li>
<li> <i>string tbl( );</i> — DB table of the values' archive.</li>
<li> <i>string fullDB( bool qTop = false );</i> — Full name of the storage table of the values' archive, <i>qTop</i> for the storage queue top.</li>
<li> <i>int64_t end( const string &amp;arch = ARCH_BUF );</i> — End of the archive time at whole (arch="") or the specified archiver, buffer (arch="&lt;bufer&gt;").</li>
<li> <i>int64_t begin( const string &amp;arch = ARCH_BUF );</i> — Start of the archive time at whole (arch="") or the specified archiver, buffer (arch="&lt;bufer&gt;").</li>
<li> <i>int64_t period( const string &amp;arch = ARCH_BUF );</i> — Periodicity of the archive buffer or the specified archiver (microseconds).</li>
<li> <i>TFld::Type valType( bool full = false );</i> — Type of the archived value. <i>full</i> — request full type, else only generic.</li>
<li> <i>bool hardGrid( );</i> — Using of the hard grid in the archive buffer.</li>
<li> <i>bool highResTm( );</i> — Using of the high-resolution time in the archive buffer (microseconds).</li>
<li> <i>bool fillLast( );</i> — Fill pass points to a last value. Mostly the pass values fill by EVAL but sometime the source's data periodicity greater to the archive's one and it is normal.</li>
<li> <i>int size( );</i> — Archive buffer size (units).</li>
<li> <i>void setName( const string &amp;inm );</i> — Setting the name of the archive.</li>
<li> <i>void setDscr( const string &amp;idscr );</i> — Setting the description of the archive.</li>
<li> <i>void setSrcMode( SrcMode vl = SaveCur, const string &amp;isrc = "&lt;*&gt;", bool noex = false );</i> — Setting the linkage mode with the data source.</li>
<li> <i>void setToStart( bool vl );</i> — Setting the sign: "Start the archive when starting the system".</li>
<li> <i>void setDB( const string &amp;vl, bool qTop = false );</i> — Setting the storage address of the values' archive, <i>qTop</i> for the storage queue top.</li>
<li> <i>void setValType( TFld::Type vl );</i> — Setting the type of the archived value.</li>
<li> <i>void setHardGrid( bool vl );</i> — Setting the using of the hard grid in the archive buffer.</li>
<li> <i>void setHighResTm( bool vl );</i> — Setting of using of the high-resolution time in the archive buffer (microseconds).</li>
<li> <i>void setFillLast( bool vl );</i> — Set to fill pass points to a last value.</li>
<li> <i>void setSize( int vl );</i> — Setting of the archive buffer size (units).</li>
<li> <i>void setPeriod( int64_t vl );</i> — Setting the periodicity of the archive buffer.</li>
<li> <i>void start( );</i> — Start of the archive.</li>
<li> <i>void stop( bool full_del = false );</i> — Stop of the archive with it's completely deleting <i>full_del</i>.</li>
<li> <i>TVariant getVal( int64_t *tm = NULL, bool up_ord = false, const string &amp;arch = "", bool onlyLocal = false );</i> — Request of the single value for the time <i>tm</i> and with the sign of the moving to the top <i>up_ord</i> from the specified archiver <i>arch</i>, buffer (arch = "&lt;bufer&gt;") or from all archivers in the course of falling quality (arch =""). To process the request only by the local station <i>onlyLocal</i> is set.</li>
<li> <i>void getVals( TValBuf &amp;buf, int64_t beg = 0, int64_t end = 0, const string &amp;arch = "", int limit = 100000, bool onlyLocal = false );</i> — Request of the values' frame <i>buf</i> for the time from <i>beg</i> to <i>end</i> from the specified archiver <i>arch</i>, buffer (arch = "&lt;bufer&gt;") or from the all archivers in the course of falling quality (arch =""), limiting the size of the request <i>limit</i> of the record. To request only the local archives, without compensation gaps in the archives from the backup stations, set <i>onlyLocal</i>.</li>
<li> <i>void setVals( TValBuf &amp;buf, int64_t beg, int64_t end, const string &amp;arch );</i> — Set of the values' frame <i>buf</i> for the time from <i>beg</i> to <i>end</i> to the specified archiver <i>arch</i>, buffer (arch = "&lt;bufer"&gt;) or to all archivers (arch ="").</li>
<li> <i>void getActiveData( const int64_t &amp;tm = 0 );</i> — To interrogate the data source with forcing time-stamp to <i>tm</i> (not zero). Is used for periodic data acquisition by the active archives in the subsystem.</li>
<li> <i>void archivatorList( vector&lt;string&gt; &amp;ls );</i> — List of archivers which serves the archive.</li>
<li> <i>bool archivatorPresent( const string &amp;arch );</i> — Check the archiver for it's servicing of the given archive.</li>
<li> <i>void archivatorAttach( const string &amp;arch );</i> — Connecting the archive to be served by the specified archiver.</li>
<li> <i>void archivatorDetach( const string &amp;arch, bool full = false );</i> — Disabling this archive from the servicing of the specified archiver.</li>
<li> <i>void archivatorSort( );</i> — Sort of the serving archivers in the order of decreasing quality.</li>
<li> <i>string makeTrendImg( int64_t beg, int64_t end, const string &amp;arch, int hsz = 650, int vsz = 230 );</i> — Building of the (pdf) image of the trend for the specified amount of time <i>beg, end</i> and for this archiver <i>arch</i>.</li>
<li> <i>TArchiveS &amp;owner( ) const;</i> — Subsystem "Archives" - the owner of the archive of values.</li></ul>
<h3><span class="mw-headline" id="Object_of_the_values.27_buffer_.28TValBuf.29"><span class="mw-headline-number">5.3</span> <span id="TValBuf" title="#TValBuf">Object of the values' buffer (TValBuf)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherited:</b></td>
<td><i><a href="#TVArchive">TVArchive</a></i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TValBuf( );</i> — Buffer initializer with default settings.</li>
<li> <i>TValBuf( TFld::Type vtp, int isz, int64_t ipr, bool ihgrd = false, bool ihres = false );</i> — Buffer initializer with the specified parameters.</li>
<li> <i>TValBuf( const TValBuf &amp;src );</i> — Copying constructor.</li>
<li> <i>TValBuf &amp;operator=( const TValBuf &amp;src );</i> — Object copying.</li>
<li> <i>void clear( );</i> — Cleaning the buffer.</li>
<li> <i>TFld::Type valType( bool full = false );</i> — Type of the value stored in the buffer. <i>full</i> — request full type, else only generic.</li>
<li> <i>bool hardGrid( );</i> — Hard grid working mode.</li>
<li> <i>bool highResTm( );</i> — High resolution (microseconds) working mode of the buffer.</li>
<li> <i>bool fillLast( );</i> — Fill pass points to a last value. Mostly the pass values fill by EVAL but sometime the source's data periodicity greater to the archive's one and it is normal.</li>
<li> <i>int size( );</i> — Maximum buffer size (units).</li>
<li> <i>int realSize( );</i> — Real buffer size (units).</li>
<li> <i>int64_t period( );</i> — Frequency of values in the buffer (microseconds). If the frequency is zero the buffer operates in the mode of free access.</li>
<li> <i>int64_t begin( );</i> — Start time of the buffer (microseconds).</li>
<li> <i>int64_t end( );</i> — End time of the buffer (microseconds).</li>
<li> <i>bool vOK( int64_t ibeg, int64_t iend );</i> — Checking for values in the buffer for the specified period of time from <i>ibeg</i> to <i>iend</i>.</li>
<li> <i>void setValType( TFld::Type vl );</i> — Setting of the value type stored by the buffer.</li>
<li> <i>void setHardGrid( bool vl );</i> — Setting the hard grid mode.</li>
<li> <i>void setHighResTm( bool vl );</i> — High resolution (microseconds) working mode setting.</li>
<li> <i>void setFillLast( bool vl );</i> — Set to fill pass points to a last value.</li>
<li> <i>void setSize( int vl );</i> — Buffer size (units) setting.</li>
<li> <i>void setPeriod( int64_t vl );</i> — Frequency of values in the buffer (microseconds) setting.</li>
<li> <i>virtual void getVals( TValBuf &amp;buf, int64_t beg = 0, int64_t end = 0 );</i> — Request of the values' frame  <i>buf</i> for the time from <i>beg</i> to <i>end</i>.</li>
<li> <i>TVariant get( int64_t *tm = NULL, bool up_ord = false );</i> — Request value for the time <i>tm</i> and with the sign of moving to the top <i>up_ord</i>.</li>
<li> <i>virtual string getS( int64_t *tm = NULL, bool up_ord = false );</i> — Request of the string type value for the time <i>tm</i> and with the sign of moving to the top <i>up_ord</i>.</li>
<li> <i>virtual double getR( int64_t *tm = NULL, bool up_ord = false );</i> — Request of the real type value for the time <i>tm</i> and with the sign of moving to the top <i>up_ord</i>.</li>
<li> <i>virtual int64_t getI( int64_t *tm = NULL, bool up_ord = false );</i> — Request of the integer type value for the time <i>tm</i> and with the sign of moving to the top <i>up_ord</i>.</li>
<li> <i>virtual char getB( int64_t *tm = NULL, bool up_ord = false );</i> — Request of the boolean type value for the time <i>tm</i> and with the sign of moving to the top <i>up_ord</i>.</li>
<li> <i>virtual void setVals( TValBuf &amp;buf, int64_t beg = 0, int64_t end = 0 );</i> — Setting the values' frame from <i>buf</i> fro the time from <i>beg</i> to <i>end</i>.</li>
<li> <i>void set( const TVariant &amp;value, int64_t tm = 0 );</i> — Setting value with the time <i>tm</i>.</li>
<li> <i>virtual void setS( const string &amp;value, int64_t tm = 0 );</i> — Setting the string type value with the time <i>tm</i>.</li>
<li> <i>virtual void setR( double value, int64_t tm = 0 );</i> — Setting the real type value with the time <i>tm</i>.</li>
<li> <i>virtual void setI( int64_t value, int64_t tm = 0 );</i> — Setting the integer type value with the time <i>tm</i>.</li>
<li> <i>virtual void setB( char value, int64_t tm = 0 );</i> — Setting the boolean type value with the time <i>tm</i>.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>void makeBuf( TFld::Type v_tp, int isz, int64_t ipr, bool hd_grd, bool hg_res );</i> — Rebuilding the buffer for the specified parameters.</li></ul>
<h3><span class="mw-headline" id="The_modular_object_of_the_archiver.27s_type_.28TTypeArchivator.29"><span class="mw-headline-number">5.4</span> <span id="TTypeArchivator" title="#TTypeArchivator">The modular object of the archiver's type (TTypeArchivator)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TModule">TModule</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By the root objects of the modules of subsystem "Archives".
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>void messList( vector&lt;string&gt; &amp;list ) const;</i> — The list of the messages' archivers.</li>
<li> <i>bool messPresent( const string &amp;id ) const;</i> — Check for the presence of the specified messages' archiver.</li>
<li> <i>string messAdd( const string &amp;id, const string &amp;idb = "*.*" );</i> — Adding of the messages' archiver. Returns the end created identifier.</li>
<li> <i>void messDel( const string &amp;id, bool full = false );</i> — Deleting of the messages' archiver.</li>
<li> <i>AutoHD&lt;TMArchivator&gt; messAt( const string &amp;id ) const;</i> — Connection to the messages' archiver.</li>
<li> <i>void valList( vector&lt;string&gt; &amp;list ) const;</i> — The list of the values' archivers.</li>
<li> <i>bool valPresent( const string &amp;id ) const;</i> — Check for the presence of the specified values' archiver.</li>
<li> <i>string valAdd( const string &amp;id, const string &amp;idb = "*.*" );</i> — Adding of the values' archiver. Returns the end created identifier.</li>
<li> <i>void valDel( const string &amp;id, bool full = false );</i> — Deleting of the values' archiver.</li>
<li> <i>AutoHD&lt;TVArchivator&gt; valAt( const string &amp;id ) const;</i> — Connection to the values' archiver.</li>
<li> <i>TArchiveS &amp;owner( ) const;</i> — Subsystem "Archives" - the owner of the archiver's type.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>virtual TMArchivator *AMess( const string &amp;iid, const string &amp;idb );</i> — The modular method of creating of the messages' archiver.</li>
<li> <i>virtual TVArchivator *AVal( const string &amp;iid, const string &amp;idb );</i> — The modular method of creating of the values' archiver.</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_messages.27_archiver_.28TMArchivator.29"><span class="mw-headline-number">5.5</span> <span id="TMArchivator" title="#TMArchivator">The object of the messages' archiver (TMArchivator)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a>, <a href="#TConfig">TConfig</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By the objects of the archivers of messages of modules of the subsystem "Archives".
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TMArchivator( const string &amp;id, const string &amp;db, TElem *cf_el );</i> — Initializing constructor of the messages' archiver with the ID <i>id</i>, for the storage in the database <i>db</i> with the structure <i>&lt;cf_el&gt;</i>.</li>
<li> <i>string id( );</i> — Archiver's ID.</li>
<li> <i>string workId( );</i> — Working identifier, it includes the name of the module.</li>
<li> <i>string name( );</i> — Archiver's name.</li>
<li> <i>string dscr( );</i> — Archiver's description.</li>
<li> <i>bool toStart( );</i> — The sign "To start the archiver".</li>
<li> <i>bool startStat( );</i> — Archivers' status "Run".</li>
<li> <i>string &amp;addr( ) const;</i> — Address of the archiver's storage.</li>
<li> <i>int &amp;level( );</i> — The level of messages, serviced by the archiver.</li>
<li> <i>void categ( vector&lt;string&gt; &amp;list );</i> — Categories (templates) of messages, serviced by the archiver.</li>
<li> <i>string DB( bool qTop = false ) const;</i> — Storage address of the archiver, <i>qTop</i> for the storage queue top.</li>
<li> <i>string tbl( );</i> — Table address of the archiver's DB.</li>
<li> <i>string fullDB( bool qTop = false );</i> — The full table address of the archiver's storage, <i>qTop</i> for the storage queue top.</li>
<li> <i>void setName( const string &amp;vl );</i> — Setting the archiver's name.</li>
<li> <i>void setDscr( const string &amp;vl );</i> — Setting the archiver's description.</li>
<li> <i>void setToStart( bool vl );</i> — Setting the sign "To start the archiver".</li>
<li> <i>void setAddr( const string &amp;vl );</i> — Setting the address of the archiver's storage.</li>
<li> <i>void setLevel( int lev );</i> — Setting the level of messages, serviced by the archiver.</li>
<li> <i>void setDB( const string &amp;vl, bool qTop = false );</i> — Setting the storage address of the archiver, <i>qTop</i> for the storage queue top.</li>
<li> <i>time_t redntTm( );</i> — Time of the last redundancy operation.</li>
<li> <i>bool redntUse( );</i> — Getting the data from the backup station mode.</li>
<li> <i>void setRedntUse( bool vl );</i> — Changing of the getting the data from the backup station mode.</li>
<li> <i>Redundant redntMode( );</i> — Redundancy mode ("&lt;high&gt;", "&lt;low&gt;", "&lt;optimal&gt;", {ForceStation}), enabling.</li>
<li> <i>void setRedntMode( Redundant vl );</i> — Setting of the redundancy mode, enabling.</li>
<li> <i>string redntRun( );</i> — Configuration of the preferred execution.</li>
<li> <i>void setRedntRun( const string &amp;vl );</i> — Setting the configuration of the preferred execution.</li>
<li> <i>virtual void redntDataUpdate( );</i> — An operation of the data receiving from the backup station execution. It is called automatically by the service procedure of the redundancy scheme of the subsystem.</li>
<li> <i>virtual void start( );</i> — Start of the archiver.</li>
<li> <i>virtual void stop( );</i> — Stop of the archiver.</li>
<li> <i>virtual time_t begin( );</i> — The beginning of the archive of the specified archiver.</li>
<li> <i>virtual time_t end( );</i> — The end of the archive of the specified archiver.</li>
<li> <i>virtual bool put( vector&lt;TMess::SRec&gt; &amp;mess, bool force = false );</i> — Place the group of messages in the messages' archive of the specified archivator. Return "true" on successful operation. <i>force</i> for direct writing to the archivator omit the redundancy.</li>
<li> <i>virtual time_t get( time_t bTm, time_t eTm, vector&lt;TMess::SRec&gt; &amp;mess, const string &amp;category = "", char level = 0, time_t upTo = 0 );</i> — Get the messages from the archive of the specified archiver for the specified filter parameters. Return time of the request stop, useful for continue from the point.</li>
<li> <i>TTypeArchivator&amp;owner( ) const;</i> — Archiver's type – the owner of the messages' archiver.</li></ul>
<p><b>Protected attributes:</b>
</p>
<ul><li> <i>bool runSt;</i> — The sign "Running".</li>
<li> <i>int messHead;</i> — The pointer to last read message of the messages buffer.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>bool chkMessOK( const string &amp;icateg, int8_t ilvl );</i> — Check the message to the filter conditions.</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_values.27_archiver_.28TVArchivator.29"><span class="mw-headline-number">5.6</span> <span id="TVArchivator" title="#TVArchivator">The object of the values' archiver (TVArchivator)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a>, <a href="#TConfig">TConfig</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By the objects of the archivers of values of modules of the subsystem "Archives".
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TVArchivator( const string &amp;id, const string &amp;db, TElem *cf_el );</i> — Initializing constructor of the values' archiver with the ID <i>id</i>, for the storage in the database <i>db</i> with the structure <i>cf_el</i>.</li>
<li> <i>string id( );</i> — Archiver's ID.</li>
<li> <i>string workId( );</i> — Working identifier, it includes the name of the module.</li>
<li> <i>string name( );</i> — Archiver's name.</li>
<li> <i>string dscr( );</i> — Archiver's description.</li>
<li> <i>string addr( ) const;</i> — Address of the archiver's storage.</li>
<li> <i>double valPeriod( );</i> — Frequency of values of the archiver (microseconds).</li>
<li> <i>int archPeriod( );</i> — Frequency of the values' archiving by the archiver. Time after which the archiver makes archiving of the frame of values from the archive's buffer.</li>
<li> <i>int selPrior( );</i> — Selection priority for mode "All" archivers.</li>
<li> <i>bool toStart( );</i> — The sign "To start the archiver".</li>
<li> <i>bool startStat( );</i> — Archivers' status "Run".</li>
<li> <i>string DB( bool qTop = false ) const;</i> — Storage address of the archiver, <i>qTop</i> for the storage queue top.</li>
<li> <i>string tbl( );</i> — Table address of the archiver's DB.</li>
<li> <i>string fullDB( bool qTop = false );</i> — The full table address of the archiver's storage, <i>qTop</i> for the storage queue top.</li>
<li> <i>void setName( const string &amp;inm );</i> — Setting the archiver's name.</li>
<li> <i>void setDscr( const string &amp;idscr );</i> — Setting the archiver's description.</li>
<li> <i>void setAddr( const string &amp;vl );</i> — Setting the address of the archiver's storage.</li>
<li> <i>void setValPeriod( double iper );</i> — Setting the frequency of values of the archiver (microseconds).</li>
<li> <i>void setArchPeriod( int iper );</i> — Setting the frequency of the values' archiving by the archiver. Time after which the archiver makes archiving of the frame of values from the archive's buffer.</li>
<li> <i>void setSelPrior( int vl );</i> — Set selection priority for mode "All" archivers.</li>
<li> <i>void setToStart( bool vl );</i> — Setting the sign "To start the archiver".</li>
<li> <i>void setDB( const string &amp;vl, bool qTop = false );</i> — Setting the storage address of the archiver, <i>qTop</i> for the storage queue top.</li>
<li> <i>virtual void start( );</i> — Start of the archiver.</li>
<li> <i>virtual void stop( bool full_del = false );</i> — Stop of the archiver with the possibility of it's full deleting <i>full_del</i>.</li>
<li> <i>void archiveList( vector&lt;string&gt; &amp;ls );</i> — The archive's list, serviced by the archiver.</li>
<li> <i>bool archivePresent( const string &amp;iid );</i> — Check for the servicing of the specified archive by the specified archiver.</li>
<li> <i>TTypeArchivator &amp;owner( ) const;</i> — Archiver's type – the owner of the values' archiver.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>TVArchEl *archivePlace( TVArchive &amp;item );</i> — Add the archive <i>item</i> to the processing by the archiver.</li>
<li> <i>void archiveRemove( const string &amp;id, bool full = false );</i> — Remove the archive <i>id</i> from the processing by the archiver, with the possibility of its full deleting  <i>full</i>.</li>
<li> <i>virtual TVArchEl *getArchEl( TVArchive &amp;arch );</i> — Getting the object of the archive's element for the specified archive.</li>
<li> <i>virtual void pushAccumVals( );</i> — Push the accumulated by the archivation task values, for the accumulated archivators.</li></ul>
<p><b>Protected attributes:</b>
</p>
<ul><li> <i>ResRW archRes;</i> — Resource locker of the archiving process.</li>
<li> <i>bool runSt;</i> — The sign "Archiver is run".</li>
<li> <i>bool endrunReq;</i> — The sign "End run request to the archiver task".</li>
<li> <i>vector&lt;TVArchEl *&gt; archEl;</i> — Array of elements of archives in the archiver.</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_archive.27s_element_in_the_archiver_.28TVArchEl.29"><span class="mw-headline-number">5.7</span> <span id="TVArchEl" title="#TVArchEl">The object of the archive's element in the archiver (TVArchEl)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherited:</b></td>
<td>By the objects of the archivers of values of modules of the subsystem "Archives".
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TVArchEl( TVArchive &amp;iarchive, TVArchivator &amp;iarchivator );</i> — Initializing constructor fro the connection the archive <i>iarchive</i> with the archiver <i>iarchivator</i>.</li>
<li> <i>virtual void fullErase( );</i> — Full deleting of the element.</li>
<li> <i>virtual int64_t end( );</i> — End time of data (microseconds).</li>
<li> <i>virtual int64_t begin( );</i> — Start time of data (microseconds).</li>
<li> <i>int64_t lastGet( );</i> — Time of last transfer of the data from the buffer to the storage.</li>
<li> <i>TVariant getVal( int64_t *tm, bool up_ord, bool onlyLocal = false );</i> — Request of the value for the time <i>tm</i> and with the sign of moving to the top <i>up_ord</i>, with the specifying of the request of only local archive in <i>onlyLocal</i>.</li>
<li> <i>void getVals( TValBuf &amp;buf, int64_t beg = 0, int64_t end = 0, bool onlyLocal = false );</i> — Request of the values' frame <i>buf</i> for the time from <i>beg</i> to <i>end</i>, with the specifying of the request of only local archive in <i>onlyLocal</i>.</li>
<li> <i>void setVals( TValBuf &amp;buf, int64_t beg = 0, int64_t end = 0, bool toAccum = false );</i> — Setting the values' frame from the <i>buf</i> for the time from <i>beg</i> to <i>end</i>, through the accumulation <i>toAccum</i>.</li>
<li> <i>TVArchive &amp;archive( );</i> — Elements' archive.</li>
<li> <i>TVArchivator &amp;archivator( );</i> — Elements' archiver.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>int64_t prev_tm;</i> — The previous value time. It is used for averaging.</li>
<li> <i>string prev_val;</i> — The previous value time. It is used for averaging.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>virtual TVariant getValProc( int64_t *tm, bool up_ord );</i> — The processing function of the single value from the archive request.</li>
<li> <i>virtual void getValsProc( TValBuf &amp;buf, int64_t beg, int64_t end );</i> — Function of the processing the request of the module to get the data.</li>
<li> <i>virtual void setValsProc( TValBuf &amp;buf, int64_t beg, int64_t end, bool toAccum );</i> — Function of the processing the request of the module to set the data, through the accumulation <i>toAccum</i>.</li></ul>
<h2><span class="mw-headline" id="Subsystem_.22Transports.22"><span class="mw-headline-number">6</span> <span id="TTransportS" title="#TTransportS">Subsystem "Transports"</span></span></h2>
<p>"Transports" subsystem is represented by the TTransportS object, which contains modular objects of the transports' types TTypeTransport on the subsystem-level. Each type of transport contains objects TTransportIn of the input and TTransportOut of the output transports. The overall structure of the subsystem is shown in Fig. 6.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:293px;"><a class="image" href="http://oscada.org/wiki/File:Oscada_subsys_tr_str.png"><img class="thumbimage" height="296" src="files/Oscada_subsys_tr_str.png" width="291" /></a>  <div class="thumbcaption">Fig. 6. Hierarchical structure of the subsystem "Transports".</div></div></div></div>
<p>The root object of the "Transports" subsystem's module provides information about the specific type of module and about the external OpenSCADA hosts/stations. As part of the single module it can be implemented the own general-module functionality. In general, for all modules, the access methods for both: inbound and outbound transports of the specific module are contained.
</p><p>The object of the input transport TTransportIn provides an interface to the implementation of the modular method of input transport.
</p><p>The object of the output transport TTransportOut provides an interface to the implementation of the modular method of output transport.
</p>
<h3><span class="mw-headline" id="The_object_of_the_.22Transports.22_subsystem_.28TTransportS.29"><span class="mw-headline-number">6.1</span> <span id="TTransportS" title="#TTransportS">The object of the "Transports" subsystem (TTransportS)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TSubSYS">TSubSYS</a></i>
</td></tr></table>
<p><b>Data:</b><br />
External hosts mode (enum — ExtHost::Mode):
</p>
<ul><li> <i>User</i> (0) — User.</li>
<li> <i>System</i> (1) — System.</li>
<li> <i>UserSystem</i> (2) — User and System.</li></ul>
<p>The structure of the external OpenSCADA hosts/stations (class TTransportS::ExtHost):
</p>
<ul><li> <i>ExtHost( const string &amp;iUserOpen, const string &amp;iid, const string &amp;iname = "", const string &amp;itransp = "", const string &amp;iaddr = "", const string &amp;iuser = "", const string &amp;ipass = "", uint8_t iUpRiseLev = 0 );</i> — Constructor of the structure initialization.</li>
<li> <i>string userOpen;</i> — User who created the record about the external host/station.</li>
<li> <i>string id;</i> — Id of the external host/station.</li>
<li> <i>string name;</i> — Name of an external host/station.</li>
<li> <i>string transp;</i> — Transport which is used to access an external host/station.</li>
<li> <i>string addr;</i> — Address for the transport, which is used to access an external host/station.</li>
<li> <i>string user;</i> — Users of the external host/station.</li>
<li> <i>string pass;</i> — Password of the external host/station user.</li>
<li> <i>uint8_t upRiseLev;</i> — External hosts uprising level/depth of this host/station.</li>
<li> <i>int8_t mode;</i> — Host mode.</li>
<li> <i>time_t mdf;</i> — Modification time.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>int subVer( );</i> — Subsystem's version.</li>
<li> <i>void inTrList( vector&lt;string&gt; &amp;ls );</i> — Full list of input transports.</li>
<li> <i>void outTrList( vector&lt;string&gt; &amp;ls );</i> — Full list of output transports.</li>
<li> <i>string extHostsDB( );</i> — Database for the storing the list of external hosts.</li>
<li> <i>void extHostList( const string &amp;user, vector&lt;ExtHost&gt; &amp;list, bool andSYS = false, int upRiseLev = -1 );</i> — The <i>list</i> of external hosts for <i>user</i>, include system <i>andSYS</i> and the uprising level <i>upRiseLev</i> (-1 - starting from the host's entry level).</li>
<li> <i>ExtHost extHostGet( const string &amp;user, const string &amp;id, bool andSYS = false );</i> — Getting the information object from the external host <i>id</i> on behalf of the user <i>user</i>, include system <i>andSYS</i> ( "*" — for the system hosts).</li>
<li> <i>ExtHost extHostSeek( const string &amp;id, int lev );</i> — Direct hosts scanning at the station <i>id</i> and the level <i>lev</i>. The scanning starts at <i>lev</i> in 0 and stops at return empty host ID.</li>
<li> <i>AutoHD&lt;TTransportOut&gt; extHost( TTransportS::ExtHost host, const string &amp;pref = "" );</i> — Creation - request of the output transport to service the external host <i>host</i> with the prefix of the identification of the system node <i>pref</i>.</li>
<li> <i>void extHostSet( const ExtHost &amp;host, bool andSYS = false );</i> — Setting of the external host/station <i>host</i>, include system <i>andSYS</i>.</li>
<li> <i>void extHostDel( const string &amp;user, const string &amp;id, bool andSYS = false );</i> — Deleting of the external host/station <i>id</i> on behalf of the user <i>user</i>, include system <i>andSYS</i> ( "*" — for the system hosts).</li>
<li> <i>int cntrIfCmd( XMLNode &amp;node, const string &amp;senderPref, const string &amp;user = "" );</i> — Transfer of the control area request of the OpenSCADA <i>node</i> to the remote station.  </li>
<li> <i>void subStart( );</i> — Start of the subsystem.</li>
<li> <i>void subStop( );</i> — Stop of the subsystem.</li>
<li> <i>TElem &amp;inEl( );</i> — DB structure of the input transports</li>
<li> <i>TElem &amp;outEl( );</i> — DB structure of the output transports</li>
<li> <i>AutoHD&lt;TTypeTransport&gt; at( const string &amp;id ) const;</i> — Addressing/connection to the type of transport <i>id</i>.</li></ul>
<h3><span class="mw-headline" id="The_modular_object_of_the_transports.27_type_.28TTypeTransport.29"><span class="mw-headline-number">6.2</span> <span id="TTypeTransport" title="#TTypeTransport">The modular object of the transports' type (TTypeTransport)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TModule">TModule</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By the root object of the subsystem's "Transports" modules..
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>void inList( vector&lt;string&gt; &amp;list ) const;</i> — The list of the input transports.</li>
<li> <i>bool inPresent( const string &amp;id ) const;</i> — Check for an input transport presence.</li>
<li> <i>string inAdd( const string &amp;id, const string &amp;db = "*.*" );</i> — Addition of the input transport. Returns the end created identifier.</li>
<li> <i>void inDel( const string &amp;id, bool complete = false );</i> — Deleting of the input transport. It is possible to completely delete with the database included, by setting the <i>complete</i> sign.</li>
<li> <i>AutoHD&lt;TTransportIn&gt; inAt( const string &amp;id ) const;</i> — Connection to the input transport.</li>
<li> <i>void outList( vector&lt;string&gt; &amp;list ) const;</i> — The list of the output transports.</li>
<li> <i>bool outPresent( const string &amp;id ) const;</i> — Check for an output transport presence.</li>
<li> <i>string outAdd( const string &amp;id, const string &amp;db = "*.*" );</i> — Addition of the output transport. Returns the end created identifier.</li>
<li> <i>void outDel( const string &amp;id, bool complete = false );</i> — Deleting of the output transport. It is possible to completely delete with the database included, by setting the <i>complete</i> sign.</li>
<li> <i>AutoHD&lt;TTransportOut&gt; outAt( const string &amp;id ) const;</i> — Connection to the output transport.</li>
<li> <i>virtual string outAddrHelp( );</i> — Address format help of the output transport.</li>
<li> <i>int outLifeTime( );</i> — Output transport lifetime, 0 for disable.</li>
<li> <i>void setOutKeepAliveTm( int vl );</i> — Set the output transport lifetime, 0 for disable.</li>
<li> <i>TTransportS &amp;owner( ) const;</i> — "Transports" subsystem - the owner of the transport's type.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>virtual TTransportIn *In( const string &amp;name, const string &amp;db );</i> — The modular method of the creating/opening of the new "input" transport.</li>
<li> <i>virtual TTransportOut *Out( const string &amp;name, const string &amp;db );</i> — The modular method of the creating/opening of the new "output" transport.</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_input_transports_.28TTransportIn.29"><span class="mw-headline-number">6.3</span> <span id="TTransportIn" title="#TTransportIn">The object of the input transports (TTransportIn)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a>, <a href="#TConfig">TConfig</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By the objects of input transports of the subsystem's "Transports" modules.
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TTransportIn( const string &amp;id, const string &amp;db, TElem *el );</i> — Initializing constructor.</li>
<li> <i>string id( );</i> — Transport's Id.</li>
<li> <i>string workId( );</i> — Full ID including the ID of the module.</li>
<li> <i>string name( );</i> — Transport's name.</li>
<li> <i>string dscr( );</i> — Transport's description.</li>
<li> <i>string addr( ) const;</i> — Address.</li>
<li> <i>string protocols( );</i> — Linked transport protocols.</li>
<li> <i>virtual unsigned keepAliveReqs( );</i> — Maximum Keep Alive requests.</li>
<li> <i>virtual unsigned keepAliveTm( );</i> — Keep Alive time.</li>
<li> <i>virtual string getStatus( );</i> — Getting the status of the input transport.</li>
<li> <i>bool toStart( );</i> — The sign "To start".</li>
<li> <i>bool startStat( );</i> — The status "Running".</li>
<li> <i>string DB( bool qTop = false ) const;</i> — Transport's storage address, <i>qTop</i> for the storage queue top.</li>
<li> <i>string tbl( ) const;</i> — Transport's DB table.</li>
<li> <i>string fullDB( bool qTop = false ) const;</i> — Full name of the transport's storage table, <i>qTop</i> for the storage queue top.</li>
<li> <i>void setName( const string &amp;inm );</i> — Setting the name of transport in <i>inm</i>.</li>
<li> <i>void setDscr( const string &amp;idscr );</i> — Setting the description of transport in <i>idscr</i>.</li>
<li> <i>void setAddr( const string &amp;addr );</i> — Setting the address of transport in <i>addr</i>.</li>
<li> <i>void setProtocols( const string &amp;prt );</i> — Setting of the linked transport protocols.</li>
<li> <i>void setToStart( bool val );</i> — Setting of the sign "To start".</li>
<li> <i>void setDB( const string &amp;vl, bool qTop = false );</i> — Setting of the transport's storage address, <i>qTop</i> for the storage queue top.</li>
<li> <i>virtual void start( );</i> — Start of the transport.</li>
<li> <i>virtual void stop( );</i> — Stop of the transport.</li>
<li> <i>virtual int writeTo( const string &amp;sender, const string &amp;data );</i> — Sending <i>data</i> backward to the <i>sender</i>.</li>
<li> <i>vector&lt;AutoHD&lt;TTransportOut&gt; &gt; assTrs( bool checkForCleanDisabled = false );</i> — The assigned output transports massive, created by the input transport for typical requests to the connection initiator. Set <i>checkForCleanDisabled</i> for prior checking and clean up disabled ones.</li>
<li> <i>int logLen( );</i> — length of the IO log.</li>
<li> <i>void setLogLen( int vl );</i> — set length of the IO log.</li>
<li> <i>void pushLogMess( const string &amp;vl, const string &amp;data = "", int dataDir = 0 );</i> — push the message <i>vl</i> with the <i>data</i> in the direction <i>dataDir</i> to the log in the format "<b>{vl}\n{data}</b>".</li>
<li> <i>TTypeTransport &amp;owner( ) const;</i> — Transport's type – the owner of the input transport.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>string assTrO( const string &amp;addr );</i> — The assigned output transport creation with address <i>addr</i>.</li></ul>
<p><b>Protected attributes:</b>
</p>
<ul><li> <i>bool runSt;</i> — The sign "Running".</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_output_transports_.28TTransportOut.29"><span class="mw-headline-number">6.4</span> <span id="TTransportOut" title="#TTransportOut">The object of the output transports (TTransportOut)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a>, <a href="#TConfig">TConfig</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By the objects of output transports of the subsystem's "Transports" modules.
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TTransportOut( const string &amp;id, const string &amp;db, TElem *el );</i> — Initializing constructor.</li>
<li> <i>virtual bool isNetwork( );</i> — The sign — "The transport is network one", what is specified by the timeouts in seconds.</li>
<li> <i>string id( );</i> — Transport's Id.</li>
<li> <i>string workId( );</i> — Full ID including the ID of the module.</li>
<li> <i>string name( );</i> — Transport name.</li>
<li> <i>string dscr( );</i> — Transport description.</li>
<li> <i>string addr( ) const;</i> — Transport address.</li>
<li> <i>virtual string timings( );</i> — Transport timeouts.</li>
<li> <i>virtual unsigned short attempts( );</i> Connection attempts.</li>
<li> <i>TVariant conPrm( const string &amp;nm );</i> — Getting the connection parameter <i>nm</i> value.</li>
<li> <i>bool startStat( );</i> — Status "Running".</li>
<li> <i>time_t startTm( );</i> — Status "Time of starting/connection".</li>
<li> <i>int64_t lstReqTm( );</i> — Status "Last request time".</li>
<li> <i>virtual string getStatus( );</i> — Getting the status of the transport.</li>
<li> <i>string DB( bool qTop = false ) const;</i> — Transport's storage address, <i>qTop</i> for the storage queue top.</li>
<li> <i>string tbl( ) const;</i> — Transport's DB table.</li>
<li> <i>string fullDB( bool qTop = false ) const;</i> — Full name of the transport's DB table, <i>qTop</i> for the storage queue top.</li>
<li> <i>void setName( const string &amp;inm );</i> — Setting the name of transport.</li>
<li> <i>void setDscr( const string &amp;idscr );</i> — Setting the description of transport.</li>
<li> <i>void setAddr( const string &amp;addr );</i> — Setting the address of transport.</li>
<li> <i>virtual void setTimings( const string &amp;vl, bool isDef = false );</i> — Setting the transport timeouts, as default one for <i>isDef</i>.</li>
<li> <i>virtual void setAttempts( unsigned short vl );</i> — Setting the connection attempts.</li>
<li> <i>void setConPrm( const string &amp;nm, const TVariant &amp;vl );</i> — Setting the connection parameter <i>nm</i> to value <i>vl</i>.</li>
<li> <i>void clearConPrm( );</i> — Clearing the connection parameters.</li>
<li> <i>void setDB( const string &amp;vl, bool qTop = false );</i> — Setting of the transport's storage address, <i>qTop</i> for the storage queue top.</li>
<li> <i>virtual void start( int time = 0 );</i> — Start of the transport with connection time <i>time</i>.</li>
<li> <i>virtual void stop( );</i> — Stop of the transport.</li>
<li> <i>virtual int messIO(  const char *obuf, int len_ob, char *ibuf = NULL, int len_ib = 0, int time = 0 );</i> — Sending of the data over the transport. The waiting time <i>time</i> of the connection (in milliseconds). The <i>time</i> in negative disables the transport's request/respond mode and allow independent reading/writing to a buffer IO, with the reading timeout <i>time</i> in absolute.</li>
<li> <i>void messProtIO( XMLNode &amp;io, const string &amp;prot );</i> — Sending of the data in the XML tree <i>in</i> over the transport using the transport protocol <i>prot</i>.</li>
<li> <i>int logLen( );</i> — length of the IO log.</li>
<li> <i>void setLogLen( int vl );</i> — set length of the IO log.</li>
<li> <i>void pushLogMess( const string &amp;vl, const string &amp;data = "", int dataDir = 0 );</i> — push the message <i>vl</i> with the <i>data</i> in the direction <i>dataDir</i> to the log in the format "<b>{vl}\n{data}</b>".</li>
<li> <i>TTypeTransport &amp;owner( ) const;</i> — Type of transport - the owner of output transport.</li>
<li> <i>ResMtx &amp;reqRes( );</i> — The requesting resource, needs to global lock into protocols with fragments receiving.</li></ul>
<p><b>Protected attributes:</b>
</p>
<ul><li> <i>bool runSt;</i> — The sign "Running".</li>
<li> <i>int64_t mLstReqTm;</i> — The last request time.</li></ul>
<h2><span class="mw-headline" id="Subsystem_.22Transport_protocols.22"><span class="mw-headline-number">7</span> <span id="TProtocolS" title="#TProtocolS">Subsystem "Transport protocols"</span></span></h2>
<p>Subsystem "Communication interfaces' protocols" is presented by the TProtocolS object, which contains modular objects of the separate protocols TProtocol on the a subsystem's level. Each protocol contains objects of the opened sessions of the input protocols TProtocolIn.
</p><p>TProtocolS object provides an access to the both: the input and the output protocols of the individual types of transport protocols. The inner side of output protocol based on the steaming principle with the individual structure of the stream for each implementation of the protocol.
</p>
<h3><span class="mw-headline" id="The_object_of_the_.22Communication_interfaces.27_protocols.22_subsystem_.28TProtocolS.29"><span class="mw-headline-number">7.1</span> <span id="TProtocolS" title="#TProtocolS">The object of the "Communication interfaces' protocols" subsystem (TProtocolS)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TSubSYS">TSubSYS</a></i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>int subVer( );</i> — Subsystem's version.</li>
<li> <i>AutoHD&lt;TProtocol&gt; at( const string &amp;id ) const;</i> — Connection to the protocol's <i>id</i> module.</li></ul>
<h3><span class="mw-headline" id="The_modular_object_of_the_protocol_.28TProtocol.29"><span class="mw-headline-number">7.2</span> <span id="TProtocol" title="#TProtocol">The modular object of the protocol (TProtocol)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TModule">TModule</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By the root object of the subsystem's "Protocols" modules.
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>virtual void itemListIn( vector&lt;string&gt; &amp;ls, const string &amp;curIt = "" );</i> — Items list of protocol for individual addressing into transport.</li>
<li> <i>void list( vector&lt;string&gt; &amp;list ) const;</i> — The list of open input sessions.</li>
<li> <i>bool openStat( const string &amp;name ) const;</i> — Check for the openness of the input session with the specified name.</li>
<li> <i>void open( const string &amp;name, TTransportIn *tr = NULL, const string &amp;sender = "" );</i> — Opening of the session on behalf of the input transport <i>tr</i>.</li>
<li> <i>void close( const string &amp;name );</i> — Closing of the input session.</li>
<li> <i>AutoHD&lt;TProtocolIn&gt; at( const string &amp;name ) const;</i> — Connecting to the open input sessions.</li>
<li> <i>virtual void outMess( XMLNode &amp;io, TTransportOut &amp;tro );</i> — Sending the data in the XML tree <i>in</i> over the protocol and transport <i>tro</i>.</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_input_protocol.27s_session_.28TProtocolIn.29"><span class="mw-headline-number">7.3</span> <span id="TProtocolIn" title="#TProtocolIn">The object of the input protocol's session (TProtocolIn)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By the session objects of the input modules' protocol of the subsystem "Protocols".
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TProtocolIn( const string &amp;name );</i> — Initializing constructor.</li>
<li> <i>string name( );</i> — The name of the input session.</li>
<li> <i>AutoHD&lt;TTransportIn&gt; &amp;srcTr( )</i> — The transport-source of the opening of the session of the input protocol.</li>
<li> <i>const string &amp;srcAddr( )</i> — The sender address; second line contains service part of the address for backward messages.</li>
<li> <i>virtual unsigned waitReqTm( );</i> — A request waiting time on input transport (in milliseconds), after what call to the protocol with the empty message — the polling mode. Setting it to zero will disable the polling mode.</li>
<li> <i>virtual void setSrcTr( TTransportIn *vl )</i> — Setting of the transport-source of the opening of the session of the input protocol.</li>
<li> <i>virtual void setSrcAddr( const string &amp;vl );</i> — Setting of the sender address.</li>
<li> <i>int writeTo( const string &amp;data );</i> — Sending the messages <i>data</i> backward to the sender, into srcAddr().</li>
<li> <i>virtual bool mess( const string &amp;request, string &amp;answer );</i> — Transfer of unstructured data to their processing by the protocol.</li>
<li> <i>TProtocol &amp;owner( ) const;</i> — The protocol, the owner of input sessions.</li></ul>
<h2><span class="mw-headline" id="Subsystem_.22User_interfaces.22"><span class="mw-headline-number">8</span> Subsystem "User interfaces"</span></h2>
<p>The subsystem "User Interfaces" is presented by the TUIS object, which contains modular objects of the TUI user interfaces' on the subsystem's level.
</p>
<h3><span class="mw-headline" id="The_object_of_the_.22User_interfaces.22_subsystem_.28TUIS.29"><span class="mw-headline-number">8.1</span> <span id="TUIS" title="#TUIS">The object of the "User interfaces" subsystem (TUIS)</span></span></h3>
<table class="wikitable">

<tr>
<td> <b>Inherits:</b> </td>
<td> <i><a href="#TSubSYS">TSubSYS</a></i>
</td></tr></table>
<p><b>Data:</b><br />
Requests parameters (enum — GetOpts):
</p>
<ul><li> <i>GetPathURL</i> (1) — Path get.</li>
<li> <i>GetContent</i> (2) — Open document command get.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>int subVer( );</i> — Subsystem's version.</li>
<li> <i>void subStart( );</i> — Start of the subsystem.</li>
<li> <i>void subStop( );</i> — Stop of the subsystem.</li>
<li> <i>AutoHD&lt;TUI&gt; at( const string &amp;name ) const;</i> — Connects to the user's interface module.</li>
<li> <i>string fontSnthHglCode( );</i> — Getting the font name used in the syntax highlight for code.</li>
<li> <i>void setFontSnthHglCode( const string &amp;val )</i> — Setting the font name used in the syntax highlight for code.</li>
<li> <i>static string icoGet( const string &amp;inm, string *tp = NULL, bool retPath = false );</i> — Downloads image of the icon <i>inm</i> from standard directories or return path, on <i>retPath</i>, to allowed icon. Detecting icons for file extensions "png", "gif", "jpg", "jpeg", which return into <i>tp</i>.</li>
<li> <i>static string docGet( const string &amp;inm, string *tp = NULL, unsigned opt = 0 );</i> — Downloads document <i>inm</i> from standard directories or return path, on <i>retPath</i>, to allowed document. Detecting documents for file extensions "pdf", "html", "odt", which return into <i>tp</i>.</li>
<li> <i>static string docKeyGet( const string &amp;itxt );</i> — Gets the inline documentation key from the text <i>itxt</i> of a configuration field, often it is the node description and the key "DOC" in it.</li>
<li> <i>static string mimeGet( const string &amp;inm, const string &amp;fDt, const string &amp;orig = "" );</i> — Gets file's mime type in view <b>{group}/{type}</b> for the file name <i>inm</i>, its content <i>fDt</i> and the original hint <i>orig</i>.</li></ul>
<h3><span class="mw-headline" id="The_modular_object_of_the_user_interface_.28TUI.29"><span class="mw-headline-number">8.2</span> <span id="TUI" title="#TUI">The modular object of the user interface (TUI)</span></span></h3>
<table class="wikitable">

<tr>
<td> <b>Inherits:</b> </td>
<td> <i><a href="#TModule">TModule</a></i>
</td></tr>
<tr>
<td> <b>Inherited:</b> </td>
<td> By the root objects of the "User interfaces" subsystem.
</td></tr></table>
<p><b>Protected attributes:</b>
</p>
<ul><li> <i>bool runSt;</i> — The sign "Running".</li></ul>
<h2><span class="mw-headline" id="Subsystem_.22Specials.22"><span class="mw-headline-number">9</span> Subsystem "Specials"</span></h2>
<p>The subsystem "Specials" is presented by TSpecialS object, which contains modular objects of TSpecial special on the subsystem's level.
</p>
<h3><span class="mw-headline" id="The_object_of_the_.22Specials.22_subsystem_.28TSpecialS.29"><span class="mw-headline-number">9.1</span> <span id="TSpecialS" title="#TSpecialS">The object of the "Specials" subsystem (TSpecialS)</span></span></h3>
<table class="wikitable">

<tr>
<td>Inherits:</td>
<td><i><a href="#TSubSYS">TSubSYS</a></i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>int subVer( );</i> — Subsystem's version.</li></ul>
<h3><span class="mw-headline" id="The_modular_object_of_the_specials_.28TSpecial.29"><span class="mw-headline-number">9.2</span> <span id="TSpecial" title="#TSpecial">The modular object of the specials (TSpecial)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TModule">TModule</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By the root objects of the subsystem's “Specials” modules.
</td></tr></table>
<p><b>Protected attributes:</b>
</p>
<ul><li> <i>bool runSt;</i> — The sign "Running".</li></ul>
<h2><span class="mw-headline" id="Subsystem_.22Security.22"><span class="mw-headline-number">10</span> Subsystem "Security"</span></h2>
<p>Security subsystem is presented by an object TSesurity, which contains group objects of TGroup and users TUser.
</p><p>User object TUser contains user information and checks the authenticity of the user in accordance with the specified password.
</p><p>TGroup user object contains information about the group of users and checks the user's belonging to the group.
</p>
<h3><span class="mw-headline" id="The_object_of_the_.22Security.22_subsystem_.28TSe.D1.81urity.29"><span class="mw-headline-number">10.1</span> <span id="TSe.D1.81urity" title="#TSeсurity">The object of the "Security" subsystem (TSeсurity)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TSubSYS">TSubSYS</a></i>
</td></tr></table>
<p><b>Data (definition):</b><br />
</p>
<ul><li> <i>SEC_HASH_MAGIC</i> — String-pointer (prefix) of the passwords in the hash.</li></ul>
<dl><dd> <i>Masks of the security access</i></dd></dl>
<ul><li> <i>SEC_XT</i> — Execution (0x01);</li>
<li> <i>SEC_WR</i> — Writing (0x02);</li>
<li> <i>SEC_RD</i> — Reading (0x04).</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>bool access( const string &amp;user, char mode, int owner, int groups, int access );</i> — Check the access of the <i>user</i> in the <i>mode</i> to the resource with the <i>owner</i>, <i>groups</i> (separated ',') and permition <i>access</i>.</li>
<li> <i>void usrList( vector&lt;string&gt; &amp;list ) const;</i> — The list of the users <i>list</i>.</li>
<li> <i>void usrGrpList( const string &amp;name, vector&lt;string&gt; &amp;list );</i> — The list of the users' groups <i>list</i>, in which the user <i>name</i> is included.</li>
<li> <i>bool usrPresent( const string &amp;name ) const;</i> — Check fro the presence of the specified user <i>name</i>.</li>
<li> <i>string usrAdd( const string &amp;name, const string &amp;db = "*.*" );</i> — Addition of the user <i>name</i> with the saving to the DB <i>db</i>. Returns the end created name of the user.</li>
<li> <i>void usrDel( const string &amp;name, bool complete = false );</i> — Deleting of the user <i>name</i> with the possibility of the completely deleting <i>complete</i>.</li>
<li> <i>AutoHD&lt;TUser&gt; usrAt( const string &amp;name ) const;</i> — Attaching of the user <i>name</i>.</li>
<li> <i>void grpList( vector&lt;string&gt; &amp;list ) const;</i> — The list of the users' groups <i>list</i>.</li>
<li> <i>bool grpPresent( const string &amp;name ) const;</i> — Check fro the presence of the specified users' group <i>name</i>.</li>
<li> <i>string grpAdd( const string &amp;name, const string &amp;db = "*.*" );</i> — Addition of the users' group <i>name</i> with the saving to the DB <i>db</i>. Returns the end created name of the user group.</li>
<li> <i>void grpDel( const string &amp;name, bool complete = false );</i> — Deleting of the users' group <i>name</i> with the possibility of the completely deleting <i>complete</i>.</li>
<li> <i>AutoHD&lt;TGroup&gt; grpAt( const string &amp;name ) const;</i> — Connection to the users' group <i>name</i>.</li></ul>
<h3><span class="mw-headline" id="The_user.27s_object_.28TUser.29"><span class="mw-headline-number">10.2</span> <span id="TUser" title="#TUser">The user's object (TUser)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a>, <a href="#TConfig">TConfig</a></i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TUser( const string &amp;name, const string &amp;db, TElem *el );</i> — Initialising constructor.</li>
<li> <i>string name( );</i> — User name.</li>
<li> <i>string descr( );</i> — User description.</li>
<li> <i>string longDescr( );</i> — User long description.</li>
<li> <i>string picture( );</i> — User image.</li>
<li> <i>string lang( );</i> — User language, only into the dynamic translation text variables mode.</li>
<li> <i>bool sysItem( );</i> — Sign of the system user.</li>
<li> <i>bool auth( const string &amp;pass, string *hash = NULL );</i> — Check the authenticity of the user by the password <i>pass</i>. The password hash, if it is supports, placing into the <i>hash</i>.</li>
<li> <i>int permitCmpr( const string &amp;user );</i> — Comparing the <i>user</i> permition with the user object. Returns -1 for lesser, 1 for greater and 0 for even permition.</li>
<li> <i>string DB( bool qTop = false ) const;</i> — User storage address, <i>qTop</i> for the storage queue top.</li>
<li> <i>string tbl( ) const;</i> — Address of the table of user's storage.</li>
<li> <i>string fullDB( bool qTop = false ) const;</i> — Full name of the table of user's storage, <i>qTop</i> for the storage queue top.</li>
<li> <i>void setDescr( const string &amp;vl );</i> — Setting user's description to <i>vl</i>.</li>
<li> <i>void setLongDescr( const string &amp;vl );</i> — Setting user's long description to <i>vl</i>.</li>
<li> <i>void setPicture( const string &amp;pct );</i> — Setting user's image to <i>pct</i>.</li>
<li> <i>void setLang( const string &amp;vl );</i> — Setting user's language to <i>vl</i>.</li>
<li> <i>void setPass( const string &amp;pass );</i> — Setting user's password to <i>pass</i>.</li>
<li> <i>void setSysItem( bool vl );</i> — Setting the sign of system user to <i>vl</i>.</li>
<li> <i>void setDB( const string &amp;vl, bool qTop = false );</i> — Setting the user's storage address, <i>qTop</i> for the storage queue top.</li>
<li> <i>TSeсurity &amp;owner( ) const;</i> — "Security" subsystem - the owner of the user.</li></ul>
<h3><span class="mw-headline" id="The_users.27_group_object_.28TGroup.29"><span class="mw-headline-number">10.3</span> <span id="TGroup" title="#TGroup">The users' group object (TGroup)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a>, <a href="#TConfig">TConfig</a></i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TGroup( const string &amp;name, const string &amp;db, TElem *el );</i> —  Initializing constructor.</li>
<li> <i>string name( );</i> — Users group name.</li>
<li> <i>string descr( );</i> — Users group description.</li>
<li> <i>string longDescr( );</i> — Users group long description.</li>
<li> <i>bool sysItem( );</i> — The sign of the system user.</li>
<li> <i>string DB( bool qTop = false ) const;</i> — Users' group storage address, <i>qTop</i> for the storage queue top.</li>
<li> <i>string tbl( ) const;</i> — Address of the table of the users' group DB.</li>
<li> <i>string fullDB( bool qTop = false ) const;</i> — Full name of the table of the users' group storage, <i>qTop</i> for the storage queue top.</li>
<li> <i>void setDescr( const string &amp;vl );</i> — Setting users group description to <i>vl</i>.</li>
<li> <i>void setLongDescr( const string &amp;vl );</i> — Setting users group long description to <i>vl</i>.</li>
<li> <i>void setDB( const string &amp;vl, bool qTop = false );</i> — Setting the users' group storage address, <i>qTop</i> for the storage queue top.</li>
<li> <i>bool user( const string &amp;name );</i> — Check for the user's belonging to the group <i>name</i>.</li>
<li> <i>void userAdd( const string &amp;name );</i> — Addition of the user <i>name</i> to the group.</li>
<li> <i>void userDel( const string &amp;name );</i> — Deleting of the user <i>name</i> from the group.</li>
<li> <i>TSeсurity &amp;owner( ) const;</i> — "Security" subsystem - the owner of the users' group.</li></ul>
<h2><span class="mw-headline" id="Subsystem_.22Modules_scheduler.22"><span class="mw-headline-number">11</span> Subsystem "Modules scheduler"</span></h2>
<p>Subsystem “Modules' sheduling” is presented by the object TModSchedul.
</p><p>The subsystem contains the control mechanism for modules contained in shared libraries.
</p>
<h3><span class="mw-headline" id="The_object_of_the_subsystem_.22Modules.27_sheduling.22_.28TModSchedul.29"><span class="mw-headline-number">11.1</span> <span id="TModSchedul" title="#TModSchedul">The object of the subsystem "Modules' sheduling" (TModSchedul)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TSubSYS">TSubSYS</a></i>
</td></tr></table>
<p><b>Data:</b><br />
The structure of information about the shared library (struct – TModSchedul::SHD):
</p>
<ul><li> <i>void *hd;</i> — the title of the shared library (if NULL, the library is present, but not connected);</li>
<li> <i>vector&lt;string&gt; use;</i> — list of connected modules;</li>
<li> <i>time_t tm;</i> — modification time of the library;</li>
<li> <i>string name;</i> — full name/path of the shared library.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>string allowList( ) const;</i> — The list of permitted shared libraries (modules).</li>
<li> <i>string denyList( );</i> — The list of prohibited shared libraries (modules).</li>
<li> <i>int chkPer( );</i> — The verification period of the directory with the modules (s).</li>
<li> <i>void setAllowList( const string &amp;vl );</i> — Setting of the list of permitted shared libraries (modules).</li>
<li> <i>void setDenyList( const string &amp;vl );</i> — Setting of the list of prohibited shared libraries (modules).</li>
<li> <i>void setChkPer( int per );</i> — Setting the verification period of the directory with the modules (s). If the frequency is equal to zero, the check will be disabled.</li>
<li> <i>void subStart( );</i> — Subsystem's start.</li>
<li> <i>void subStop( );</i> — Subsystem's stop.</li>
<li> <i>int loadLibS( );</i> — Loading the shared libraries and initialization of the modules. Return numbers loaded modules.</li>
<li> <i>SHD &amp;lib( const string &amp;name );</i> — Getting the shared library object <i>name</i>.</li>
<li> <i>void libList( vector&lt;string&gt; &amp;list );</i> — The list of shared libraries <i>list</i>.</li>
<li> <i>int libLoad( const string &amp;path, bool full );</i> — Loading the shared libraries from the specified path <i>path</i>. Return numbers loaded modules.</li>
<li> <i>void libAtt( const string &amp;name, bool full = false);</i> — Attaching of the specified shared library <i>name</i>.</li>
<li> <i>void libDet( const string &amp;name );</i> — Detaching of the specified shared library <i>name</i>.</li></ul>
<h2><span class="mw-headline" id="Components_of_the_object_model_of_OpenSCADA"><span class="mw-headline-number">12</span> Components of the object model of OpenSCADA</span></h2>
<p>Object model of OpenSCADA is based on the function object <i>TFunction</i>, on the parameters of the function <i>IO</i> and on the values' frame of the function <i>TValFunc</i>. Later the function's objects are included in the object tree, forming an object model of the system. Using the functions of the object model is made by linking the frame of values <i>TValFunc</i> with function.
</p><p>The idea in general is shown in Fig. 7.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:602px;"><a class="image" href="http://oscada.org/wiki/File:LogicLev_func_base.png"><img class="thumbimage" height="469" src="files/LogicLev_func_base.png" width="600" /></a>  <div class="thumbcaption">Fig. 7. Basis of the programming area of OpenSCADA.</div></div></div></div>
<p>Object of the function (TFunction) provides an interface for the formation of function parameters and algorithm of the computing in the object which inherits it.
</p><p>Object of the function's parameter (IO) contains the configuration of the single parameter.
</p><p>Object of the values' frame (TValFunc) contains values in accordance with the structure of the linked function. While the execution of the algorithm by the associated function the values of this object are used.
</p>
<h3><span class="mw-headline" id="The_function_object_.28TFunction.29"><span class="mw-headline-number">12.1</span> <span id="TFunction" title="#TFunction">The function object (TFunction)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TCntrNode">TCntrNode</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td>By the modules and nodes of the systems, which contains the functions for publication in the object model of the system.
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TFunction( const string &amp;id, const char *grp = "root", const string &amp;istor = "" );</i> — Initializing constructor of the function with the identifier <i>id</i>, users group <i>grp</i> and storage <i>stor</i>.</li>
<li> <i>TFunction( const TFunction &amp;src );</i> — Copying constructor.</li>
<li> <i>TFunction &amp;operator=( const TFunction &amp;func );</i> — Copying of functions.</li>
<li> <i>string id( ) const;</i> — Function ID.</li>
<li> <i>virtual string name( );</i> — Localized name of the function.</li>
<li> <i>virtual string descr( );</i> — Description of the function.</li>
<li> <i>virtual string prog( );</i> — Program's text of the function, for no static ones.</li>
<li> <i>virtual string stor( );</i> — Storage DB, for table "Trs" mostly.</li>
<li> <i>bool startStat( ) const;</i> — Status - "Running".</li>
<li> <i>int use( );</i> — Counter of the function's using.</li>
<li> <i>ResRW &amp;fRes( );</i> — Link to the resource of the function.</li>
<li> <i>void setId( const string &amp;vl );</i> — Set the function identifier.</li>
<li> <i>virtual void setProg( const string &amp;prg );</i> — Set program's text of the function, for no static ones.</li>
<li> <i>void setStor( const string &amp;istor );</i> — Set storage DB to <i>stor</i>.</li>
<li> <i>virtual void setStart( bool val );</i> — Start/stop <i>val</i> of the function.</li>
<li> <i>void ioList( vector&lt;string&gt; &amp;list );</i> — The list of the function's parameters <i>list</i>.</li>
<li> <i>int ioId( const string &amp;id ) const;</i> — Getting the index of the function's parameter <i>id</i>.</li>
<li> <i>int ioSize( ) const;</i> — The quantity of the function's parameters.</li>
<li> <i>IO *io( int id ) const;</i> — Getting the function's parameter by the index <i>id</i>.</li>
<li> <i>int ioAdd( IO *io );</i> — Addition of the function's parameter <i>io</i>. Returns the actual position of the new IO.</li>
<li> <i>int ioIns( IO *io, int pos );</i> — Insert of the function's parameter <i>io</i> into the position <i>pos</i>. Returns the actual position of the new IO.</li>
<li> <i>void ioDel( int pos );</i> — Deleting the function's parameter in the position <i>pos</i>.</li>
<li> <i>void ioMove( int pos, int to );</i> — Moving the function's parameter from the position <i>pos</i> to the position <i>to</i>.</li>
<li> <i>virtual void calc( TValFunc *val );</i> — The calculation of the function's algorithm of the specified values <i>val</i>.</li>
<li> <i>virtual void valAtt( TValFunc *vfnc );</i> — Is called by the object of the values' frame <i>vfnc</i> in the case of attaching with the function.</li>
<li> <i>virtual void valDet( TValFunc *vfnc );</i> — Is called by the object of the values' frame <i>vfnc</i> in the case of detaching from the function.</li>
<li> <i>virtual void preIOCfgChange( );</i> — Is called before the changing of the configuration of the function.</li>
<li> <i>virtual void postIOCfgChange( );</i> — Is called after the changing of the configuration of the function.</li></ul>
<p><b>Protected attributes:</b>
</p>
<ul><li> <i>string mId;</i> — Function ID.</li>
<li> <i>bool runSt;</i> — Sign - "Running".</li>
<li> <i>bool beStart;</i> — Sign - "Start".</li>
<li> <i>TValFunc *mTVal;</i> — Reference to the values' object, used for testing the function. May be absent.</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_function.27s_parameter_.28IO.29"><span class="mw-headline-number">12.2</span> <span id="IO" title="#IO">The object of the function's parameter (IO)</span></span></h3>
<p><b>Data:</b><br />
Parameter's type (enum — IO::Type):
</p>
<ul><li> <i>IO::String</i> (0) — string/text;</li>
<li> <i>IO::Integer</i> (1) — integer;</li>
<li> <i>IO::Real</i> (2) — real;</li>
<li> <i>IO::Boolean</i> (3) — boolean;</li>
<li> <i>IO::Object</i> (4) — object.</li></ul>
<p>Parameter's flags (enum — IO::IOFlgs):
</p>
<ul><li> <i>IO::Default</i> (0x00) — default mode (input);</li>
<li> <i>IO::Output</i> (0x01) — output;</li>
<li> <i>IO::Return</i> (0x02) — return;</li>
<li> <i>IO::FullText</i> (0x04) — full-text string;</li>
<li> <i>IO::Selectable</i> (0x08) — selectable;</li>
<li> <i>IO::TransltText</i> (0x1000) — being translated string, <a href="#TPrmTempl">TPrmTempl</a> reserves the flags range [0x10...0x0800].</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>IO( const char *id, const char *name, IO::Type type, unsigned flgs, const char *def = "", bool hide = false, const char *rez = "" );</i> — Initializing constructor.</li>
<li> <i>IO( const IO &amp;src );</i> — Copying constructor.</li>
<li> <i>IO &amp;operator=( const IO &amp;iio );</i> — Copying of the function parameters.</li>
<li> <i>const string &amp;id( ) const;</i> — ID of the function's parameter.</li>
<li> <i>string name( ) const;</i> — The localized name of the function's parameter.</li>
<li> <i>const Type &amp;type( ) const;</i> — The type of the function's parameter.</li>
<li> <i>unsigned flg( ) const;</i> — The flags of the function's parameter.</li>
<li> <i>const string &amp;def( ) const;</i> — Default value.</li>
<li> <i>bool hide( ) const;</i> — Sign - "Hide".</li>
<li> <i>const string &amp;rez( ) const;</i> — The reserve property of the function's parameter.</li>
<li> <i>void setId( const string &amp;val );</i> — Set the identifier to <i>val</i>.</li>
<li> <i>void setName( const string &amp;val );</i> — Set the name to <i>val</i>.</li>
<li> <i>void setType( Type val );</i> — Set the type to <i>val</i>.</li>
<li> <i>void setFlg( unsigned val );</i> — Set the flags to <i>val</i>.</li>
<li> <i>void setDef( const string &amp;val );</i> — Set the default value to <i>val</i>.</li>
<li> <i>void setHide( bool val );</i> — Set/unset the sign - "Hide".</li>
<li> <i>void setRez( const string &amp;val );</i> — Set the reserve property to <i>val</i>.</li></ul>
<h3><span class="mw-headline" id="The_object_of_the_function.27s_value_.28TValFunc.29"><span class="mw-headline-number">12.3</span> <span id="TValFunc" title="#TValFunc">The object of the function's value (TValFunc)</span></span></h3>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TValFunc( const string &amp;iname = "", TFunction *ifunc = NULL, bool iblk = true );</i> — Initializing constructor.</li>
<li> <i>bool blk( );</i> — The sign — "Blocking of the parameters' changes of the function".</li>
<li> <i>bool mdfChk( );</i> — The sign — "To check attributes to modify".</li>
<li> <i>bool isChangedProg( bool clear = false );</i> — The sign — "The program changing" with it clearing by <i>clear</i>.</li>
<li> <i>bool isCalc( );</i> — The sign — "The function calculation".</li>
<li> <i>string user( );</i> — User on whose behalf the function is executed.</li>
<li> <i>string lang( );</i> — Language on whose the function is executed.</li>
<li> <i>const string &amp;vfName( );</i> — Name of the values' object.</li>
<li> <i>void setUser( const string &amp;vl );</i> — Set the user on whose behalf the function will be executed.</li>
<li> <i>void setLang( const string &amp;vl );</i> — Set the language on whose the function will be executed.</li>
<li> <i>void setVfName( const string &amp;nm );</i> — Set the name of the values' object to <i>nm</i>.</li>
<li> <i>void setMdfChk( bool set );</i> — Set/unset <i>set</i> of the sign - "To check attributes to modify".</li>
<li> <i>void ioList( vector&lt;string&gt; &amp;list );</i> — The list of the function's parameters <i>list</i>.</li>
<li> <i>int ioId( const string &amp;id );</i> — Getting the parameter's index <i>id</i>.</li>
<li> <i>int ioSize( ) const;</i> — The whole quantity of the parameters.</li>
<li> <i>IO::Type ioType( unsigned id );</i> — Parameter's type <i>id</i>.</li>
<li> <i>unsigned ioFlg( unsigned id ) const;</i> — Parameter's flags <i>id</i>.</li>
<li> <i>bool ioHide( unsigned id );</i> — Parameter's sign <i>id</i> - "Hide".</li>
<li> <i>bool ioMdf( unsigned id );</i> — Parameter's sign <i>id</i> - "Modified".</li>
<li> <i>TVariant get( unsigned id );</i> — Get the value of the parameter <i>id</i>.</li>
<li> <i>string getS( unsigned id );</i> — Get the value (string) of the parameter <i>id</i>.</li>
<li> <i>int64_t getI( unsigned id );</i> — Get the value (integer) of the parameter <i>id</i>.</li>
<li> <i>double getR( unsigned id );</i> — Get the value (real) of the parameter <i>id</i>.</li>
<li> <i>bool getB( unsigned id );</i> — Get the value (boolean) of the parameter <i>id</i>.</li>
<li> <i>AutoHD&lt;TVarObj&gt;	getO( unsigned id );</i> — Get the value of the parameter's object <i>id</i>.</li>
<li> <i>void set( unsigned id, const TVariant &amp;val );</i> — Set the value <i>val</i> of the parameter <i>id</i>.</li>
<li> <i>void setS( unsigned id, const string &amp;val );</i> — Set the value <i>val</i> (string) of the parameter <i>id</i>.</li>
<li> <i>void setI( unsigned id, int64_t val );</i> — Set the value <i>val</i> (integer) of the parameter <i>id</i>.</li>
<li> <i>void setR( unsigned id, double val );</i> — Set the value <i>val</i> (real) of the parameter <i>id</i>.</li>
<li> <i>void setB( unsigned id, bool val );</i> — Set the value <i>val</i> (boolean) of the parameter <i>id</i>.</li>
<li> <i>void setO( unsigned id, AutoHD&lt;TVarObj&gt; val );</i> — Set the value <i>val</i> of the parameter's object <i>id</i>.</li>
<li> <i>virtual void calc( const string &amp;user = "" );</i> — To calculate on behalf of the user <i>user</i> or user, specified earlier.</li>
<li> <i>double calcTm( );</i> — Computation time.</li>
<li> <i>void setCalcTm( double vl );</i> — Initializing of the time of value's calculation <i>vl</i>.</li>
<li> <i>TFunction *func( );</i> — Attached function.</li>
<li> <i>void setFunc( TFunction *func, bool att_det = true );</i> — To attach with the specified function <i>func</i>.</li>
<li> <i>virtual void preIOCfgChange( );</i> — Is called before the configuration changes.</li>
<li> <i>virtual void postIOCfgChange( );</i> — Is called after the configuration changes.</li>
<li> <i>virtual void progChange( );</i> —  Is called at the program changing.</li>
<li> <i>TValFunc *ctxGet( int key );</i> — Get context for key <i>key</i>.</li>
<li> <i>void ctxSet( int key, TValFunc *val );</i> — Set context for key <i>key</i>.</li>
<li> <i>void ctxClear( );</i> — External functions call context clear.</li></ul>
<p><b>Public attributes:</b>
</p>
<ul><li> <i>void *exCtx;</i> — The function execution context.</li></ul>
<h2><span class="mw-headline" id="Data_in_OpenSCADA_and_their_storage"><span class="mw-headline-number">13</span> <span id="Data" title="#Data">Data in OpenSCADA and their storage</span></span></h2>
<p>Storing data in the program is based on the objects <i><a href="#TConfig">TConfig</a></i> and <i><a href="#TElem">TElem</a></i>. These objects store the structure and field values of the storage, allowing for direct loading and saving the configuration via the <a href="#TBDS">"DB" subsystem</a>. For the specialised different types of the data storage the <i><a href="#TVariant">TVariant</a></i> object is provided.
</p><p>The <i>TElem</i> object contains the structure of database record. Structure of the record contains extensive information about the elements, their types, sizes and other parameters. Information in that structure is enough to create, control and manage the real structure of the database. Elementary unit of the record is the cell <i><a href="#TFld">TFld</a></i>.
</p><p>The <i>TConfig</i> object is the heir of <i>TElem</i> and contains the actual values of elements. <i>TConfig</i> is used as the parameter in the functions of the manipulating with the table records in the "DB" subsystem. Elementary unit of the record is the cell <i><a href="#TCfg">TCfg</a></i>.
</p><p>To provide an opportunity to inform the data storehouse about the changes in the structure it is provides an object <i><a href="#TValElem">TValElem</a></i>, from which it is inherited the storehouse <i>TConfig</i> and the list of which is contained in the <i>TElem</i> structure.
</p>
<h3><span class="mw-headline" id="Data_storing_conception"><span class="mw-headline-number">13.1</span> <span id="DataConcept" title="#DataConcept">Data storing conception</span></span></h3>
<p>OpenSCADA commonly defines and uses as the storage only the Configuration File and the Data Bases of different types of the "DB" subsystem. Where the Configuration File has the highest priority as an obligatory and always present storage.
</p><p>The Generic Storage is a common system configuration field of selection a storage for common program data and as default storage value of OpenSCADA nodes to store. As the Generic Storage there can be selected whether the Configuration File "<b>&lt;cfg&gt;</b>" or a DB "<b>{DB module}.{DB name}</b>", and the same is pointed as "<b>*.*</b>" for enabling the implicit data accessing method in OpenSCADA nodes.
</p><p>There are provided two variants of the data accessing:
</p>
<ol><li> directly and exclusively at the specified storage name;</li>
<li> implicitly at specifying the Generic Storage name "<b>*.*</b>", what commonly means of accessing to the Configuration File firstly and the Generic Storage DB secondary, at the data missing in the Configuration File.</li></ol>
<p>The "DB" subsystem (the class <i>TBDS</i>) provides the functions <i>dataSeek()</i>, <i>dataGet()</i>, <i>dataSet()</i>, <i>dataDel()</i> of accessing the data which perform the data accessing variants in such ways:
</p>
<ul><li> <i>dataSeek()</i> — the data seeking function:</li></ul>
<dl><dd><ol><li> seeking data only the directly specified storage;</li>
<li> throughout seeking the Configuration File and the Generic Storage DB.</li></ol></dd></dl>
<ul><li> <i>dataGet()</i> — the data getting function:</li></ul>
<dl><dd><ol><li> getting data only the directly specified storage;</li>
<li> getting the present data in the Configuration File, next the Generic Storage DB data at missing in the Configuration File.</li></ol></dd></dl>
<ul><li> <i>dataSet()</i> — the data setting function:</li></ul>
<dl><dd><ol><li> setting data only to the directly specified storage;</li>
<li> setting the present data in the Configuration File, next the Generic Storage DB data at missing in the Configuration File; provides the flag <i>TBDS::OnlyCfg</i> support to force the new data creation in the Configuration File.</li></ol></dd></dl>
<ul><li> <i>dataDel()</i> — the data deleting function:</li></ul>
<dl><dd><ol><li> deleting data only in the directly specified storage;</li>
<li> deleting the data both in the Configuration File and the Generic Storage DB.</li></ol></dd></dl>
<p>The testing scenarios of the data accessing:
</p>
<ul><li> creating and loading to/from the work Data Base of the Generic Storage: DB, Security.{User,Group}, Transport.{Input,Output}, ExtTansp, DAQ.{Controller,TemplateLib}, Archives.{VArchive,VArchiver,MArchiver}, DAQ.JavaLikeCalc.Lib, Protocol.{ModBus,OPC_UA,UserProtocol}.*, UI.WebUser.Page, UI.VCAEngine.{WdgLib,Proj}.</li>
<li> saving and loading to/from the Configuration File of the Generic Storage (with presence in the work Data Base): DB, Security.{User,Group}, Transport.{Input,Output}, ExtTansp, DAQ.{Controller,TemplateLib}, Archives.{VArchive,VArchiver,MArchiver}, DAQ.JavaLikeCalc.Lib, Protocol.{ModBus,OPC_UA,UserProtocol}.*, UI.WebUser.Page, UI.VCAEngine.{WdgLib,Proj}.</li>
<li> complete removing from the Generic Storage (both the Configuration File and the work Data Base): DB, Security.{User,Group}, Transport.{Input,Output}, ExtTansp, DAQ.{Controller,TemplateLib}, Archives.{VArchive,VArchiver,MArchiver}, DAQ.JavaLikeCalc.Lib, Protocol.{ModBus,OPC_UA,UserProtocol}.*, UI.WebUser.Page, UI.VCAEngine.{WdgLib,Proj}.</li>
<li> creating and loading directly to/from the library Data Base: Security.{User,Group}, Transport.{Input,Output}, DAQ.{Controller,TemplateLib}, Archives.{VArchive,VArchiver,MArchiver}, DAQ.JavaLikeCalc.Lib, Protocol.{ModBus,OPC_UA,UserProtocol}.*, UI.WebUser.Page, UI.VCAEngine.{WdgLib,Proj}.</li>
<li> saving directly to the Configuration File, removing from the library Data Base and loading from the Configuration File: Security.{User,Group}, Transport.{Input,Output}, DAQ.{Controller,TemplateLib}, Archives.{VArchive,VArchiver,MArchiver}, DAQ.JavaLikeCalc.Lib, Protocol.{ModBus,OPC_UA,UserProtocol}.*, UI.WebUser.Page, UI.VCAEngine.{WdgLib,Proj}.</li>
<li> removing from the Configuration File as a main part of the Generic Storage: Security.{User,Group}, Transport.{Input,Output}, DAQ.{Controller,TemplateLib}, Archives.{VArchive,VArchiver,MArchiver}, DAQ.JavaLikeCalc.Lib, Protocol.{ModBus,OPC_UA,UserProtocol}.*, UI.WebUser.Page, UI.VCAEngine.{WdgLib,Proj}.</li></ul>
<h3><span class="mw-headline" id="Data_object_.28TConfig.29"><span class="mw-headline-number">13.2</span> <span id="TConfig" title="#TConfig">Data object (TConfig)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TValElem">TValElem</a></i>
</td></tr>
<tr>
<td><b>Inherited:</b></td>
<td><i><a href="#TParamContr">TParamContr</a>, <a href="#TController">TController</a>, <a href="#TMArchivator">TMArchivator</a>, <a href="#TPrmTempl">TPrmTempl</a>, <a href="#TPrmTmplLib">TPrmTmplLib</a>, <a href="#TUser">TUser</a>, <a href="#TGroup">TGroup</a>, <a href="#TTransportIn">TTransportIn</a>, <a href="#TTransportOut">TTransportOut</a>, <a href="#TBD">TBD</a>, <a href="#TVArchive">TVArchive</a>, <a href="#TVArchivator">TVArchivator</a>, as well as modular objects that store their data in the DB.</i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TConfig( TElem *Elements = NULL );</i> — Initializing constructor.</li>
<li> <i>TConfig( const TConfig &amp;src );</i> — Copying constructor.</li>
<li> <i>TConfig &amp;operator=( const TConfig &amp;cfg ); TConfig &amp;exclCopy( const TConfig &amp;cfg, const string &amp;passCpLs = "", bool cpElsToSingle = false );</i> — Copying from <i>cfg</i>, passing fields into <i>passCpLs</i> and creating same this fields <i>cpElsToSingle</i> for combined configurations.</li>
<li> <i>void cfgList( vector&lt;string&gt; &amp;list ) const;</i> — Elements' list <i>list</i>.</li>
<li> <i>bool cfgPresent( const string &amp;n_val ) const;</i> — Check for the element's presence <i>n_val</i>.</li>
<li> <i>TCfg &amp;cfg( const string &amp;n_val ) const;</i> — Getting of th element <i>n_val</i>.</li>
<li> <i>TCfg *at( const string &amp;n_val, bool noExpt = false ) const;</i> — Getting of the element's pointer <i>n_val</i>. If the element is absent an exception is generated or the null pointer is returned when setting <i>noExpt</i>.</li>
<li> <i>void cfgViewAll( bool val = true );</i> — Set/unset the sign of the visibility for all the elements.</li>
<li> <i>void cfgKeyUseAll( bool val );</i> — Set/unset the sign of the using the key for all the elements.</li>
<li> <i>void cfgToDefault( );</i> — Setting all not key and view fields to the default value.</li>
<li> <i>TElem &amp;elem( );</i> — The using structure.</li>
<li> <i>void setElem( TElem *Elements, bool first = false );</i> — Setting the structure in <i>Elements</i>.</li>
<li> <i>void cntrCmdMake( XMLNode *fld, const string &amp;path, int pos, const string &amp;user = "root", const string &amp;grp = "root", int perm = 0664 );</i> — Formation of the information description of elements of the configuration for the management interface of OpenSCADA.</li>
<li> <i>void cntrCmdProc( XMLNode *fld, const string &amp;elem, const string &amp;user = "root", const string &amp;grp = "root", int perm = 0664 );</i> — Requests' of the OpenSCADA management interface to the elements of the configuration processing.</li>
<li> <i>bool incomplTblStruct( );</i> — The DB struct incomplete flag.</li>
<li> <i>void setIncmplTblStrct( bool vl );</i> — Setting the DB struct incomplete flag to <i>vl</i>.</li>
<li> <i>bool reqKeys( );</i> — The sign "Requests key", mark for using the request keys by the group items.</li>
<li> <i>bool trcSet( ) const;</i> — The setting elements tracing.</li>
<li> <i>void setTrcSet( bool vl );</i> — Setting the setting elements tracing, at setting TRUE all marks of the items setting are cleared.</li>
<li> <i>bool noTransl( ) const;</i> — The sign "No translation" is provided to disable the translation of all text variables of the record by default.</li>
<li> <i>void setNoTransl( bool vl );</i> — Setting of the sign "No translation".</li>
<li> <i>TVariant objFunc( const string &amp;id, vector&lt;TVariant&gt; &amp;prms, const string &amp;user_lang, int perm, const string &amp;owner );</i> — User API object functions of accessing to the configuration with the permition control.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>virtual bool cfgChange( TCfg &amp;co, const TVariant &amp;pc );</i> — Is called in the case of changing the contents of the configuration element.</li></ul>
<h3><span class="mw-headline" id="Data_cell_.28TCfg.29"><span class="mw-headline-number">13.3</span> <span id="TCfg" title="#TCfg">Data cell (TCfg)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherits:</b></td>
<td><i><a href="#TVariant">TVariant</a></i>
</td></tr></table>
<p><b>Data:</b><br />
Additional flags to <i>TFld</i> (enum — TCfg::AttrFlg):
</p>
<ul><li> <i>TCfg::NoVal(0x100)</i> — Do not reflect an element on the value of the TValue object.</li>
<li> <i>TCfg::Key(0x200)</i> — key field.</li>
<li> <i>TCfg::Hide(0x400)</i> — attribute is hidden.</li></ul>
<p>Requests flags (enum — ReqFlg):
</p>
<ul><li> <i>TFld::ForceUse(0x01)</i> — Forcing the setting of the flag of the element's using during the setting of its value.</li>
<li> <i>TFld::ExtValOne (0x02)</i> — One/first (and default) value: set value for key.</li>
<li> <i>TFld::ExtValTwo (0x04)</i> — Two/second value: base value for the key request or set.</li>
<li> <i>TFld::ExtValThree (0x08)</i> — Three value: source address for translations.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TCfg( TFld &amp;fld, TConfig &amp;owner );</i> — Initializing constructor.</li>
<li> <i>TCfg( const TCfg &amp;cfg );</i> — Copy constructor.</li>
<li> <i>const string &amp;name( );</i> — Cell name.</li>
<li> <i>bool operator==( TCfg &amp;cfg );</i> — Comparison of the cells.</li>
<li> <i>TCfg &amp;operator=( const TCfg &amp;cfg );</i> — Copying of the cells.</li>
<li> <i>bool view( ) const;</i> — The sign - "Cell is visible".</li>
<li> <i>bool keyUse( ) const;</i> — The sign - "Use the key" for the dataSeek() and dataDel() requests.</li>
<li> <i>bool noTransl( ) const;</i> — The sign "No translation" is provided to disable the translation of text variables for the record.</li>
<li> <i>bool reqKey( ) const;</i> — The sign "Requests key", for group operations produce by the field as key.</li>
<li> <i>bool isKey( ) const;</i> — Common sign of the field as key, depends from mode "Requests key" for the group.</li>
<li> <i>bool extVal( ) const;</i> — The sign "Extended value", for mark the field to misc role for search and update the key value and translation.</li>
<li> <i>bool isSet( ) const;</i> — The setting element sign.</li>
<li> <i>void setView( bool vw );</i> — Setting of the sign "The cell is visible" в <i>vw</i>.</li>
<li> <i>void setKeyUse( bool vl );</i> — Setting of the sign "Use the key" in <i>vl</i>.</li>
<li> <i>void setNoTransl( bool vl );</i> — Setting of the sign "No translation".</li>
<li> <i>void setReqKey( bool vl, bool treatDep = true );</i> — Setting of the sign "Requests key", treating the dependencies by <i>treatDep</i>.</li>
<li> <i>void setExtVal( bool vw );</i> — Setting of the sign "Extended value".</li>
<li> <i>void setIsSet( bool vl );</i> — Setting the setting element sign.</li>
<li> <i>void toDefault( bool notSetType = false );</i> — Setting the field value to the default one, and without setting the field type at <i>notSetType</i>.</li>
<li> <i>TFld &amp;fld( ) const;</i> —  Configuration of the cell.</li>
<li> <i>string getSEL( );</i> — Get the value of the selectable type.</li>
<li> <i>string getS( ) const; string getS( uint8_t RqFlg );</i> — Get the value of the string type with the request flags <i>RqFlg</i>.</li>
<li> <i>const char *getSd( );</i> — Get the direct access to the string type value.</li>
<li> <i>double &amp;getRd( );</i> — Get the direct access to the real type value.</li>
<li> <i>int64_t &amp;getId( );</i> — Get the direct access to the integer type value.</li>
<li> <i>char &amp;getBd( );</i> — Get the direct access to the boolean type value.</li>
<li> <i>void setSEL( const string &amp;val, uint8_t RqFlg = 0 );</i> — Set the value of the selectable type to the <i>val</i> with the request flags <i>RqFlg</i>.</li>
<li> <i>void setS( const string &amp;val ); TCfg &amp;operator=( const string &amp;vl ); TCfg &amp;operator=( const char *vl ); void setS( const string &amp;val, uint8_t RqFlg );</i> — Set the value of the string type to the <i>val</i> with the request flags <i>RqFlg</i>.</li>
<li> <i>void setR( double val ); TCfg &amp;operator=( double vl ); void setR( double val, uint8_t RqFlg );</i> — Set the value of the real type to the <i>val</i> with the request flags <i>RqFlg</i>.</li>
<li> <i>void setI( int64_t val ); TCfg &amp;operator=( int64_t vl ); void setI( int64_t val, uint8_t RqFlg );</i> — Set the value of the integer type to the <i>val</i> with the request flags <i>RqFlg</i>.</li>
<li> <i>void setB( char val ); TCfg &amp;operator=( bool vl ); void setB( char val, uint8_t RqFlg );</i> — Set the value of the boolean type to the <i>val</i> with the request flags <i>RqFlg</i>.</li>
<li> <i>TConfig &amp;owner( ) const;</i> — The object of container-owner.</li></ul>
<h3><span class="mw-headline" id="Data_structure_object_.28TElem.29"><span class="mw-headline-number">13.4</span> <span id="TElem" title="#TElem">Data structure object (TElem)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherited:</b></td>
<td> By the <i><a href="#TTypeParam">TTypeParam</a>, <a href="#TControllerS">TControllerS</a>, <a href="#TTypeDAQ">TTypeDAQ</a></i>, as well as by the modular objects, combining the functions of the structure storage .
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TElem( const string &amp;name = "" );</i> — Initialization of the structure with the specified name <i>name</i>.</li>
<li> <i>TElem( const TElem &amp;src );</i> — Copying constructor.</li>
<li> <i>TElem &amp;operator=( const TElem &amp;src );</i> — Copying from <i>src</i>.</li>
<li> <i>string &amp;elName( );</i> — The name if the structure.</li>
<li> <i>void fldList( vector&lt;string&gt; &amp;list );</i> — The cell's list in the structure <i>list</i>.</li>
<li> <i>unsigned fldSize( ) const;</i> — The number of cells in the structure.</li>
<li> <i>unsigned fldId( const string &amp;name, bool noex = false );</i> — Getting the index of the cell from its identifier <i>name</i>. Set <i>noex</i> on no the cell present caused return overall cells number, without exception generation.</li>
<li> <i>bool fldPresent( const string &amp;name );</i> — Check for the presence of the specified cell <i>name</i>.</li>
<li> <i>int fldAdd( TFld *fld, int id = -1 );</i> — Addition/insert of the cell <i>fld</i> to the position <i>id</i> (-1 — insert to the end).</li>
<li> <i>void fldDel( unsigned int id );</i> — Deleting of the cell  <i>id</i>.</li>
<li> <i>TFld &amp;fldAt( unsigned int id ) const;</i> — Getting of the cell <i>id</i>.</li>
<li> <i>void fldClear( );</i> — Removing all cells.</li>
<li> <i>void valAtt( TValElem *cnt );</i> — Is called automatically when the structure is attached to the data storage <i>cnt</i>.</li>
<li> <i>void valDet( TValElem *cnt );</i> — Is called automatically when the structure is detached from the data storage <i>cnt</i>.</li>
<li> <i>ResMtx &amp;resEl( );</i> — Mutex for access to containers of the fields.</li></ul>
<h3><span class="mw-headline" id="Data_structure_cell_.28TFld.29"><span class="mw-headline-number">13.5</span> <span id="TFld" title="#TFld">Data structure cell (TFld)</span></span></h3>
<p><b>Data:</b><br />
Cell's type (enum – TFld::Type):
</p>
<ul><li> <i>TFld::Boolean</i>(0) — boolean type;</li>
<li> <i>TFld::Integer</i>(1) — integer type;</li>
<li> <i>TFld::Real</i>(4) — real type;</li>
<li> <i>TFld::String</i>(5) — string type;</li>
<li> <i>TFld::Object</i>(6) — object type.</li>
<li> <i>TFld::GenMask</i>(0x0F) — generic types mask;</li>
<li> <i>TFld::Int16</i>(0x11) — signed integer 16 bits;</li>
<li> <i>TFld::Int32</i>(0x01) — signed integer 32 bits;</li>
<li> <i>TFld::Int64</i>(0x21) — signed integer 64 bits;</li>
<li> <i>TFld::Float</i>(0x14) — float (4 bytes);</li>
<li> <i>TFld::Double</i>(0x04) — double (8 bytes).</li></ul>
<p>Cell's flags (enum — TFld::AttrFlg):
</p>
<ul><li> <i>TFld::NoFlag</i>(0x00) — No flags;</li>
<li> <i>TFld::Selectable</i>(0x01) — selection mode from the available values, the selectable type;</li>
<li> <i>TFld::SelfFld</i>(0x02) — To create the own copy of this cell;</li>
<li> <i>TFld::NoWrite</i>(0x04) — unwritable;</li>
<li> <i>TFld::HexDec</i>(0x08) — integer type: hexadecimal notation;</li>
<li> <i>TFld::OctDec</i>(0x10) —  integer type: octal notation;</li>
<li> <i>TFld::DateTimeDec</i>(0x20) — integer type: содержит дату в UTC;</li>
<li> <i>TFld::FullText</i>(0x08) — Full-text, multi-string mode of the text type;</li>
<li> <i>TFld::TransltText(0x10)</i> — Translate the text variables of the record.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TFld( );</i> — Initialization by default.</li>
<li> <i>TFld( const TFld &amp;ifld, const char *name = NULL );</i> — Copying constructor, with possibility for individual <i>name</i> set.</li>
<li> <i>TFld( const char *name, const string &amp;descr, Type type, unsigned char flg, const char *valLen = "", const char *valDef = "", const char *vals = "", const char *nSel = "", const char *res = "" );</i> —  Initialization with the specified configuration.</li>
<li> <i>TFld &amp;operator=( const TFld &amp;fld );</i> — Copy of the cell from <i>fld</i>.</li>
<li> <i>const string &amp;name( ) const;</i> — Cell's name.</li>
<li> <i>string descr( ) const;</i> — Cell's description.</li>
<li> <i>string lenS( ) const;</i> — Combined string variant of the length field in the form "{len}.{dec}".</li>
<li> <i>int len( ) const;</i> — Size of the cell's value (symbols in symbolic representation).</li>
<li> <i>int dec( ) const;</i> — Size of the fractional part of a real (symbols in symbolic representation).</li>
<li> <i>Type type( ) const;</i> — Cell's type.</li>
<li> <i>static Type type(IO::Type tp);</i> — Cell's type from IO::Type type.</li>
<li> <i>IO::Type typeIO( ) const;</i> — Cell's type in IO::Type.</li>
<li> <i>unsigned flg( ) const;</i> — Cell's flag.</li>
<li> <i>const string &amp;def( ) const;</i> — Default value.</li>
<li> <i>string values( ) const;</i> — Working range of the value or a list of possible values for the selectable type (as — "vl1;vl2;vl3").</li>
<li> <i>string selNames( ) const;</i> — List of names of values for the selectable type (as — "Value 1;Value 2;Value 3").</li>
<li> <i>const string &amp;reserve( ) const;</i> — Reserve parameter.</li>
<li> <i>void setDescr( const string &amp;dscr );</i> — Set the descrition to the <i>dscr</i>.</li>
<li> <i>void setLen( int vl );</i> — Set the cell's size to the <i>vl</i>.</li>
<li> <i>void setDec( int vl );</i> — Set the fraction part of the real to the <i>vl</i>.</li>
<li> <i>void setDef( const string &amp;def );</i> — Set the default value to the <i>def</i>.</li>
<li> <i>void setFlg( unsigned flg );</i> — Set the flags to <i>flg</i>.</li>
<li> <i>void setValues( const string &amp;vls );</i> — Set the working range of value or the list of possible values for the selectable type (as — "vl1;vl2;vl3") to the <i>vls</i>.</li>
<li> <i>void setSelNames( const string &amp;slnms );</i> — Set the list of values' names for the selectable type (as — "Value 1;Value 2;Value 3") to the <i>slnms</i>.</li>
<li> <i>void setReserve( const string &amp;ires );</i> — Set of the reserve parameter to <i>res</i>.</li>
<li> <i>const vector&lt;string&gt; &amp;selValS() const;</i> — List of values' variants for the string type.</li>
<li> <i>const vector&lt;int&gt;    &amp;selValI() const;</i> — List of values' variants for the integer type.</li>
<li> <i>const vector&lt;double&gt; &amp;selValR() const;</i> — List of values' variants for the real type</li>
<li> <i>const vector&lt;bool&gt;   &amp;selValB() const;</i> — List of values' variants for the boolean type</li>
<li> <i>const vector&lt;string&gt; &amp;selNm() const;</i> — List of the names of values' variants.</li>
<li> <i>string selVl2Nm( const string &amp;val );</i> — Get the selectable name from the value <i>val</i> of the string type.</li>
<li> <i>string selVl2Nm( int64_t val );</i> — Get the selectable name from the value <i>val</i> of the integer type.</li>
<li> <i>string selVl2Nm( double val );</i> — Get the selectable name from the value <i>val</i> of the real type.</li>
<li> <i>string selVl2Nm( bool val ); string selVl2Nm( char val );</i> — Get the selectable name from the value <i>val</i>of the Boolean type.</li>
<li> <i>string selNm2VlS( const string &amp;name );</i> — Get the value of string type from the selectable name <i>name</i>.</li>
<li> <i>int64_t selNm2VlI( const string &amp;name );</i> — Get the value of integer type from the selectable name <i>name</i>.</li>
<li> <i>double selNm2VlR( const string &amp;name );</i> — Get the value of real type from the selectable name <i>name</i>.</li>
<li> <i>bool selNm2VlB( const string &amp;name );</i> — Get the value of boolean type from the selectable name <i>name</i>.</li>
<li> <i>XMLNode *cntrCmdMake( XMLNode *opt, const string &amp;path, int pos, const string &amp;user = "root", const string &amp;grp = "root", int perm = 0664 );</i> — Create a form element in accordance with the parameters of the cell.</li></ul>
<h3><span class="mw-headline" id="The_object_which_preacts_about_changing_of_the_structure_.28TValElem.29"><span class="mw-headline-number">13.6</span> <span id="TValElem" title="#TValElem">The object which preacts about changing of the structure (TValElem)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherited:</b></td>
<td><i><a href="#TValue">TValue</a>, <a href="#TConfig">TConfig</a></i>
</td></tr></table>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>virtual void detElem( TElem *el );</i> — Notification by the element <i>el</i> of the container about it's wish to detach.</li>
<li> <i>virtual void addFld( TElem *el, unsigned id ) = 0;</i> — Notification about the addition of the cell <i>id</i> of the element <i>el</i>.</li>
<li> <i>virtual void delFld( TElem *el, unsigned id ) = 0;</i> — Notification about the deleting of the cell <i>id</i> of the element <i>el</i>.</li></ul>
<h3><span class="mw-headline" id="Data_cell_.28TVariant.29"><span class="mw-headline-number">13.7</span> <span id="TVariant" title="#TVariant">Data cell (TVariant)</span></span></h3>
<p><b>Data:</b><br />
Error values for the different data types (definition):
</p>
<ul><li> <i>EVAL_BOOL</i> — Error value of the boolean type (2);</li>
<li> <i>EVAL_INT</i> — Error value of the integer type (-2147483647);</li>
<li> <i>EVAL_REAL</i> — Error value of the real type (-3.3E308);</li>
<li> <i>EVAL_STR</i> — Error value of the string type ("&lt;EVAL&gt;").</li>
<li> <i>EVAL_INT16</i> — Error value of the integer 16 type (-32767);</li>
<li> <i>EVAL_INT32</i> — Error value of the integer 32 type (-2147483647);</li>
<li> <i>EVAL_INT64</i> — Error value of the integer 64 type (-9223372036854775807ll);</li>
<li> <i>EVAL_RFlt</i> — Error value of the real type Float (-3.29E38f);</li>
<li> <i>EVAL_RDbl</i> — Error value of the real type Double (-1.79E308).</li></ul>
<p>Типы данных (enum — TVariant::Type):
</p>
<ul><li> <i>TVariant::Null</i> — data type and data is not set.</li>
<li> <i>TVariant::Boolean</i> — boolean type (boolean, 8бит).</li>
<li> <i>TVariant::Integer</i> — integer type (integer, 32бит).</li>
<li> <i>TVariant::Real</i> — real type (double).</li>
<li> <i>TVariant::String</i> — string.</li>
<li> <i>TVariant::Object</i> — object.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TVariant( );</i> — Default constructor.</li>
<li> <i>TVariant( char ivl ); TVariant( bool ivl );</i> — Boolean type constructor.</li>
<li> <i>TVariant( int64_t ivl ); TVariant( int ivl );</i> — Integer type constructor.</li>
<li> <i>TVariant( double ivl );</i> — Real type constructor.</li>
<li> <i>TVariant( string ivl );</i> — String type constructor.</li>
<li> <i>TVariant( const char *var );</i> — String type constructor.</li>
<li> <i>TVariant( AutoHD&lt;TVarObj&gt; ivl ); TVariant( TVarObj *ivl );</i> — Object constructor.</li>
<li> <i>TVariant( const TVariant &amp;var );</i> — Copying constructor.</li>
<li> <i>bool operator==( const TVariant &amp;vr ) const;</i> — Check the object for equality.</li>
<li> <i>bool operator!=( const TVariant &amp;vr ) const;</i> — Check the object for not equality.</li>
<li> <i>TVariant &amp;operator=( const TVariant &amp;vr );</i> — Copy of the object.</li>
<li> <i>bool isNull( ) const;</i> — Signs that the object is not initiated.</li>
<li> <i>bool isEVal( ) const;</i> — Value into the object is error.</li>
<li> <i>Type type( ) const;</i> — Value's type.</li>
<li> <i>void setType( Type tp, bool fix = false, bool stdStringOmit = false );</i> — Set type <i>tp</i> for fixing it <i>fix</i> and use as constant allow <i>stdStringOmit</i>.</li>
<li> <i>bool isModify( );</i> — Modification flag. It serves in the object functions to indicate the modification of variables.</li>
<li> <i>void setModify( bool vl = true );</i> — Set of the modification flag.</li>
<li> <i>virtual char getB( ) const; operator char( );</i> — Getting the value as the boolean one.</li>
<li> <i>virtual int64_t getI( ) const; operator int64_t( ); operator int( );</i> — Getting the value as the integer one.</li>
<li> <i>virtual double getR( ) const; operator double( );</i> — Getting the value as the real one.</li>
<li> <i>virtual string getS( ) const; operator string( );</i> — Getting the value as the string one.</li>
<li> <i>virtual AutoHD&lt;TVarObj&gt; getO( ) const; operator AutoHD&lt;TVarObj&gt;( );</i> — Getting the object.</li>
<li> <i>virtual void setB( char val );</i> — Set to the value the boolean one.</li>
<li> <i>virtual void setI( int64_t val );</i> — Set to the value the integer one.</li>
<li> <i>virtual void setR( double val );</i> — Set to the value the real one.</li>
<li> <i>virtual void setS( const string &amp;val );</i> — Set to the value the string one.</li>
<li> <i>virtual void setO( AutoHD&lt;TVarObj&gt; val );</i> — Set the object.</li></ul>
<h3><span class="mw-headline" id="User_object_.28TVarObj.29"><span class="mw-headline-number">13.8</span> <span id="TVarObj" title="#TVarObj">User object (TVarObj)</span></span></h3>
<table class="wikitable">

<tr>
<td><b>Inherited:</b></td>
<td><i><a href="#TArrayObj">TArrayObj</a></i>
</td></tr></table>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TVarObj( );</i> — Constructor.</li>
<li> <i>int connect( );</i> — Connection to the object.</li>
<li> <i>int disconnect( );</i> — Disconnection from the object.</li>
<li> <i>virtual void propList( vector&lt;string&gt; &amp;ls );</i> — Object's properties list <i>ls</i>.</li>
<li> <i>virtual TVariant propGet( const string &amp;id );</i> — Request of the object property with an ID <i>id</i>.</li>
<li> <i>TVariant propGet( const string &amp;ids, char sep );</i> — Request of the object hierarchical property with a path <i>ids</i> and separator <i>sep</i>.</li>
<li> <i>virtual void propSet( const string &amp;id, TVariant val );</i> — Set the object property with an ID <i>id</i> to the value <i>val</i>.</li>
<li> <i>void propSet( const string &amp;ids, char sep, TVariant val );</i> — Set the object hierarchical property with a path <i>ids</i> and separator <i>sep</i> to the value <i>val</i>.</li>
<li> <i>void propClear( const string &amp;ids = "" );</i> — Property <i>ids</i> clear or all properties clear for empty <i>ids</i>.</li>
<li> <i>virtual string getStrXML( const string &amp;oid = "" );</i> — Conversion of the contents of the object in the XML flow.</li>
<li> <i>static AutoHD&lt;TVarObj&gt; parseStrXML( const string &amp;str, XMLNode *nd = NULL, AutoHD&lt;TVarObj&gt; prev = NULL );</i> — Backward serialization for XML-stream to object.</li>
<li> <i>virtual TVariant funcCall( const string &amp;id, vector&lt;TVariant&gt; &amp;prms );</i> — Call of the object function with the ID <i>id</i> and with the parameters <i>prms</i>.</li></ul>
<h2><span class="mw-headline" id="Control_interface_of_OpenSCADA_and_the_dynamic_tree_of_the_control_nodes"><span class="mw-headline-number">14</span> <span id="CntrNode" title="#CntrNode">Control interface of OpenSCADA and the dynamic tree of the control nodes</span></span></h2>
<p>For complete coverage of the key components of the system by the network of the same structure objects the object of the dynamic tree node TCntrNode is provided. This objects provides the following functions:
</p>
<ul><li> providing of the uniform access to system components, including the blocks of the dynamic access;</li>
<li> building the distributed control interface.</li></ul>
<p>Any object that has the need to provide dynamic access to itself or its components must be inherited from the object of the dynamic tree node TCntrNode. This relationship is automatically includes the node into the dynamic tree of objects covered by both: the direct and the reverse links, and also provides an opportunity to create containers for its own child nodes. In addition to this node is able to preact the inclusion and exclusion/remove of the node from the tree with the possibility of reject from the exclusion/removal.
</p><p>The control interface of the system is included into the TCntrNode object and, accordingly, covers all the nodes of the dynamic tree of the system, allowing you to consistently manage the system regardless of the client tool used. The control interface of the system is based on the markup language XML. You can think of many ways to use control interface of system, as an example, we'll note the following most meaningful solutions:
</p>
<ul><li> Web interface of the configuration&nbsp;;</li>
<li> GUI configuration interface (QT, GTK+, ...);</li>
<li> reflection of the configuration in the network for distributed management of multiple OpenSCADA-stations from the single management area;</li>
<li> using as the protocol for objects' data access from the network;</li>
<li> provision of service functions to access of the exterior application and the single OpenSCADA components to the internal data.</li></ul>
<p>The control interface of the system is implemented by the following components:
</p>
<ul><li> information structure of the user configuration page;</li>
<li> dynamic part in the form of requests for getting, modification of data and service requests;</li>
<li> container or group of the above elements.</li></ul>
<p>Information hierarchical structure contains information about public control elements and can be used to build custom dialogs for the node's control of the system.
</p><p>The dynamic part contains the scripts of requests' to the control elements service which are described in the information structure; as well as hidden control elements in the form of service functions used for unified access to the node.
</p><p>The container can also gather into the single request several information structures and dynamic parts, thereby optimizing the time of the request especially on the high latency network interfaces.
</p><p>Overall control interface is built from individual components of the dynamic tree. Hierarchical inheritance from the TCntrNode object allows to realize multi-level addition of the configuration of the control interface. General view of the dynamic node tree is shown in Fig. 8.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:802px;"><a class="image" href="http://oscada.org/wiki/File:Oscada_UserOM.png"><img class="thumbimage" height="360" src="files/800px-Oscada_UserOM.png" srcset="/wiki/images/6/67/Oscada_UserOM.png 1.5x, /wiki/images/6/67/Oscada_UserOM.png 2x" width="800" /></a>  <div class="thumbcaption"><div class="magnify"><a class="internal" href="http://oscada.org/wiki/File:Oscada_UserOM.png" title="Enlarge" /></div>Fig. 8. Example of a dynamic tree of the nodes in OpenSCADA.</div></div></div></div>
<p>System's nodes, containing data for the control interface of the system must also be connected to the dynamic tree of objects. 
</p><p>Connection of the node to the dynamic tree is done as follows:
</p>
<ul><li> inheritance of the <i>TCntrNode</i> object or its child;</li>
<li> information structure formation;</li>
<li> service of the requests to dynamic data.</li></ul>
<h3><span class="mw-headline" id="The_syntax_of_the_request_and_response_of_the_control_interface"><span class="mw-headline-number">14.1</span> The syntax of the request and response of the control interface</span></h3>
<p>Whole exchange with the control interface is done through the XML language. The internal exchange is done through the parsed structure of XML language (DOM), and external — through the transformation in the stream the characters of continuous XML-file and vice versa.
</p><p>Request is executed by sending a container with some parameters in the attributes. The result is placed in the resulting container with the changes in certain attributes of the root container. In general, the request container can be written as follows: <i>&lt;cmd path="/TreePath" user="user" force="1"/&gt;</i><br />
Where:
</p>
<dl><dd><i>cmd</i> — request command;</dd>
<dd><i>path</i> — path to the node or to the branch of the tree;</dd>
<dd><i>user</i> — user of the system on behalf  of which the request is sent;</dd>
<dd><i>force</i> — the sign: to execute the request without warning.</dd></dl>
<p>As the confirmation of the request's result it is set the result's attribute <i>rez</i> in values: 0-request succeeds, 1-warning (with the possibility of execution), 2-error. In the case of error and warning the messages are written in the text of the container and in the attribute <i>mcat</i> (message category): <i>&lt;cmd path = "/TreePath" user="user" force="1" rez="2" mcat="sub_DAQ/mod_BlockCalc&gt;; Unable to delete the node &lt;/cmd&gt;</i>
</p><p>Grouping request "CntrReqs" is processed at the API level of the node and does not require separate processing in the user code. In fact, into the tag "CntrReqs" may be placed any other requests with the possibility of hierarchical grouping by including of the internal tags "CntrReqs". The only attribute of this tag is an attribute <i>path</i>, which indicates the path to the node and is the basis for internal requests. 
</p>
<pre style="white-space: pre-wrap;">
&lt;CntrReqs path="/sub_DAQ/cntr_gate"&gt;
  &lt;get path="/%2fprm%2fcfg%2fNAME"/&gt;
  &lt;get path="/%2fprm%2fcfg%2fDESCR"/&gt;
  &lt;list path="/%2fserv%2fattr"/&gt;
&lt;/CntrReqs&gt;
</pre>
<h3><span class="mw-headline" id="Tag_of_the_information_structure_for_describing_the_groups_of_child_branches_of_the_page"><span class="mw-headline-number">14.2</span> Tag of the information structure for describing the groups of child branches of the page</span></h3>
<p>Each page can contain groups of child branches. For descriptions of groups of branches there is the tag "branches". Tag contains the description of groups of branches through embedded tags <i>grp</i>. The group tag can be accessed as for the "read" (visibility) and for modification (the execution of commands for adding and removing the elements of the group), hence the element of the triad of access may be:
</p>
<dl><dd><i>0</i> — there is no any access;</dd>
<dd><i>4</i> — there is an access only for reading;</dd>
<dd><i>2</i> — there is only access fro the writing, usually this value has no meaning because the write access means access for reading;</dd>
<dd><i>6</i> — there is an access to read, and to write.</dd></dl>
<p>In the high octet it contains the maximum permition.
</p>
<pre style="white-space: pre-wrap;">
&lt;branches id='br'&gt;
  &lt;grp id='/br/in_' descr='Input transport' acs='52'/&gt;
  &lt;grp id='/br/out_' descr='Output transport' acs='52'/&gt;
&lt;/branches&gt;
</pre>
<p>Actions over the group of elements coincide with the actions over the list of visual elements "list", which is described below.
</p>
<h3><span class="mw-headline" id="Tags_of_the_description_of_the_information_structure_of_the_control_interface"><span class="mw-headline-number">14.3</span> Tags of the description of the information structure of the control interface</span></h3>
<p>Information tags for the XML form the alphabet of the formation of the description the configuration dialogs. Request command of the information part is: <i>&lt;info path="/TreePath" user="user"/&gt;</i>
</p><p>As the result of the request it will be received the information structure of the page in accordance with the privileges of the specified user.
</p>
<h4><span class="mw-headline" id="Area_tag_.22area.22"><span class="mw-headline-number">14.3.1</span> Area tag "area"</span></h4>
<p>Areas are described with "area" tag and are intended to group the elements on different features. Area may include other elements and areas. The root ones form the bookmarks in the presentation of the user interface. To tag, you can access only to "read" or "visibility", hence the element of the triad of access can be set to 00, if access is absent, or 04, if it is present.
</p>
<pre style="white-space: pre-wrap;">
&lt;area id="base" dscr="Base information"&gt;
  &lt;fld id="host" dscr="Host name" tp="str"/&gt;
  &lt;fld id="user" dscr="Operated user" tp="str"/&gt;
  &lt;fld id="sys" dscr="Station system" tp="str"/&gt;
  &lt;area id="other" dscr="Other options"&gt;
     &lt;fld id="val" dscr="Value" tp="real"/&gt;
  &lt;/area&gt;
&lt;/area&gt;
</pre>
<h4><span class="mw-headline" id="Data_tags"><span class="mw-headline-number">14.3.2</span> Data tags</span></h4>
<p>Tags, which describe data, are shown in the table 1.
</p><p><b>Table 1.</b> Tags, which describe data
</p>
<table class="wikitable">

<tr>
<th> Tag </th>
<th> Description
</th></tr>
<tr>
<td>&lt;fld&gt;</td>
<td>The simplest data of the string, integer, real or boolean types.
</td></tr>
<tr>
<td>&lt;list&gt;</td>
<td>Lists with data of string, real and boolean types.
</td></tr>
<tr>
<td>&lt;table&gt;</td>
<td>Tables with the data in cells of string, integer, real, boolean types.
</td></tr>
<tr>
<td>&lt;img&gt;</td>
<td>Images.
</td></tr></table>
<h5><span class="mw-headline" id="Tag_.22fld.22"><span class="mw-headline-number">14.3.2.1</span> Tag "fld"</span></h5>
<pre style="white-space: pre-wrap;">
&lt;fld id="host" dscr="Host name" tp="str"/&gt;
&lt;fld id="user" dscr="Operated user" tp="str"/&gt;
&lt;fld id="sys" dscr="Station system" tp="str"/&gt;
</pre>
<p>The tag can be accessed as to "read" and also to "write", therefore an element of the triad of access may be: 
</p>
<dl><dd><i>00</i> — there is no any access;</dd>
<dd><i>04</i> — there is an access only for reading;</dd>
<dd><i>02</i> — there is only access fro the writing, usually this value has no meaning because the write access means access for reading;</dd>
<dd><i>06</i> — there is an access to read, and to write.</dd></dl>
<p>Type of the element, discribed by the "fld" tag, is specified by the <i>tp</i> attribute (table 2).
</p><p><b>Table 2.</b> Attribute's <i>tp</i> values of the "fld" tag.
</p>
<table class="wikitable">

<tr>
<th> Tag <i>tp</i> </th>
<th> Description
</th></tr>
<tr>
<td>str</td>
<td>String type.<br />
<p><i>&lt;fld id="host" dscr="Host name" tp="str"/&gt;</i>
</p>
</td></tr>
<tr>
<td>dec</td>
<td>Integer in decimal representation. <br />
<p><i>&lt;fld id="debug" dscr="Debug level" tp="dec"/&gt;</i>
</p>
</td></tr>
<tr>
<td>oct</td>
<td>Integer in octal representation. <br />
<p><i>&lt;fld id="cr_file_perm" dscr="Make files permissions(default 0644)" tp="oct" len="3"/&gt;</i>
</p>
</td></tr>
<tr>
<td>hex</td>
<td>Integer in hexadecimal representation.
</td></tr>
<tr>
<td>real</td>
<td>Real value.
</td></tr>
<tr>
<td>bool</td>
<td>Boolean sign ("false"|"true"). <br />
<p><i>&lt;fld id="log_sysl" dscr="Direct messages to syslog" tp="bool"/&gt;</i>
</p>
</td></tr>
<tr>
<td>time</td>
<td>Time in seconds (from 01/01/1970). <br />
<p><i>&lt;fld id="v_beg" dscr="Start time" tp="time"/&gt;</i>
</p>
</td></tr></table>
<p><b>Table 3.</b> Actions over the element, described by the "fld" tag.
</p>
<table class="wikitable">

<tr>
<th> Operation </th>
<th> Action
</th></tr>
<tr>
<td>Interrogation</td>
<td>
<p><i>Request:</i> command "get": <i>&lt;get path="/fld_teg" user="user"/&gt;</i>.<br />
<i>Result:</i> confirmation with the value in the text of the tag or an error message.
</p>
</td></tr>
<tr>
<td>Modification</td>
<td>
<p><i>Request:</i> command "set": <i>&lt;set path="/fld_teg" user="user"&gt;value&lt;/set&gt;</i><br />
<i>Result:</i> confirmation or an error message.
</p>
</td></tr>
<tr>
<td>Request for the rules of syntax highlight, for text fields (the attribute "rows" set).</td>
<td>
<p><i>Request:</i> <span id="SnthHgl" title="#SnthHgl">command "SnthHgl"</span>: <i>&lt;SnthHgl path="/fld_teg" user="user"/&gt;</i><br />
<i>Result:</i> confirmation with the rules of syntax highlight list:
</p>
<pre style="white-space: pre-wrap;">
&lt;rule expr="\b(if|else|for|while|in|using|new|var|break|continue|return|Array|Object)\b" color="darkblue" font_weight="1"/&gt;
&lt;rule expr="(\?|\:)" color="darkblue" font_weight="1"/&gt;
&lt;rule expr="(\b0[xX][0-9a-fA-F]*\b|\b[+-]?[0-9]*\.?[0-9]+[eE]?[-+]?[0-9]*\b|\btrue\b|\bfalse\b)" color="blue"/&gt;
&lt;rule expr=""[^"]*"" color="darkgreen"/&gt;
&lt;rule expr="//[^\n]*" color="gray" font_italic="1"/&gt;
&lt;blk beg="/\\*" end="\\*/" color="gray" font_italic="1"/&gt;
</pre>
</td></tr></table>
<h5><span class="mw-headline" id="Tag_.22list.22"><span class="mw-headline-number">14.3.2.2</span> Tag "list"</span></h5>
<pre style="white-space: pre-wrap;">
&lt;list id="mod_auto" dscr="List of shared libs(modules)" tp="str" dest="file"/&gt;
</pre>
<p>The tag can be accessed as to "read" and also to "write"(modification), therefore an element of the triad of access may be: 
</p>
<dl><dd><i>00</i> — there is no any access;</dd>
<dd><i>04</i> — there is an access only for reading;</dd>
<dd><i>02</i> — there is only access fro the writing, usually this value has no meaning because the write access means access for reading;</dd>
<dd><i>06</i> — there is an access to read, and to write.</dd></dl>
<p>Type of the elements in the list is specified by the attribute <i>tp</i>. <i>tp</i> attribute's values are given in Table 1.
</p><p><b>Table 4.</b> Actions over the list.
</p>
<table class="wikitable">

<tr>
<th> Operation </th>
<th> Action
</th></tr>
<tr>
<td>Interrogation</td>
<td>
<p><i>Request:</i> command "get": <i>&lt;get path="/fld_teg" user="user"/&gt;</i><br />
<i>Result:</i> confirmation with the result in the tag's text or an error message. The result is formed in the form:
</p>
<dl><dd>&lt;get path="/fld_teg" user="user" rez="0"&gt; 
<dl><dd>&lt;el id="0"&gt;./MODULES/arh_base.o&lt;/el&gt;</dd>
<dd>&lt;el id="1"&gt;./MODULES/cntr_sys.o&lt;/el&gt;</dd></dl></dd>
<dd>&lt;/get&gt;</dd></dl>
</td></tr>
<tr>
<td>String's addition</td>
<td>
<p><i>Request:</i> command "add": <i>&lt;add path="/fld_teg" user="user" id="tst"&gt;Test&lt;/add&gt;</i>
</p>
<dl><dd>To add the string with ID "tst" and value "Test". If the list is not indexed, then the id attribute is absent.<br /></dd></dl>
<p><i>Result:</i> confirmation or an error message.
</p>
</td></tr>
<tr>
<td>Insert the string</td>
<td>
<p><i>Request:</i> command "ins": <i>&lt;ins path="/fld_teg" user="user" pos="3" p_id="tst1" id="tst"&gt;Test&lt;/ins&gt;</i>
</p>
<dl><dd>To insert the string with the ID "tst" and value "Test" in position 3 with the string "tst1". In the case of the index list p_id attribute contains the identifier, else — the text of the string. If the list is not indexed, then the ID attribute is absent.<br /></dd></dl>
<p><i>Result:</i> confirmation or an error message.
</p>
</td></tr>
<tr>
<td>Deleting of the string</td>
<td>
<p><i>Request:</i> command "del": <i>&lt;del path="/fld_teg" user="user" pos="3" id="tst"&gt;Test&lt;/del&gt;</i>
</p>
<dl><dd>To delete the string with ID "tst" and value "Test" from the position 3. If the list is not indexed, then the ID attribute is absent.<br /></dd></dl>
<p><i>Result:</i> confirmation or an error message.
</p>
</td></tr>
<tr>
<td>Edit of the string</td>
<td>
<p><i>Request::</i> command "edit": <i>&lt;edit path="/fld_teg" user="user" pos="3" p_id="tst1" id="tst" &gt;Test&lt;/edit&gt;</i>
</p>
<dl><dd>To replace the string at position 3 with the identifier "tst1" with the another string with the identifier "tst" and value "Test". In the case of the index list p_id attribute contains the identifier, else — the text of the string. If the list is not indexed, then the ID attribute is absent.<br /></dd></dl>
<p><i>Result:</i> confirmation or an error message.
</p>
</td></tr>
<tr>
<td>Mooving of the string</td>
<td>
<p><i>Request:</i> command "move": <i>&lt;move path="/fld_teg" user="user" pos="3" to="5"/&gt;</i>
</p>
<dl><dd>To move the string from position 3 to position 5.<br /></dd></dl>
<p><i>Result:</i> confirmation or an error message.
</p>
</td></tr></table>
<h5><span class="mw-headline" id="Tag_.22table.22"><span class="mw-headline-number">14.3.2.3</span> Tag "table"</span></h5>
<pre style="white-space: pre-wrap;">
&lt;table id="a_mess" key="0" col_lst="0;1;2"&gt;
  &lt;list id="0" dscr="Id" acs="36" tp="str"/&gt;
  &lt;list id="1" dscr="Name" acs="52" tp="str"/&gt;
  &lt;list id="2" dscr="Type" acs="52" tp="str"/&gt;
  &lt;list id="3" dscr="Hide" acs="52" tp="bool"/&gt;
&lt;/table&gt;
</pre>
<p>The tag of the table or single column can be accessed as to "read" and also to "write"(modification), therefore an element of the triad of access may be: 
</p>
<dl><dd><i>00</i> — there is no any access;</dd>
<dd><i>04</i> — there is an access only for reading;</dd>
<dd><i>02</i> — there is only access fro the writing, usually this value has no meaning because the write access means access for reading;</dd>
<dd><i>06</i> — there is an access to read, and to write.</dd></dl>
<p>If the attribute <i>key</i> is specified and it lists the key columns, the work with the table moves to the addressing mode by the identifiers for columns and keys.
</p><p><b>Table 5.</b> Actions over the table.
</p>
<table class="wikitable">

<tr>
<th> Operation </th>
<th> Action
</th></tr>
<tr>
<td>Interrogation</td>
<td>
<p><i>Request:</i> command "get": <i>&lt;get path="/fld_teg" user="user" cols="0;2" rows="100;1000"/&gt;</i>
</p>
<dl><dd>To get columns 0-2 and rows of them from 100 to 1000 table. <br /></dd></dl>
<p><i>Result:</i> Confirmation with the data of the table or an error message. The result is formed in the form:
</p>
<dl><dd>&lt;get path="/fld_teg" user="user" cols="0;2" rows="100;1000" rez="0"&gt; 
<dl><dd>&lt;list id="0" tp="str"&gt;
<dl><dd>&lt;el id="100"&gt;Sat Feb 21 18:04:16 2004&lt;/el&gt;    </dd></dl></dd>
<dd>&lt;/list&gt;</dd>
<dd>&lt;list id="1" tp="str"&gt;
<dl><dd>&lt;el id="100"&gt;SYS&lt;/el&gt;</dd></dl></dd>
<dd>&lt;/list&gt;</dd>
<dd>&lt;list id="2" tp="str"&gt;
<dl><dd>&lt;el id="100"&gt;*:(TSYS)Broken PIPE signal allow!&lt;/el&gt;</dd></dl></dd>
<dd>&lt;/list&gt;</dd></dl></dd>
<dd>&lt;/get&gt;</dd></dl>
</td></tr>
<tr>
<td> Adding of the row </td>
<td>
<p><i>Request:</i> command "add": <i>&lt;add path="/fld_teg" user="user"/&gt;</i><br />
<i>Result:</i> confirmation or an error message.
</p>
</td></tr>
<tr>
<td> Inserting of the row </td>
<td>
<p><i>Request:</i> command "ins": <i>&lt;ins path="/fld_teg" user="user" row="3"/&gt;</i>
</p>
<dl><dd>To insert the string in position 3. Command does not work when attribute <i>key</i> is set!<br /></dd></dl>
<p><i>Result:</i> confirmation or an error message.
</p>
</td></tr>
<tr>
<td> Deleting of the row </td>
<td>
<p><i>Request:</i> command "del": <i>&lt;del path="/fld_teg" user="user" row="3"/&gt;</i> or <i>&lt;del path="/fld_teg" user="user" key_id="Test"/&gt;</i> for the key mode
</p>
<dl><dd>To remove the string in position 3 or string in the position where the <i>id</i> column value is "Test".<br /></dd></dl>
<p><i>Result:</i> confirmation or an error message.
</p>
</td></tr>
<tr>
<td> Moving of the row </td>
<td>
<p><i>Request:</i> command "move": <i>&lt;move path="/fld_teg" user="user" row="3" to="5"/&gt;</i>
</p>
<dl><dd>To move the string from position 3 to position 5. Command does not work when attribute <i>key</i> is set!<br /></dd></dl>
<p><i>Result:</i> confirmation or an error message.
</p>
</td></tr>
<tr>
<td> User command of the row </td>
<td>
<p><i>Request:</i> command "{user}": <i>&lt;{user} path="/fld_teg" user="user" row="3"/&gt;</i> or <i>&lt;{user} path="/fld_teg" user="user" key_id="Test"/&gt;</i> for the key mode
</p>
<dl><dd>To send a <i>{user}</i> command for position 3 or string in the position where the <i>id</i> column value is "Test".<br /></dd></dl>
<p><i>Result:</i> confirmation or an error message.
</p>
</td></tr>
<tr>
<td> Changing of the row </td>
<td>
<p><i>Request:</i> command "set": <i>&lt;set path="/fld_teg" user="user" row="3" col="id"&gt;Test&lt;/set&gt;</i> or <i>&lt;set path="/fld_teg" user="user" key_id="Test" col="id"&gt;Test1&lt;/set&gt;</i> for the key mode
</p>
<dl><dd>To set the cell's value in row 3 and column "id" to "Test" or set of the column named "id" of the row to the position where the <i>id</i> column value is "Test" to value "Test1". Practically, this command renames a key element of the specified row.<br /></dd></dl>
<p><i>Result:</i> confirmation or an error message.
</p>
</td></tr></table>
<h5><span class="mw-headline" id="Tag_.22img.22"><span class="mw-headline-number">14.3.2.4</span> Tag "img"</span></h5>
<pre style="white-space: pre-wrap;">
&lt;img id="ico" descr="Page icon"/&gt;
</pre>
<p>The tag can be accessed as to "read" and also to "write"(modification), therefore an element of the triad of access may be: 
</p>
<dl><dd><i>00</i> — there is no any access;</dd>
<dd><i>04</i> — there is an access only for reading;</dd>
<dd><i>02</i> — there is only access fro the writing, usually this value has no meaning because the write access means access for reading;</dd>
<dd><i>06</i> — there is an access to read, and to write.</dd></dl>
<p>Tag is provided to transfer images to the clients of control interface. Under the image may be: pages' icons, graphics of the values' arrays and other data that can be presented in graphical form.
</p><p>The following requests' commands are supported:
</p>
<ul><li> <i>&lt;get path="/fld_teg" user="user"/&gt;</i> — image request;</li></ul>
<dl><dd>The result is the confirmation with image data or an error message.</dd></dl>
<ul><li> <i>&lt;set path="/fld_teg" user="user"&gt;img&lt;/set&gt;</i> — загрузка изображения.</li></ul>
<dl><dd>The result is the confirmation or error message.</dd></dl>
<h5><span class="mw-headline" id="Commands_with_the_parameters._Tag_.22comm.22"><span class="mw-headline-number">14.3.2.5</span> Commands with the parameters. Tag "comm"</span></h5>
<pre style="white-space: pre-wrap;">
&lt;comm id="add"&gt;
  &lt;fld id="tm" tp="time"/&gt;
  &lt;fld id="cat" tp="str"/&gt;
  &lt;fld id="lvl" tp="dec" min="0" max="7"/&gt;
  &lt;fld id="mess" tp="str"/&gt;
&lt;/comm&gt;
</pre>
<p>The tag can be accessed as to "read" or visibility + service of the requests, and for modification or execution of the command, hence an element of the triad of access can be set to 00, if access is absent at all; 04, if the command can be seen, and 06, if the command can be initiated.
</p><p>It is provided for transmission of commands and actions to the node, and also can be used to create links to other pages. Commands may include options. Parameters are described with "fld".
</p><p>The following request commands are supported:
</p>
<ul><li> Command execution:</li></ul>
<pre style="white-space: pre-wrap;">
&lt;set path="/fld_teg" user="user"/&gt;
  &lt;fld id="tm"&gt;1023456244&lt;/fld&gt;
  &lt;fld id="cat"&gt;*&lt;/fld&gt;
  &lt;fld id="lvl"&gt;2&lt;/fld&gt;
  &lt;fld id="mess"&gt;Test mess&lt;/fld&gt;
&lt;/set&gt;</pre>
<ul><li> Load the link to another page:</li></ul>
<pre style="white-space: pre-wrap;">
&lt;get path="/fld_teg" user="user" tp="lnk"/&gt;"</pre>
<p>The result is the confirmation or error message.
</p>
<h5><span class="mw-headline" id="Branches_.28child_nodes.29"><span class="mw-headline-number">14.3.2.6</span> Branches (child nodes)</span></h5>
<pre style="white-space: pre-wrap;">
&lt;list id="k_br" dscr="Kernel branches" tp="br"/&gt;
</pre>
<p>The branches are described by the usual list "list" with special attributes tp = "br". Methodology of the request and modification of branches coincides with the one of work with the list "list".
</p>
<h3><span class="mw-headline" id="Hierarchical_dependences_of_the_information_elements_of_the_control_language"><span class="mw-headline-number">14.4</span> Hierarchical dependences of the information elements of the control language</span></h3>
<p>Example of the node page of the control language:
</p>
<pre style="white-space: pre-wrap;">
&lt;oscada_cntr&gt;
  &lt;area id="a_gen" dscr="Generic control"&gt;
    &lt;fld id="config" dscr="Config file" tp="str" dest="file"/&gt;
    &lt;fld id="cr_file_perm" dscr="Files" tp="oct" len="3"/&gt;
    &lt;fld id="cr_dir_perm" dscr="Directories" tp="oct" len="3"/&gt;
    &lt;comm id="upd_opt" dscr="Update options(from config)"/&gt;
    &lt;comm id="quit" dscr="Quit"/&gt;
  &lt;/area&gt;
  &lt;area id="a_kern" dscr="Kernels"&gt;
    &lt;list id="k_br" dscr="Kernels" tp="br"/&gt;
  &lt;/area&gt;
&lt;/oscada_cntr&gt;
</pre>
<p><b>Table 6.</b> Hierarchical dependencies of the information elements of the language.
</p>
<table class="wikitable">

<tr>
<th> Tag </th>
<th> Description </th>
<th> Attributes </th>
<th> Contents
</th></tr>
<tr>
<td>oscada_cntr</td>
<td>The root element of the page. It is the only and serves to identify the origin of language of control interface.</td>
<td>
<p><i>id</i> — ID;<br />
<i>dscr</i> — description.
</p>
</td>
<td>area, img, branches
</td></tr>
<tr>
<td>branches</td>
<td>Container of the groups of child branches of the node.</td>
<td>
<p><i>id</i> — Container's ID. It is equal: <i>br</i>.||grp
</p>
</td></tr>
<tr>
<td>grp</td>
<td>The group of the child nodes.</td>
<td>
<p><i>id</i> — prefix of the group of child nodes in the system;<br />
<i>dscr</i> — description of the branches' group;<br />
<i>acs</i> — access options.
</p>
</td>
<td>
</td></tr>
<tr>
<td>area</td>
<td>Grouping of the standard tags.</td>
<td>
<p><i>id</i> — ID;<br />
<i>dscr</i> — description;<br />
<i>acs</i> — access options.
</p>
</td>
<td>area, fld, list, table, comm, img
</td></tr>
<tr>
<td>comm</td>
<td>Commands to the node.</td>
<td>
<p><i>id</i> — ID;<br />
<i>dscr</i> — description;<br />
<i>help</i> — command's help;<br />
<i>tp</i> — command's type (<i>lnk</i> — ссылка);<br />
<i>acs</i> — access options.
</p>
</td>
<td>fld
</td></tr>
<tr>
<td>fld</td>
<td>Description of the standard data types.</td>
<td>
<p><i>id</i> — ID;<br />
<i>dscr</i> — description;<br />
<i>help</i> — help;<br />
<i>acs</i> — access options.<br />
<i>tp</i> — element's type:
</p>
<dl><dd><i>str(len, dest, cols, rows(SnthHgl))</i> — string element;</dd>
<dd><i>dec(len, max, min, dest)</i> — integer in decimal representation;</dd>
<dd><i>oct(len, max, min, dest)</i> — integer in octal;</dd>
<dd><i>hex(len, max, min, dest)</i> — integer in hexadecimal;</dd>
<dd><i>real(len, max, min, dest)</i> — real number;</dd>
<dd><i>bool</i> — boolean sign;</dd>
<dd><i>time</i> — time/date in seconds (from 01/01/1970).<br /></dd></dl>
<p><b>Connected:</b><br />
<i>len</i> — value length (char.);<br />
<i>min</i> — minimum of value;<br />
<i>max</i> — maximum of value;<br />
<i>cols</i> — number of columns;<br />
<i>rows</i> — number of rows;<br />
<i>dest</i> — input method:
</p>
<dl><dd><i>data</i> — source of binary data (base64).</dd>
<dd><i>select(select)</i> — selective type;</dd>
<dd><i>sel_ed(select)</i> — selective type with the possibility of editing.<br /></dd></dl>
<p><i>select</i> — path to the hidden list;<br />
<i>sel_list</i> — static list (separator ';');<br />
<i>sel_id</i> — static list of the identifiers (separator ';').
</p>
</td>
<td>
</td></tr>
<tr>
<td>list</td>
<td>List of standard data types.</td>
<td>
<p><i>id</i> — ID;<br />
<i>dscr</i> — description;<br />
<i>help</i> — help list;<br />
<i>acs</i> — access options;<br />
<i>tp</i> — as in <i>fld</i> except:
</p>
<dl><dd><i>br(br_pref)</i> — child nodes.<br /></dd></dl>
<p><i>idm</i> — indexed list (0|1);<br />
<i>s_com</i> — ways of the list's modification [add][,ins][,edit][,del]:
</p>
<dl><dd><i>add</i> — add rows;</dd>
<dd><i>ins</i> — insert rows;</dd>
<dd><i>edit</i> — modify rows;</dd>
<dd><i>del</i> — delete rows.<br /></dd></dl>
<p><b>Connected:</b><br />
<i>br_pref</i> — child node's prefix;<br />
<i>dest</i> — as in <i>fld</i>.
</p>
</td>
<td>
</td></tr>
<tr>
<td>table</td>
<td>Table of standard data types.</td>
<td>
<p><i>id</i> — ID;<br />
<i>dscr</i> — description;<br />
<i>help</i> — table help;<br />
<i>acs</i> — access options;<br />
<i>key</i> — key columns (key="id,name,per");<br />
<i>cols</i> — list of columns in the request attribute;<br />
<i>rows</i> — range of rows in the attribute of the request;<br />
<i>s_com</i> — types of the table's modification [add][,del][,ins][,move][,{user}]:
</p>
<dl><dd><i>add[:{CustName}]</i> — add row, with the menu item custom name <i>CustName</i>;</dd>
<dd><i>ins[:{CustName}]</i> — insert row, with the menu item custom name <i>CustName</i>;</dd>
<dd><i>del[:{CustName}]</i> — delete row, with the menu item custom name <i>CustName</i>;</dd>
<dd><i>move</i> — move row;</dd>
<dd><i>{user}[:{name}]</i> — user command to row or in whole table with the menu item name <i>name</i>.</dd></dl>
</td>
<td>list
</td></tr>
<tr>
<td>img</td>
<td>Image.</td>
<td>
<p><i>id</i> — ID;<br />
<i>dscr</i> — description;<br />
<i>help</i> — image help;<br />
<i>acs</i> — access options;<br />
<i>h_sz</i> — horizontal limitation;<br />
<i>v_sz</i> — vertical limitation.
</p>
</td>
<td>
</td></tr></table>
<h3><span class="mw-headline" id="Object_of_the_dynamic_tree_node_.28TCntrNode.29"><span class="mw-headline-number">14.5</span> <span id="TCntrNode" title="#TCntrNode">Object of the dynamic tree node (TCntrNode)</span></span></h3>
<table class="wikitable">

<tr>
<td> <b>Inherited:</b> </td>
<td> By all the dynamic and controlled objects directly or through children.
</td></tr></table>
<p><b>Data:</b><br />
Named rights of access to control elements (definition):
</p>
<ul><li> <i>R_R_R_</i> (0444) — access to all read-only;</li>
<li> <i>R_R___</i> (0440) — read access only to the owner and group;</li>
<li> <i>R_____</i> (0400) — read access only to the owner;</li>
<li> <i>RWRWRW</i> (0666) — full access to all;</li>
<li> <i>RWRWR_</i> (0664) — full access to the owner and group, and for the rest — the read-only;</li>
<li> <i>RWR_R_</i> (0644) — full access to the owner and for the group and the rest — the read-only;</li>
<li> <i>RWR___</i> (0640) — full access to the owner, read-only — to the group and closed for the rest;</li>
<li> <i>RW____</i> (0600) — full access to the owner, but for the group and everyone else is closed.</li></ul>
<p>Dynamic node's flags (enum TCntrNode::Flag):
</p>
<ul><li> <i>TCntrNode::DoDisable</i> — switching-off (0);</li>
<li> <i>TCntrNode::Disabled</i> — disabled (1);</li>
<li> <i>TCntrNode::DoEnable</i> — switching-on (2);</li>
<li> <i>TCntrNode::Enabled</i> — enabled (3);</li>
<li> <i>TCntrNode::Modified</i> — sign of the Modified state (0x04);</li>
<li> <i>TCntrNode::ModifiedS</i> — sign of saving the Modified state at it setting just in the loading (0x08);</li>
<li> <i>TCntrNode::SaveForceOnChild</i> — sign of saving forcibly on children Modified flag set (0x10)</li>
<li> <i>TCntrNode::LoadForcibly</i> — sign of the node forcibly loading, then the errors suppression for not modified nodes before that operation (0x20).</li></ul>
<p>Flags of the enabling/disabling modes of the node (enum TCntrNode::EnDisFlag):
</p>
<ul><li> <i>TCntrNode::NodeNoFlg</i> (0) — no node flag;</li></ul>
<dl><dd> <i>Enable flags</i></dd></dl>
<ul><li> <i>TCntrNode::NodeConnect</i> (0x01) — connection of the node;</li>
<li> <i>TCntrNode::NodeRestore</i> (0x02) — restoration of the connection of the node;</li></ul>
<dl><dd> <i>Disable flags</i></dd></dl>
<ul><li> <i>TCntrNode::NodeRemove</i> (0x01) — node complete removing also from the storage;</li>
<li> <i>TCntrNode::NodeRemoveOnlyStor</i> (0x02) — node removing only from the storage;</li>
<li> <i>TCntrNode::NodeSpecific</i> (0x100) — reserved for the node specific &gt; 0x100.</li></ul>
<p>Modification of the node flags (enum TCntrNode::ModifFlag):
</p>
<ul><li> <i>TCntrNode::Self</i> — the given node is modified;</li>
<li> <i>TCntrNode::Child</i> — the child nodes are modified;</li>
<li> <i>TCntrNode::All</i> — the given node and the child ones are modified.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TCntrNode( TCntrNode *prev = NULL );</i> — Initialization with an indication of the parent node <i>prev</i>.</li>
<li> <i>virtual string objName( );</i> — Object name. Object-heir should extend the definition of aggregate object name.</li>
<li> <i>virtual TCntrNode &amp;operator=( const TCntrNode &amp;node );</i> — Virtual copy function of the dynamic tree nodes.</li>
<li> <i>void cntrCmd( XMLNode *opt, int lev = 0, const string &amp;path = "", int off = 0 );</i> — Command of work with the control interface of the system. The transport transitions to the full path of the following form are supported: "**/sub_Seсurity/usr_root/%2fgen**" где <i>%2fgen</i> — encoded sub-path to a particular field of the page (/gen).</li>
<li> <i>static XMLNode *ctrId( XMLNode *inf, const string &amp;n_id, bool noex = false );</i> — Getting the XML node by the attribute's value "id" <i>n_id</i>. XML requests of the node by the full path to it are supported (node1/node2/node3).</li>
<li> <i>static XMLNode *_ctrMkNode( const char *n_nd, XMLNode *nd, int pos, const char *req, const string &amp;dscr, int perm = 0777, const char *user = "root", const char *grp = "root" );</i></li></ul>
<dl><dd><i>static XMLNode *ctrMkNode( const char *n_nd, XMLNode *nd, int pos, const char *req, const string &amp;dscr int perm = 0777, const char *user = "root", const char *grp = "root", int n_attr = 0, ... );</i></dd>
<dd><i>static XMLNode *ctrMkNode2( const char *n_nd, XMLNode *nd, int pos, const char *req, const string &amp;dscr, int perm = 0777, const char *user = "root", const char *grp = "root", ... );</i> — Adding the control element to the page. It is possible to specify the set of additional attributes in the number of  <i>n_attr</i> as follows: "<b>{attribute1},{values1},{attribute2},{values2},...</b>" or by zero pointer at the end of the pair sequence.</dd></dl>
<ul><li> <i>bool ctrRemoveNode( XMLNode *nd, const char *path );</i> — Removing the control element <i>path</i> from the page <i>nd</i>.</li>
<li> <i>static bool ctrChkNode( XMLNode *nd, const char *cmd="get", int perm=0444, const char *user="root", const char *grp="root", char mode=04, const char *warn = NULL );</i> — Checking for the dynamic command getting <i>cmd</i> and for the existence of rights to its execution.</li>
<li> <i>ResMtx &amp;dataRes( );</i> — Mutex for using resources of the node in common purpose.</li>
<li> <i>virtual const char *nodeName( ) const;</i> — Node's name.</li>
<li> <i>virtual const char *nodeNameSYSM( ) const;</i> — System message's location entry name, to place it to the system's message text by function "mess_sys" and "err_sys". Empty value, by default, to pass the node.</li>
<li> <i>string nodePath( char sep = 0, bool from_root = true ) const;</i> — Getting the full path to the node, beginning from the root <i>from_root</i>, and using the separator <i>sep</i> or standard path recording.</li>
<li> <i>void nodeList( vector&lt;string&gt; &amp;list, const string&amp; gid = "" );</i> — Child nodes list <i>list</i> in the specified group <i>gid</i>.</li>
<li> <i>AutoHD&lt;TCntrNode&gt; nodeAt( const string &amp;path, int lev = 0, char sep = 0, int off = 0, bool noex = false );</i> — Attachment to the child node.</li>
<li> <i>void nodeDel( const string &amp;path, char sep = 0, int flag = NodeNoFlg );</i> — Deleting the node using its path.</li>
<li> <i>static void nodeCopy( const string &amp;src, const string &amp;dst, const string &amp;user = "root" );</i> — Copying the nodes of the dynamic tree.</li>
<li> <i>TCntrNode *nodePrev( bool noex = false ) const;</i> — Address of the parent node.</li>
<li> <i>char nodeFlg( );</i> — Node's flag.</li>
<li> <i>void setNodeFlg( char flg );</i> — Set flags <i>TCntrNode::SelfModify</i>, <i>TCntrNode::SelfModifyS</i> and <i>TCntrNode::SelfSaveForceOnChild</i>.</li>
<li> <i>char nodeMode( ) const;</i> — Node's status.</li>
<li> <i>unsigned nodeUse( bool selfOnly );</i> — Number of the connections to the node. <i>selfOnly</i> — only self connections, without childs.</li>
<li> <i>unsigned nodePos( );</i> — The position of the node in the parent-node's container. It is valid only for ordered containers.</li>
<li> <i>int isModify( int mflg = TCntrNode::All );</i> — Checking for the modification of the node or nodes' branch.</li>
<li> <i>void modif( bool save = false, bool forceLoad = false );</i> — Setting the modification sign of the node, with saving <i>save</i> the sign at the loading and marking for the force loading <i>forceLoad</i>.</li>
<li> <i>void modifG( bool forceLoad = false );</i> — Setting the modification sign of the node branch, with marking for the force loading <i>forceLoad</i>.</li>
<li> <i>void modifClr( bool save = false );</i> — Clearing the modification sign or the saving sign <i>save</i> of the node.</li>
<li> <i>void modifGClr( );</i> — Clearing the modification sign of the node branch.</li>
<li> <i>void load( TConfig *cfg = NULL, string *errs = NULL );</i> — Load the dynamic tree node for ready configuration <i>cfg</i>. The loading errors place to <i>errs</i> by lines.</li>
<li> <i>void save( unsigned lev = 0, string *errs = NULL );</i> — Saving the dynamic tree node, on nesting level <i>lev</i> (service). The saving errors place to <i>errs</i> by lines.</li>
<li> <i>virtual void AHDConnect( );</i> — Connection to the node (capture of the resource).</li>
<li> <i>virtual bool AHDDisConnect( );</i> — Disсonnection from the node (release of the resource). Resource will remove on zero result.</li>
<li> <i>void mess_sys( int8_t level, const char *fmt,  ... );</i> — The system message forms for the node path as the category, the <i>level</i>, the formatted message <i>fmt</i> appended by the node location and followed arguments.</li>
<li> <i>TError err_sys( const char *fmt,  ... ) const; TError err_sys( int cod, const char *fmt,  ... ) const;</i> — The error object forms for the node path as the category, the code <i>cod</i>, the formatted message <i>fmt</i> appended by the node location and followed arguments.</li>
<li> <i>virtual TVariant objPropGet( const string &amp;id );</i> — Request of the node's property as the user's object.</li>
<li> <i>virtual void objPropSet( const string &amp;id, TVariant val );</i> — Setting the node's property as the user's object.</li>
<li> <i>virtual TVariant objFuncCall( const string &amp;id, vector&lt;TVariant&gt; &amp;prms, const string &amp;user_lang );</i> — Node function <i>id</i> call with the parameters <i>prms</i> and for user/language <i>user_lang</i> ("{user}\n{lang}").</li>
<li> <i>int8_t grpSize( );</i> — Number of the containers with the child nodes.</li>
<li> <i>int8_t grpId( const string &amp;sid );</i> — Getting the index of the group by its ID.</li>
<li> <i>virtual AutoHD&lt;TCntrNode&gt; chldAt( int8_t igr, const string &amp;name, const string &amp;user = "" ) const;</i> — Attachment to the child node <i>name</i> of the container <i>gr</i> of the user <i>user</i>.</li>
<li> <i>virtual void chldList( int8_t igr, vector&lt;string&gt; &amp;list, bool noex = false ) const;</i> — The list of the child nodes <i>list</i> in the specified container <i>gr</i>.</li>
<li> <i>virtual bool chldPresent( int8_t igr, const string &amp;name ) const;</i> — Check for the presence of the specified child node <i>name</i> in the container <i>gr</i>.</li></ul>
<p><b>Protected methods:</b>
</p>
<ul><li> <i>virtual void cntrCmdProc( XMLNode *req );</i> — Function of requests' processing of the control interface. It must be redefined by the child.</li>
<li> <i>void nodeEn( int flag = NodeNoFlg );</i> — Node's enabling.</li>
<li> <i>void nodeDis( long tm = 0, int flag = NodeNoFlg );</i> — Disabling of the node with the flag transfer.</li>
<li> <i>void nodeDelAll( );</i> — Clear all containers with child nodes.</li>
<li> <i>void setNodePrev( TCntrNode *node );</i> — Setting the parent node to <i>node</i>.</li>
<li> <i>void setNodeMode( char mode );</i> — Setting the node's status.</li>
<li> <i>GrpEl	&amp;grpAt( int8_t id );</i> — Access to the structure of the group.</li>
<li> <i>unsigned grpAdd( const string &amp;id, bool ordered = false );</i> — Adding the container of the child nodes with the prefix <i>id</i> and the possibility of an orderly storage <i>ordered</i>. Returns the ID of the new container.</li>
<li> <i>void grpDel( int8_t id );</i> — Deleting the container of the child nodes <i>id</i>.</li>
<li> <i>virtual string chldAdd( int8_t igr, TCntrNode *node, int pos = -1 );</i> — Adds the child node <i>node</i> to the container <i>gr</i> and position <i>pos</i>. Returns the actual node identifier or name, after it cleaning and shrinking.</li>
<li> <i>void chldDel( int8_t gr, const string &amp;name, long tm = -1, int flags = NodeNoFlg );</i> — Deleting the child node <i>name</i> from the container <i>gr</i> according the EnDisFlag <i>flags</i>.</li>
<li> <i>virtual void preEnable( int flag );</i> — The connection preact. It is called before the actual connection.</li>
<li> <i>virtual void postEnable( int flag );</i> — The connection preact. It is called after the actual connection.</li>
<li> <i>virtual void preDisable( int flag );</i> — The disconnection preact. It is called before the actual disconnection.</li>
<li> <i>virtual void postDisable( int flag );</i> — The disconnection preact. It is called before the actual disconnection (before deleting).</li>
<li> <i>virtual void load_( ); virtual void load_( TConfig *cfg );</i> — The function of the node specific loading, for ready configuration <i>cfg</i> also.</li>
<li> <i>virtual void load__( );</i> — The function of the node specific loading in the loading end.</li>
<li> <i>virtual void save_( );</i> — The function of the saving child node calling.</li>
<li> <i>string storage( const string &amp;cnt, bool forQueueOfData = false ) const;</i> — getting the work or the queued latest storage at <i>forQueueOfData</i> for the storage container <i>cnt</i>.</li>
<li> <i>void setStorage( string &amp;cnt, const string &amp;vl, bool forQueueOfData = false );</i> — setting the work or the queued latest storage at <i>forQueueOfData</i> for the storage container <i>cnt</i>. Empty <i>vl</i> and <i>forQueueOfData</i> removes the first storage from the queue.</li></ul>
<h2><span class="mw-headline" id="Resources_locking"><span class="mw-headline-number">15</span> Resources locking</span></h2>
<p>Most of the units and subsystems of OpenSCADA are dynamic, ie they allow the creation/deletion/configuration while the system is working. Taking into account the multi-threading of the system, this functionality imposes stringent requirements for synchronization of threads. For synchronization in the system the resources are used, functions of which are localized in the objects "Res" and "ResAlloc". Object "Res" provides storage of the resource, providing the functions of capture/release for the read and write. In object "ResAlloc" the automatic release of the resource functions are implemented. Automatic resource involves the creation of a local resource object with its automatic release at fracture (in the destructor). Using of automatic resource makes the work with resources when using the exceptions much easier.
</p><p>Any dynamic system object is inherited from "TCntrNode" object, which contains a mechanism to connect via the "AutoHD" template. The main function of the template is to store the link to the object and the capture of the resource, excluding the deleting of the object at the time of use. Template supports copying the resource and its release in case of destruction of the template object. For clarity of the access to the objects generated by "TCntrNode" the "AutoHD" template supports casting, based on the dynamic cast.
</p>
<h3><span class="mw-headline" id="Resource_R.2FW_lock_object_.28ResRW.29"><span class="mw-headline-number">15.1</span> <span id="ResRW" title="#ResRW">Resource R/W lock object (ResRW)</span></span></h3>
<p><b>Public methods:</b>
</p>
<ul><li> <i>ResRW( );</i> — Initialization of the resource.</li>
<li> <i>static void resRequestW( long tm = 0 );</i> — Request the resource for writing/modification with wait timeout <i>tm</i> (in milliseconds).</li>
<li> <i>bool resTryW( );</i> — Request try the resource for writing/modification. On success return "true" else "false".</li>
<li> <i>static void resRequestR( long tm = 0 );</i> — Request the resource for reading with wait timeout <i>tm</i> (in milliseconds).</li>
<li> <i>bool resTryR( );</i> — Request try the resource for reading. On success return "true" else "false".</li>
<li> <i>static void resRelease( );</i> — Release of the resource.</li></ul>
<h3><span class="mw-headline" id="Automatic_resource_RW_unlock_object_.28ResAlloc.29"><span class="mw-headline-number">15.2</span> <span id="ResAlloc" title="#ResAlloc">Automatic resource RW unlock object (ResAlloc)</span></span></h3>
<p><b>Public methods:</b>
</p>
<ul><li> <i>ResAlloc( ResRW &amp;rid );</i> — Initialization of the automatically released resource for the previously selected identifier  <i>rid</i>.</li>
<li> <i>ResAlloc( ResRW &amp;rid, bool write, long tm = 0 );</i> — Initialization of the automatically released resource for the previously selected identifier <i>rid</i>. With the specification of the resource type <i>write</i> (read/write).</li>
<li> <i>void request( bool write = false, long tm = 0 ); void lock( bool write = false, unsigned short tm = 0 );</i> — Request of the resource in the specified mode <i>write</i> (read/write).</li>
<li> <i>void release( ); void unlock( );</i> — Release of the resource.</li></ul>
<h3><span class="mw-headline" id="Template_.28AutoHD.29"><span class="mw-headline-number">15.3</span> <span id="AutoHD" title="#AutoHD">Template (AutoHD)</span></span></h3>
<p><b>Public methods:</b>
</p>
<ul><li> <i>AutoHD( );</i> — Initializing without linkage to the object.</li>
<li> <i>AutoHD( ORes *node, const string &amp;who = "" );</i> — Initialization with the linkage to the object <i>node</i>. The object must contain the function AHDConnect() and AHDDisConnect().</li>
<li> <i>AutoHD( const AutoHD &amp;hd );</i> — Copyng constructor.</li>
<li> <i>template &lt;class ORes1&gt; AutoHD( const AutoHD&lt;ORes1&gt; &amp;hd_s, bool nosafe = false );</i> — Сast constructor in safe mode casting (by help dynamic_cast). Return free resource on impossible cast.</li>
<li> <i>ORes &amp;at( ) const;</i> — Getting the object by the resource. </li>
<li> <i>AutoHD &amp;operator=(const AutoHD &amp;hd);</i> — Copying of the resources.</li>
<li> <i>bool operator==(const AutoHD &amp;hd);</i> — Compare objects into resource by pointer.</li>
<li> <i>void free( );</i> — Release of the resource.</li>
<li> <i>bool freeStat( ) const;</i> — The sign "The resource is free".</li></ul>
<h3><span class="mw-headline" id="Resources_allocation_object.2C_by_mutex_.28ResMtx.29"><span class="mw-headline-number">15.4</span> <span id="ResMtx" title="#ResMtx">Resources allocation object, by mutex (ResMtx)</span></span></h3>
<p><b>Public methods:</b>
</p>
<ul><li> <i>ResMtx( bool isRecurs = true );</i> — Initialization of a mutex object with recursion <i>isRecurs</i>.</li>
<li> <i>void lock( );</i> — Mutex lock. Return zero at the success.</li>
<li> <i>void unlock( );</i> — Mutex unlock. Return zero at the success.</li>
<li> <i>int tryLock( );</i> — Mutex try lock, without wait for free. Return zero at success.</li>
<li> <i>pthread_mutex_t &amp;mtx( );</i> — Direct link to the mutex structure.</li></ul>
<h3><span class="mw-headline" id="Object_of_the_string_with_the_access_shared_by_the_resource_.28ResString.29"><span class="mw-headline-number">15.5</span> <span id="ResString" title="#ResString">Object of the string with the access shared by the resource (ResString)</span></span></h3>
<p><b>Public methods:</b>
</p>
<ul><li> <i>explicit ResString( const string &amp;vl = "" );</i> — Initialization of the string with the specified value <i>vl</i>.</li>
<li> <i>ResString &amp;operator=( const string &amp;val );</i> — Function for implicit conversion from <i>std::string</i>.</li>
<li> <i>operator string( );</i> — Function for implicit conversion to <i>std::string</i>.</li>
<li> <i>size_t size( );</i> — The string size.</li>
<li> <i>bool empty( );</i> — The string empty.</li>
<li> <i>void setVal( const string &amp;vl );</i> — Setting the string's value to <i>vl</i>.</li>
<li> <i>const string &amp;getVal( );</i> — Getting the string's value.</li>
<li> <i>const string &amp;getValRef( );</i> — Getting a direct reference to the string <i>std::string</i>. The resource is ignored when you use this function!</li></ul>
<h3><span class="mw-headline" id="Conditional_variable_object.2C_by_mutex_.28CondVar.29"><span class="mw-headline-number">15.6</span> <span id="CondVar" title="#CondVar">Conditional variable object, by mutex (CondVar)</span></span></h3>
<p><b>Public methods:</b>
</p>
<ul><li> <i>CondVar( );</i> — Initialization of the conditional variable.</li>
<li> <i>int wait( ResMtx &amp;mtx, unsigned short tm = 0 );</i> — wait for the conditional variable wake up for the timeout <i>tm</i> with the mutex <i>mtx</i>.</li>
<li> <i>int wakeOne( );</i> — wake up one thread.</li>
<li> <i>int wakeAll( );</i> — wake up all threads.</li></ul>
<h3><span class="mw-headline" id="Object_of_automatic_unlock_POSIX_mutex_.28MtxAlloc.29"><span class="mw-headline-number">15.7</span> <span id="MtxAlloc" title="#MtxAlloc">Object of automatic unlock POSIX mutex (MtxAlloc)</span></span></h3>
<p><b>Public methods:</b>
</p>
<ul><li> <i>MtxAlloc( ResMtx &amp;iM, bool lock = false );</i> — Initialization of automatic unlock mutex for early allocated identifier <i>iM</i>. With the <i>lock</i> set at a creation.</li>
<li> <i>int lock( );</i> — The resource lock. Return zero at the success.</li>
<li> <i>int unlock( );</i> — The resource unlock. Return zero at the success.</li>
<li> <i>int tryLock( );</i> — The resource try lock, without wait for free. Return zero at the success.</li></ul>
<h3><span class="mw-headline" id="Object_of_the_string_with_the_access_shared_by_the_global_the_data_resource_.28mutex.29_.28MtxString.29"><span class="mw-headline-number">15.8</span> <span id="MtxString" title="#MtxString">Object of the string with the access shared by the global the data resource (mutex) (MtxString)</span></span></h3>
<p><b>Public methods:</b>
</p>
<ul><li> <i>MtxString( ResMtx &amp;iM );</i> — The string initialization with the access sharing by resource <i>iM</i>.</li>
<li> <i>MtxString &amp;operator=( const string &amp;val );</i> — Function for implicit conversion from <i>std::string</i>.</li>
<li> <i>operator string( );</i> — Function for implicit conversion to <i>std::string</i>.</li>
<li> <i>size_t size( );</i> — The string size.</li>
<li> <i>bool empty( );</i> — The string empty.</li>
<li> <i>void setVal( const string &amp;vl );</i> — Setting the string's value to <i>vl</i>.</li>
<li> <i>const string &amp;getVal( );</i> — Getting the string's value.</li>
<li> <i>const string &amp;getValRef( );</i> — Getting a direct reference to the string <i>std::string</i>. The resource is ignored when you use this function!</li></ul>
<h2><span class="mw-headline" id="Other_generic_objects"><span class="mw-headline-number">16</span> Other generic objects</span></h2>
<p>XML in OpenSACDA is represented by the object of the XML-tag — XMLNode.
</p><p>Errors of the exceptions are handled by the error object "TError".
</p>
<h3><span class="mw-headline" id="XML-tag_.28XMLNode.29"><span class="mw-headline-number">16.1</span> <span id="XMLNode" title="#XMLNode">XML-tag (XMLNode)</span></span></h3>
<p><b>Data:</b><br />
Options for XML-file loading (enum — XMLNode::LoadFlgs):
</p>
<ul><li> <i>XMLNode::LD_Full</i> (0x01) — load XML full;</li>
<li> <i>XMLNode::LD_NoTxtSpcRemEnBeg</i> (0x02) — no remove spaces for begin and end tag's text, for not full mode.</li></ul>
<p>Options of the function of XML-file generation (enum - XMLNode::SaveView):
</p>
<ul><li> <i>XMLNode::BrOpenPrev</i> (0x01) — insert the end of the line before the opening tag;</li>
<li> <i>XMLNode::BrOpenPast</i> (0x02) — insert the end of the line after the opening tag;</li>
<li> <i>XMLNode::BrClosePast</i> (0x04) — insert the end of the line after the closing tag;</li>
<li> <i>XMLNode::BrTextPast</i> (0x08) — insert the end of the line after the tag text;</li>
<li> <i>XMLNode::BrSpecBlkPast</i> (0x10) — insert the end of the line after the computed instruction;</li>
<li> <i>XMLNode::BrAllPast</i> (0x1E) — insert the end of the line after the all elements;</li>
<li> <i>XMLNode::XMLHeader</i> (0x20) — insert the standard xml-header;</li>
<li> <i>XMLNode::XHTMLHeader</i> (0x40) — insert the standard XHTML-header;</li>
<li> <i>XMLNode::Clean</i> (0x80) — result clean from comments and procedure insertions;</li>
<li> <i>XMLNode::MissTagEnc</i> (0x100) — to miss for tags name encoding;</li>
<li> <i>XMLNode::MissAttrEnc</i> (0x200) — to miss for attributes name encoding;</li>
<li> <i>XMLNode::BinShield</i> (0x400) — shield the binary symbols [\x0-\x8\xB-\xC\x0E-\x1F] and wrong UTF-8.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>XMLNode( const string &amp;name = "" );</i> — Initialization of the tag with the <i>name</i>.</li>
<li> <i>XMLNode( const XMLNode &amp;nd );</i> — Copy constructor.</li>
<li> <i>XMLNode &amp;operator=( const XMLNode &amp;prm );</i> — Copying a branch of the XML-tree from <i>prm</i>.</li>
<li> <i>string name( ) const;</i> — Tag's name.</li>
<li> <i>XMLNode* setName( const string &amp;s );</i> — Setting the tag's name to <i>s</i>.</li>
<li> <i>string text( bool childs = false, bool recursive = false ) const;</i> — Tag's text. <i>childs</i> — for text getting from special text nodes.</li>
<li> <i>XMLNode* setText( const string &amp;s, bool childs = false );</i> — Setting the tag's text to <i>s</i>. <i>childs</i> — for set text to special text node.</li>
<li> <i>void attrList( vector&lt;string&gt; &amp; list ) const;</i> — <i>List</i> of attributes in the tag.</li>
<li> <i>XMLNode* attrDel( const string &amp;name );</i> — Deleting of the attribute <i>name</i>.</li>
<li> <i>void attrClear( );</i> — Clean up the tag's attributes.</li>
<li> <i>string attr( const string &amp;name, bool caseSens = true, bool *presence = NULL ) const;</i> — Getting the attribute <i>name</i> for the case-sensitivity <i>caseSens</i> and with the <i>presence</i> sign.</li>
<li> <i>XMLNode* setAttr( const string &amp;name, const string &amp;val );</i> — Setting/creation of the attribute <i>name</i> with the value <i>val</i>.</li>
<li> <i>void load( const string &amp;vl, unsigned flg = 0, const string &amp;cp = "UTF-8" );</i> — Load/parsing of the XML-file, with source encoding <i>cp</i> and flags <i>flg</i>.</li>
<li> <i>string save( unsigned flg = 0, const string &amp;cp = "UTF-8" ) const;</i> — Saving/creation of the XML-file with the formatting parameter <i>flg</i> and encoding to <i>cp</i>.</li>
<li> <i>XMLNode* clear( );</i> — Clear the tag (recursively, including all childs).</li>
<li> <i>bool childEmpty( ) const;</i> — Check for empty included tags.</li>
<li> <i>unsigned childSize( ) const;</i> — Number of included tags.</li>
<li> <i>void childAdd( XMLNode *nd ); XMLNode* childAdd( const string &amp;name = "" );</i> — Adding the included tag.</li>
<li> <i>int childIns( int id, XMLNode *nd );</i> — Insert of the included tag <i>nd</i> to the position <i>id</i>. Negative <i>id</i> counts from end.</li>
<li> <i>XMLNode* childIns( int id, const string &amp;name = "" );</i> — Insert of the included tag with the name <i>name</i> to the position <i>id</i>. Negative <i>id</i> counts from end.</li>
<li> <i>void childDel( const int id );</i> — Deleting of the included tag <i>id</i>. Negative <i>id</i> counts from end.</li>
<li> <i>void childDel( XMLNode *nd );</i> — Deleting of the included tag using its address <i>nd</i>.</li>
<li> <i>void childClear( const string &amp;name = "" );</i> — Clean up of the included tag <i>name</i>.</li>
<li> <i>XMLNode* childGet( const int, bool noex = false ) const;</i> — Getting the included tag by its index number.</li>
<li> <i>XMLNode* childGet( const string &amp;name, const int numb = 0, bool noex = false ) const;</i> — Getting of the included <i>numb</i> indexed tag by the tag's name <i>name</i>. <i>noex</i> indicates the prohibition of the generation of exception in the case of absence of the tag.</li>
<li> <i>XMLNode* childGet( const string &amp;attr, const string &amp;vl, bool noex = false ) const;</i> — Getting the included <i>numb</i> indexed tag by its value <i>vl</i> of the attribute <i>attr</i>. <i>noex</i> indicates the prohibition of the generation of exception in the case of absence of the tag.</li>
<li> <i>XMLNode* getElementBy( const string &amp;attr, const string &amp;val );</i> — Included node search by the value <i>val</i> of the attribute <i>attr</i>.</li>
<li> <i>void getElementsBy( const string &amp;tag, const string &amp;attr, const string &amp;val, TArrayObj *rez );</i> — get elements array <i>rez</i> from the tree by <i>tag</i> (empty for all) and attribute <i>attr</i> value <i>val</i> (empty for pass).</li>
<li> <i>XMLNode* parent( );</i> — Parent tag of the tag.</li>
<li> <i>XMLNode* root( );</i> — Root tag of the tag.</li></ul>
<h3><span class="mw-headline" id="Error_exception_.28TError.29"><span class="mw-headline-number">16.2</span> <span id="TError" title="#TError">Error exception (TError)</span></span></h3>
<p><b>Data:</b><br />
Error codes (enum — TError::Codes):
</p>
<ul><li> <i>TError::NoCode (0)</i>, <i>TError::NoError (0)</i> — no error;</li>
<li> <i>TError::Core_CntrWarning (1)</i> — core level, warning of the control interface;</li>
<li> <i>TError::Core_CntrError (2)</i> — core level, error of the control interface;</li>
<li> <i>TError::Core_RWLock_EDEADLK (3)</i> — core level, deadlock of the RWLock;</li>
<li> <i>TError::Core_TaskCrt (4)</i> — core level, error the task-thread creation;</li>
<li> <i>TError::Core_NoNode (5)</i> — no node, error at accessing some missing node;</li>
<li> <i>TError::Tr_Connect (10)</i> — transport level, error connection;</li>
<li> <i>TError::Tr_UnknownHost (11)</i> — transport level, unknown host;</li>
<li> <i>TError::Tr_ErrTransport (12)</i> — transport level, transport error;</li>
<li> <i>TError::Tr_ErrResponse (13)</i> — transport level, response error;</li>
<li> <i>TError::Tr_ErrDevice (14)</i> — transport level, device error;</li>
<li> <i>TError::DB_SQL_Connect (20)</i> — DB level, error the SQL-connection;</li>
<li> <i>TError::DB_SQL_Query (21)</i> — DB level, error the SQL-query;</li>
<li> <i>TError::DB_TrRemoved (22)</i> — DB level, translation removed;</li>
<li> <i>TError::DB_ReadOnly (23)</i> — DB in the Read Only mode;</li>
<li> <i>TError::Arch_Val_OldBufVl (30)</i> — archives level, old value placing to the value buffer;</li>
<li> <i>TError::Arch_Val_DblVSrc (31)</i> — double value source setting try;</li>
<li> <i>TError::EXT (100)</i> — extended errors of OpenSCADA modules to use as TError::EXT+{N}.</li></ul>
<p><b>Public methods:</b>
</p>
<ul><li> <i>TError( );</i> — Default-empty constructor.</li>
<li> <i>TError( const char *cat, const char *mess, ... );</i> — Initialization of the error with the category <i>cat</i> and the message <i>mess</i> + arguments.</li>
<li> <i>TError( int cod, const char *cat, const char *mess, ... );</i> — Initialization of the error with the <i>code</i>, the category <i>cat</i> and the message <i>mess</i> + arguments.</li></ul>
<p><b>Public attributes:</b>
</p>
<ul><li> <i>int cod;</i> — The error code.</li>
<li> <i>string cat;</i> — The error category.</li>
<li> <i>string mess;</i> — The error message.</li></ul>
<h2><span class="mw-headline" id="Organization_and_structure_of_the_database_of_the_system_components"><span class="mw-headline-number">17</span> Organization and structure of the database of the system components</span></h2>
<p>Nodes and subsystems of OpenSCADA may have their own tables in the database to store their own data. The structure of tables is individual and determined by the &lt;TConfig&gt; object. Nodes and subsystems must create and configure the &lt;TConfig&gt; object under their demands.
</p>
<h3><span class="mw-headline" id="System_tables"><span class="mw-headline-number">17.1</span> System tables</span></h3>
<p>OpenSCADA has two system tables: BD and SYS. Table BD contains records of registered databases and the table SYS contains data of system-wide parameters.
</p><p><b>Table 7.</b> Structure if the table of system-wide parameters (SYS).
</p>
<table class="wikitable">

<tr>
<th> User &lt;<u>user</u>&gt; </th>
<th> Parameter's ID &lt;<u>id</u>&gt; </th>
<th> Parameter's value &lt;val&gt;
</th></tr>
<tr>
<td>root</td>
<td>/DemoStation/MessLev</td>
<td>0
</td></tr>
<tr>
<td>user</td>
<td>/DemoStation/Workdir</td>
<td>/mnt/home/roman/work/OScadaD/share/OpenScada
</td></tr>
<tr>
<td>user</td>
<td>/DemoStation/UI/QTStarter/StartMod</td>
<td>QTCfg
</td></tr></table>
<p><b>Table 8.</b> Structure if the table of registered DB.
</p>
<table class="wikitable">

<tr>
<th> ID &lt;<u>ID</u>&gt; </th>
<th> DB Type &lt;<u>TYPE</u>&gt; </th>
<th> Name &lt;NAME&gt; </th>
<th> Description &lt;DESCR&gt; </th>
<th> Address &lt;ADDR&gt; </th>
<th> Codepage of the database contents &lt;CODEPAGE&gt; </th>
<th> To enable &lt;EN&gt;
</th></tr>
<tr>
<td>LibBD</td>
<td>MySQL</td>
<td>Function's library</td>
<td> </td>
<td>server.diya.org;roman;123456;oscadaUserLibs</td>
<td>KOI8-U</td>
<td>1
</td></tr>
<tr>
<td>AnastModel</td>
<td>SQLite</td>
<td>AGLKS model</td>
<td> </td>
<td>./DATA/AGLKSModel.db</td>
<td>UTF8</td>
<td>1
</td></tr>
<tr>
<td>GenDB</td>
<td>MySQL</td>
<td>Main DB </td>
<td> </td>
<td>server.diya.org;roman;123456;oscadaDemoSt</td>
<td>KOI8-U</td>
<td>1
</td></tr></table>
<h3><span class="mw-headline" id="Tables_of_the_.22Data_acquisition.22_subsystem"><span class="mw-headline-number">17.2</span> Tables of the "Data acquisition" subsystem</span></h3>
<p>Controllers (data sources) of the subsystem "Data acquisition" are stored in the tables of their subsystems named DAQ_&lt;ModName&gt;. The structures of these tables can differ significantly, but all of them have the obligatory fields. The overall structure of the controllers' tables is presented in table 9.
</p><p><b>Table  9.</b> The overall structure of the controllers' tables of the subsystem "Data acquisition" (DAQ_&lt;ModName&gt;).
</p>
<table class="wikitable">

<tr>
<th> ID &lt;<u>ID</u>&gt; </th>
<th> Controller's name &lt;NAME&gt; </th>
<th> Description &lt;DESCR&gt; </th>
<th> To enable&lt;ENABLE&gt; </th>
<th> To start &lt;START&gt; </th>
<th> Individual parameters
</th></tr>
<tr>
<td>AutoDA</td>
<td>Automatic source</td>
<td>Data acquisition from active sources with automatic identification of them.</td>
<td>1</td>
<td>1</td>
<td> ...
</td></tr></table>
<p>Like the controller's table, the parameter's table for different types of data sources can differ significantly, but also have the obligatory fields. In addition to the differences which is typical to the type of data source, parameter's tables can still be different for different types of parameters. The overall structure of the parameters' tables is given in Table 10.
</p><p><b>Table 10.</b> The overall structure of the parameters' tables of  the subsystem "Data acquisition".
</p>
<table class="wikitable">

<tr>
<th> Parameter's shifr &lt;<u>SHIFR</u>&gt; </th>
<th> Parameter's name &lt;NAME&gt; </th>
<th> Parameter's description &lt;DESCR&gt; </th>
<th> To enable &lt;EN&gt; </th>
<th> Individual parameters
</th></tr>
<tr>
<td>P3</td>
<td>P3</td>
<td>Pressure on the diaphragm</td>
<td>1</td>
<td>...
</td></tr></table>
<p>In addition to controllers and parameters the subsystem "Data acquisition" contains parameter's templates. Parameter's templates are grouped by templates' libraries and are stored in tables of three types: templates' library table (ParamTemplLibs) — table 11, parameter's templates table — table 12 and template's parameters table — table 13.
</p><p><b>Table 11.</b> Structure of the templates' library table.
</p>
<table class="wikitable">

<tr>
<th> ID &lt;<u>ID</u>&gt; </th>
<th> Name &lt;NAME&gt; </th>
<th> Description &lt;DESCR&gt; </th>
<th> DB table of the library &lt;DB&gt;
</th></tr>
<tr>
<td>base</td>
<td>Basic templates</td>
<td>Basic templates' library</td>
<td>tmplib_base
</td></tr>
<tr>
<td>S7</td>
<td> </td>
<td>Templates' Library for Siemens S7 series controllers.</td>
<td>tmplib_S7
</td></tr></table>
<p><b>Table 12.</b> Structure of the templates' table.
</p>
<table class="wikitable">

<tr>
<th> ID &lt;<u>ID</u>&gt; </th>
<th> Name &lt;NAME&gt; </th>
<th> Description &lt;DESCR&gt; </th>
<th> Text of the template procedure &lt;PROGRAM&gt;
</th></tr>
<tr>
<td>digAlarm</td>
<td>Digital signal</td>
<td>Alarm over the discrete parameter</td>
<td>JavaLikeCalc.JavaScript
</td></tr>
<tr>
<td>simpleBoard</td>
<td>Simple boards</td>
<td>Formation of the simple boards of the analog signal.</td>
<td>JavaLikeCalc.JavaScript
</td></tr></table>
<p><b>Table 13.</b> Structure of the table of the template's parameters.
</p>
<table class="wikitable">

<tr>
<th> Template's ID &lt;<u>TMPL_ID</u>&gt; </th>
<th> Parameter's ID &lt;<u>ID</u>&gt; </th>
<th> Name &lt;NAME&gt; </th>
<th> Type &lt;TYPE&gt; </th>
<th> Flags &lt;FLAGS&gt; </th>
<th> Value &lt;VALUE&gt; </th>
<th> Position &lt;POS&gt;
</th></tr>
<tr>
<td>digAlarm</td>
<td>in</td>
<td>Вход</td>
<td>3</td>
<td>144</td>
<td> </td>
<td>2
</td></tr>
<tr>
<td>digitBlock</td>
<td>cmdOpen</td>
<td>Open command</td>
<td>3</td>
<td>161</td>
<td> </td>
<td>0
</td></tr></table>
<h3><span class="mw-headline" id="Tables_of_the_.22Transports.22_subsystem"><span class="mw-headline-number">17.3</span> Tables of the "Transports" subsystem</span></h3>
<p>Subsystem "Transports" is divided into input and output transports. For each type of transport there is its own table with its own structure. Table names, respectively: Transport_In and Transport_Out. Tables can be supplemented by fields, typical to the type of transport.
</p><p><b>Table 14.</b> Structure of the input transport's table (Transport_in).
</p>
<table class="wikitable">

<tr>
<th> ID &lt;<u>ID</u>&gt; </th>
<th> Type &lt;<u>MODULE</u>&gt; </th>
<th> Name &lt;NAME&gt; </th>
<th> Description &lt;DESCRIPT&gt; </th>
<th> Address &lt;ADDR&gt; </th>
<th> Protocol &lt;PROT&gt; </th>
<th> To start &lt;START&gt; </th>
<th> Individual fields of the transports' types
</th></tr>
<tr>
<td>web1</td>
<td>Sockets</td>
<td>Web 1</td>
<td>Work web transport for proced http requests.</td>
<td>TCP::10002:0</td>
<td>HTTP</td>
<td>1</td>
<td>...
</td></tr>
<tr>
<td>Self</td>
<td>SelfSystem</td>
<td>TCP 1</td>
<td>Test TCP input socket!</td>
<td>Sockets</td>
<td>TCP::10001:1</td>
<td>1</td>
<td>...
</td></tr></table>
<p><b>Table 15.</b> Structure of the output transport's table (Transport_out).
</p>
<table class="wikitable">

<tr>
<th> ID &lt;<u>ID</u>&gt; </th>
<th> Type &lt;<u>MODULE</u>&gt; </th>
<th> Name &lt;NAME&gt; </th>
<th> Description &lt;DESCRIPT&gt; </th>
<th> Address &lt;ADDR&gt; </th>
<th> Individual fields of the transports' types
</th></tr>
<tr>
<td>tcp_o1</td>
<td>Sockets</td>
<td>TCP Out 1</td>
<td>Output TCP transport 1</td>
<td>TCP::10001</td>
<td>...
</td></tr></table>
<p>For the centralized description of the list of external OpenSCADA stations it is used the table of external hosts (CfgExtHosts). The structure of this table is shown in Table 16.
</p><p><b>Table 16.</b> The structure of the table of external OpenSCADA hosts (CfgExtHosts).
</p>
<table class="wikitable">

<tr>
<th> User of the system &lt;<u>OP_USER</u>&gt; </th>
<th> ID &lt;<u>ID</u>&gt; </th>
<th> Name &lt;NAME&gt; </th>
<th> Transport &lt;TRANSP&gt; </th>
<th> Address of the remote host &lt;ADDR&gt; </th>
<th> User of the external host &lt;USER&gt; </th>
<th> Password of the user of the external host &lt;PASS&gt;
</th></tr>
<tr>
<td>tcp_o1</td>
<td>Sockets</td>
<td>TCP Out 1</td>
<td>Output TCP transport 1</td>
<td>TCP::10001</td>
<td>1</td>
<td>...
</td></tr></table>
<h3><span class="mw-headline" id="Tables_of_the_.22Archives.22_subsystem"><span class="mw-headline-number">17.4</span> Tables of the "Archives" subsystem</span></h3>
<p>Subsystem "Archives" contains three tables with fixed names:
</p>
<ul><li> Archives of values: Archive_val;</li>
<li> Archivers of values: Archive_val_proc;</li>
<li> Archivers of messages: Archive_mess_proc.</li></ul>
<p>Tables of the archivers can be complemented by fields, typical for each type of archiver.
</p><p><b>Table 17.</b> Structure of the table of the values' archive (Archive_val).
</p>
<table class="wikitable">

<tr>
<th> ID &lt;<u>ID</u>&gt; </th>
<th> Name &lt;NAME&gt; </th>
<th> Description &lt;DESCR&gt; </th>
<th> To start &lt;START&gt; </th>
<th> The mode of the values' source &lt;SrcMode&gt; </th>
<th> Source of the values &lt;Source&gt; </th>
<th> Type of the values &lt;VTYPE&gt; </th>
<th> Buffer's periodicity &lt;BPER&gt; </th>
<th> Buffer's size &lt;BSIZE&gt; </th>
<th> Buffer's hard grid &lt;BHGRD&gt; </th>
<th> High resolution of the buffer's time &lt;BHRES&gt; </th>
<th> List of the serviced archivers &lt;ArchS&gt;
</th></tr>
<tr>
<td>CPULoad_load</td>
<td> </td>
<td> </td>
<td>1</td>
<td>1</td>
<td>DAQ.System.AutoDA.CPULoad.load</td>
<td>4</td>
<td>1</td>
<td>100</td>
<td>0</td>
<td>0</td>
<td>FSArch.1s;DBArch.1m;FSArch.1m;
</td></tr>
<tr>
<td>ai1_dP</td>
<td> </td>
<td> </td>
<td>0</td>
<td>0</td>
<td> </td>
<td>4</td>
<td>0.0001</td>
<td>100</td>
<td>1</td>
<td>1</td>
<td>FSArch.POMP_20070301;FSArch.1s;
</td></tr></table>
<p><b>Table 18.</b> Structure of the table of the values' archivers (Archive_val_proc).
</p>
<table class="wikitable">

<tr>
<th> ID &lt;<u>ID</u>&gt; </th>
<th> Archiver's type &lt;<u>MODUL</u>&gt; </th>
<th> Name &lt;NAME&gt; </th>
<th> Description &lt;DESCR&gt; </th>
<th> To start &lt;START&gt; </th>
<th> Address &lt;ADDR&gt; </th>
<th> Values' period &lt;V_PER&gt; </th>
<th> Archiving period &lt;A_PER&gt; </th>
<th> Individual fields of the archivers' types
</th></tr>
<tr>
<td>1s</td>
<td>FSArch</td>
<td> </td>
<td>One second</td>
<td>1</td>
<td>ARCHIVES/VAL/1s</td>
<td>1</td>
<td>60</td>
<td>...
</td></tr>
<tr>
<td>POMP_20070301</td>
<td>FSArch</td>
<td> </td>
<td> </td>
<td>0</td>
<td>ARCHIVES/VAL/POMP_20070301</td>
<td>0.0001</td>
<td>60</td>
<td>...
</td></tr></table>
<p><b>Table 19.</b> Structure of the table of the messages' archivers (Archive_mess_proc).
</p>
<table class="wikitable">

<tr>
<th> ID &lt;<u>ID</u>&gt; </th>
<th> Archiver's type &lt;<u>MODUL</u>&gt; </th>
<th> Name &lt;NAME&gt; </th>
<th> Description &lt;DESCR&gt; </th>
<th> To start &lt;START&gt; </th>
<th> Template of the messages' category &lt;CATEG&gt; </th>
<th> Messages' level &lt;LEVEL&gt; </th>
<th> Address &lt;ADDR&gt; </th>
<th> Individual fields of the archivers' types
</th></tr>
<tr>
<td>StatErrors</td>
<td>FSArh</td>
<td>Station error</td>
<td> </td>
<td>1</td>
<td>/DemoStation*</td>
<td>4</td>
<td>ARCHIVES/MESS/stError/</td>
<td>...
</td></tr>
<tr>
<td>NetRequsts</td>
<td>FSArh</td>
<td>Network requests</td>
<td> </td>
<td>1</td>
<td>/DemoStation/Transport/Sockets*</td>
<td>1</td>
<td>ARCHIVES/MESS/Net/</td>
<td>...
</td></tr></table>
<h3><span class="mw-headline" id="Tables_of_the_.22Security.22_subsystem"><span class="mw-headline-number">17.5</span> Tables of the "Security" subsystem</span></h3>
<p>Subsystem "Security" contains two tables: table of the system's users (Security_user) and groups of the system (Security_grp).
</p><p><b>Table 20.</b> Structure of the table of the system's users (Security_user).
</p>
<table class="wikitable">

<tr>
<th> Name &lt;<u>NAME</u>&gt; </th>
<th> Description &lt;DESCR&gt; </th>
<th> Password &lt;PASS&gt; </th>
<th> Picture &lt;PICTURE&gt;
</th></tr>
<tr>
<td>root</td>
<td>SuperUser</td>
<td>openscada</td>
<td>
</td></tr>
<tr>
<td>user</td>
<td>User</td>
<td>user</td>
<td>
</td></tr></table>
<p><b>Table 21.</b> Structure of the table of the system's users groups (Security_grp).
</p>
<table class="wikitable">

<tr>
<th> Name &lt;<u>NAME</u>&gt; </th>
<th> Description &lt;DESCR&gt; </th>
<th> Users in the group &lt;USERS&gt;
</th></tr>
<tr>
<td>root</td>
<td>SuperUser's group</td>
<td>root;user
</td></tr>
<tr>
<td>users</td>
<td>User's group</td>
<td>toot;user
</td></tr></table>
<h3><span class="mw-headline" id="The_structure_of_the_databases_of_the_modules"><span class="mw-headline-number">17.6</span> The structure of the databases of the modules</span></h3>
<p>Each module can have its own database tables to store individual data. Structure of database tables of the modules can be formed freely, based on internal needs.
</p>
<h2><span class="mw-headline" id="Service_functions_of_the_OpenSCADA_control_interface"><span class="mw-headline-number">18</span> <span id="ServFunc" title="#ServFunc">Service functions of the OpenSCADA control interface</span></span></h2>
<p>Service functions is an interface to access OpenSCADA through <a href="#CntrNode">the OpenSCADA control interface</a> from external systems. This mechanism is the basis for all exchange mechanisms within OpenSCADA, implemented through weak links and <a href="Modules/SelfSystem.html" title="Special:MyLanguage/Modules/SelfSystem">the standard-self exchange protocol of OpenSCADA</a>. Its main advantage is the priority processing and the possibility of using non-standard packaging data. For access to normal data you can use <a href="#CntrNode">the standard commands</a> of the control interface.
</p><p><a class="image" href="http://oscada.org/wiki/File:At.png"><img alt="At.png" height="22" src="files/At.png" width="22" /></a> Not all service functions-requests are described here so to familiarise all presented you must see to the function <i>cntrCmdProc()</i> of proper parts of OpenSCADA in <a class="external text" href="http://oscada.org/svn/trunk/OpenSCADA/" rel="nofollow noreferrer noopener" target="_blank">the project sources</a>.
</p>
<h3><span class="mw-headline" id="Group_access_to_the_values_of_the_parameter.27s_attributes_of_the_subsystem_.22Data_acquisition.22.2C_as_well_as_to_the_detailed_information"><span class="mw-headline-number">18.1</span> Group access to the values of the parameter's attributes of the subsystem "Data acquisition", as well as to the detailed information</span></h3>
<p>These requests let you to obtain detailed information about the parameters of the subsystem "Data acquisition", to acquire the values of all attributes of the parameters, and also to make the group setting. Detailed information about requests is given in Table 23.
</p><p><b>Table 23.</b> Attributes of the request commands of the attributes' parameters of the subsystem "Data acquisition"
</p>
<table class="wikitable">

<tr>
<td><b>Id</b></td>
<td><b>Name</b></td>
<td><b>Value</b>
</td></tr>
<tr>
<td> <i>Request command of information about the attributes of the parameter:</i> <b>&lt;list path="/sub_DAQ/mod_{SRC}/cntr_{CNTR}/prm_{PRM}/%2fserv%2fattr"/&gt;</b>
</td></tr>
<tr>
<td> &lt;el id="iatr"/&gt; </td>
<td> Information of the attributes </td>
<td> In separate tags the information about attribute is returned.
</td></tr>
<tr>
<td>  id </td>
<td> Attribute's ID </td>
<td> The character identifier of the single attribute.
</td></tr>
<tr>
<td>  nm </td>
<td> Attribute's name </td>
<td> The name of the single attribute.
</td></tr>
<tr>
<td>  flg </td>
<td> Attribute's flags </td>
<td> Flags of the single attribute.
</td></tr>
<tr>
<td>  tp </td>
<td> Attribute's type </td>
<td> The type of the single attribute.
</td></tr>
<tr>
<td>  vals </td>
<td> Values area of the attribute. </td>
<td> Values area of the single attribute.
</td></tr>
<tr>
<td>  names </td>
<td> The names of the attribute's values for the selectable type. </td>
<td> The names of the single attribute's values for the selectable type.
</td></tr>
<tr>
<td> <i>Team request command of the all values of attributes of the parameter:</i> <b>&lt;get path="/sub_DAQ/mod_{SRC}/cntr_{CNTR}/prm_{PRM}/%2fserv%2fattr"/&gt;</b>
</td></tr>
<tr>
<td> &lt;el id="iatr"&gt;val&lt;/el&gt; </td>
<td> Attributes' values </td>
<td> In separate tags the values of the attributes are returned.
</td></tr>
<tr>
<td> <i>The set command of the the values of the specified attributes of the parameter:</i> <b>&lt;set path="/sub_DAQ/mod_{SRC}/cntr_{CNTR}/prm_{PRM}/%2fserv%2fattr"/&gt;</b>
</td></tr>
<tr>
<td> &lt;el id="iatr"&gt;val&lt;/el&gt; </td>
<td> The values of attributes are specified </td>
<td> In separate tags the values of attributes are specified.
</td></tr></table>
<h3><span class="mw-headline" id="Access_to_archived_data_of_the_archives_of_messages"><span class="mw-headline-number">18.2</span> Access to archived data of the archives of messages</span></h3>
<p>To request and set the archive data in the archiving subsystem of the messages archive's object the following command is provided <b>&lt;info path="/sub_Archive/%2fserv%2fmess"/&gt;</b>, <b>&lt;get path="/sub_Archive/%2fserv%2fmess"/&gt;</b> and <b>&lt;set path="/sub_Archive/%2fserv%2fmess"/&gt;</b> to request the information about the archive, archive's values and set values to archive, respectively. Into the object of controller of subsystem "Data acquisition" provides service request for messages generated by the data source <b>&lt;get path="/sub_DAQ/{DAQ_TP}/{DAQ_CNTR}/%2fserv%2fmess"/&gt;</b>. The detailed description of these commands is presented in Table 24.
</p><p><b>Table 24.</b> Attributes of request commands of information about the archive of values and archive data
</p>
<table class="wikitable">

<tr>
<td><b>Id</b></td>
<td><b>Name</b></td>
<td><b>Value</b>
</td></tr>
<tr>
<td> <i>Request command of the information about the archive:</i> <b>&lt;info path="/sub_Archive/%2fserv%2fmess"/&gt;</b>
</td></tr>
<tr>
<td> arch </td>
<td> Setting the name of the archive's archiver </td>
<td> Archive's archiver, for which to specify the parameters.
</td></tr>
<tr>
<td> end </td>
<td> Control of the archive's top in the given archiver </td>
<td> As a result of the request points to the real top of the messages' archive in the given archiver &lt;arch&gt;.
</td></tr>
<tr>
<td> beg </td>
<td> Control of the archive's depth in the given archiver </td>
<td> As a result of the request points to the real depth of the messages' archive in the given archiver &lt;arch&gt;.
</td></tr>
<tr>
<td> <i>Request command of the archival and/or current data:</i> <b>&lt;get path="/sub_Archive/%2fserv%2fmess"/&gt;</b>
</td></tr>
<tr>
<td> tm </td>
<td> Time set </td>
<td> Time of the block's top of the messages' archive.
</td></tr>
<tr>
<td> tm_grnd </td>
<td> Time set of the foundation/beginning of the archive </td>
<td> Points to the foundation/beginning of the archive.
</td></tr>
<tr>
<td> arch </td>
<td> Setting of the archive's archiver </td>
<td> Specifies at what archiver to request the values. If the archiver is not specified, the request will be made consistently in all archivers with the exception of duplicates.
</td></tr>
<tr>
<td> cat </td>
<td> Setting the message's category </td>
<td> Specify the category/template of the requested messages.
</td></tr>
<tr>
<td> lev </td>
<td> Setting the level of importance </td>
<td> Specifies the importance level of messages for which and above to get the messages.
</td></tr>
<tr>
<td> &lt;el&gt;{mess}&lt;/el&gt; </td>
<td> Messages </td>
<td> In separate tags the messages are returned.
</td></tr>
<tr>
<td>  time, utime </td>
<td> Message's time (seconds, microseconds) </td>
<td> Time of the separate message.
</td></tr>
<tr>
<td>  cat </td>
<td> Message's category </td>
<td> Category of the separate message.
</td></tr>
<tr>
<td>  lev </td>
<td> Message's level </td>
<td> Level of the separate message.
</td></tr>
<tr>
<td> <i>Set command of the archival data:</i> <b>&lt;set path="/sub_Archive/%2fserv%2fmess"/&gt;</b>
</td></tr>
<tr>
<td> &lt;el&gt;{mess}&lt;/el&gt; </td>
<td> Messages </td>
<td> In separate tags the messages for set.
</td></tr>
<tr>
<td>  time, utime </td>
<td> Message's time (seconds, microseconds) </td>
<td> Time of the separate message.
</td></tr>
<tr>
<td>  cat </td>
<td> Message's category </td>
<td> Category of the separate message.
</td></tr>
<tr>
<td>  lev </td>
<td> Message's level </td>
<td> Level of the separate message.
</td></tr>
<tr>
<td> <i>Request command of the archival and/or current data of the data source:</i> <b>&lt;get path="/sub_DAQ/{DAQ_TP}/{DAQ_CNTR}/%2fserv%2fmess"/&gt;</b>
</td></tr>
<tr>
<td> tm </td>
<td> Time set </td>
<td> Time of the block's top of the messages' archive. If the value is zero then set and return here current time value.
</td></tr>
<tr>
<td> tm_grnd </td>
<td> Time set of the foundation/beginning of the archive </td>
<td> Points to the foundation/beginning of the archive.
</td></tr>
<tr>
<td> &lt;el&gt;{mess}&lt;/el&gt; </td>
<td> Messages </td>
<td> In separate tags the messages are returned.
</td></tr>
<tr>
<td>  time, utime </td>
<td> Message's time (seconds, microseconds) </td>
<td> Time of the separate message.
</td></tr>
<tr>
<td>  cat </td>
<td> Message's category </td>
<td> Category of the separate message.
</td></tr>
<tr>
<td>  lev </td>
<td> Message's level </td>
<td> Level of the separate message.
</td></tr></table>
<h3><span class="mw-headline" id="Access_to_archived_data_of_the_values.27_archive"><span class="mw-headline-number">18.3</span> Access to archived data of the values' archive</span></h3>
<p>To request the archive data in the archiving subsystem of the values archive's object and parameter's attribute object of "Data acquisition" subsystem the following command is provided <b>&lt;info path="{a_p_addr}/%2fserv%2fval"/&gt;</b> и <b>&lt;get path="{a_p_addr}/%2fserv%2fval"/&gt;</b> to request the information about the archive's and archive values respectively. Attributes of these commands, involving various mechanisms of the request are presented in Table 25.
</p><p><b>Table 25.</b> Attributes of the request commands of information about the archive of archive data
</p>
<table class="wikitable">

<tr>
<th> Id </th>
<th> Name </th>
<th> Value
</th></tr>
<tr>
<td> <i>Request command of the information about the archive:</i> <b>&lt;info path="{a_p_addr}/%2fserv%2fval"/&gt;</b> </td>
<td> </td>
<td>
</td></tr>
<tr>
<td> arch </td>
<td> Setting the name of the archive's archiver </td>
<td> Archive's archiver, for which to specify the parameters.
</td></tr>
<tr>
<td> end </td>
<td> Control of the archive's top in the given archiver </td>
<td> As a result of the request points to the real top of the values' archive in the given archiver &lt;arch&gt;. In the case of the archive's absence the attribute is set to "0".
</td></tr>
<tr>
<td> beg </td>
<td> Control of the archive's depth in the given archiver </td>
<td> As a result of the request points to the real depth of the values' archive in the given archiver &lt;arch&gt;. In the case of the archive's absence the attribute is set to "0".
</td></tr>
<tr>
<td> per </td>
<td> Control of the archive's periodicity in the given archiver </td>
<td> As a result of the request points to the real periodicity of the values' archive in the given archiver &lt;arch&gt;. In the case of the archive's absence the attribute is set to "0".
</td></tr>
<tr>
<td> vtp </td>
<td> Control of the archive's/parameter's type of value </td>
<td> Returns the code of the type of the archive data values: 0 — Boolean, 1 — Integer, 4 — Real, 5 — String. But this property is only available in the case of request at the parameter without archive!
</td></tr>
<tr>
<td> <i>Request command of archive or/and current data</i> <b>&lt;get path="{a_p_addr}/%2fserv%2fval"/&gt;</b> </td>
<td> </td>
<td>
</td></tr>
<tr>
<td> tm </td>
<td> Setting and control of time </td>
<td> Time of the requested value or top of the archive values' block. If the attribute is not specified or equal to "0", the last value is returned. The value of this attribute is set to the value of time of obtained value or of the top of the archival data block.
</td></tr>
<tr>
<td> tm_grnd </td>
<td> Setting and control of the foundation/beginning time of the archive </td>
<td> Points to the  foundation/beginning of the archive. If the attribute is not specified or equal to "0", then the request of one value is made. The value of this attribute is set to the foundation of the block of archival data time.
</td></tr>
<tr>
<td> per </td>
<td> Setting and control of the periodicity of the obtained values  </td>
<td> Periodicity of requested values. If the attribute is not specified or equal to "0" or less than the real periodicity of the archive, then the values will be returned with the real periodicity of the archive and the value of this attribute will be set to the real periodicity value. If the attribute's value is more than the actual periodicity, the values of the archive will be averaged to the specified periodicity.
</td></tr>
<tr>
<td> arch </td>
<td> Setting and control of the archive's archiver </td>
<td> Specifies at what archiver to request the values. If the archiver is not specified, the request will be made consistent with the priority from best to worst. The name of the archiver, from whom the values are obtained, will be indicated in this attribute when returning the result. If the archiver for this parameter is not set, or such archiver is not present, then the value of this attribute will be reset. In the case of the request, crossing several archivers, the processing occurs only for the first archiver with the specification of its name and dimension in the relevant attributes. To request the data of follow-up archivers the request is repeated starting from the dimension of the previous request.
</td></tr>
<tr>
<td> mode </td>
<td> Setting and control of the mode of transfer of the archive data  </td>
<td> The form in which it is desirable to obtain the archive data is specified. The following modes/forms of transfer of archives' data are provided:
<dl><dd><i>0</i> — Simple record: single value — one string without packaging of the related values. In the case of string archive the values are encoded to exclude the newlines characters. Example of the writing form:</dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
34.5678
23.6543
65.8754
34.6523</pre>
<dl><dd><i>1</i> — Packed record on the principle of folding the related values: one value — one record. Before each value it is indicated its position number, separated by the space:</dd></dl>
<pre style="white-space: pre-wrap; margin-left: 30px">
0 34.5678
1 23.6543
4 65.8754
6 34.6523</pre>
<dl><dd><i>2</i> — The array of unpackaged binary values encoded by Mime Base64. Can not be used for string archives.</dd></dl>
</td></tr>
<tr>
<td> real_prec </td>
<td> Setting the precision of the real values </td>
<td> Specifies the precision with which to transmit the data of real values in the "0" and "1" mode. By default, this precision is 6 digits.
</td></tr>
<tr>
<td> round_perc </td>
<td> Setting the rounding percent </td>
<td> Indicates the rounding percentage of related numeric values for the mode of "1".
</td></tr>
<tr>
<td> <i>Request name for archived parameter or same archive:</i> <b>&lt;name path="{a_p_addr}/%2fserv%2fval"/&gt;</b> </td>
<td> </td>
<td>
</td></tr></table>
<h2><span class="mw-headline" id="API_of_modules_of_the_modular_subsystems"><span class="mw-headline-number">19</span> <span id="ModAPI" title="#ModAPI">API of modules of the modular subsystems</span></span></h2>
<p>Modules in OpenSCADA are implemented as shared libraries. As it was previously mentioned, one such library can contain many modules of OpenSCADA subsystems, actually acting as a container.
</p><p>The first step in connecting the shared (SO — shared object) libraries is the connection of the initialization functions. These functions should be defined as usual "C" functions to avoid distortion of function names. Usually this is done as follows:
</p>
<pre style="white-space: pre-wrap;">
//================== CUT =========================
extern "C"
{
#ifdef MOD_INCL
    //Need for define only at case builtin to OpenSCADA core support by the module
    TModule::SAt bd_DBF_module( int n_mod )
#else
    TModule::SAt module( int n_mod )
#endif
    {
	//Allowed into the shared object the modules descriptors forming
    }

#ifdef MOD_INCL
    //Need for define only at case builtin to OpenSCADA core support by the module
    TModule *bd_Tmpl_attach( const TModule::SAt &amp;AtMod, const string &amp;source )
#else
    TModule *attach( const TModule::SAt &amp;AtMod, const string &amp;source )
#endif
    {
	//Selected module connect
    }
}
//================== CUT =========================
</pre>
<p><b>Functions for the working with shared library:</b><br />
<i>TModule::SAt module( int n_mod );</i>
</p>
<dl><dd>The function is provided to sequentially poll the information about modules which are contained in the SO library. <i>n_mod</i> parameter indicates the serial number of the requested module and must be looked over, starting from zero. In the case of absence of the module with the given identifier the function must return the structure with the module name of zero length, that is the end of the scanning process. </dd></dl>
<p><i>TModule *attach( const TModule::SAt &amp;AtMod, const string &amp;source );</i>
</p>
<dl><dd>Connection to the specified module.</dd></dl>
<p>Actually all functions and data of the system are summarized in the API-systems described in this document. However, to simplify and accelerate the process of writing the modules the main function, redefined in modules, are listed in Table 22.
</p><p><b>Table 22.</b> The main functions used when creating the modules
</p>
<table class="wikitable">

<tr>
<th> Common API
</th></tr>
<tr>
<td><b>Objects API (TCntrNode):</b>
<ul><li> <i>virtual void load_( );</i> — Object loading from storage.</li>
<li> <i>virtual void save_( );</i> — Object saving into storage.</li></ul>
</td></tr>
<tr>
<td><b>Common modules API (TModule):</b><br />
<p><i>Attributes:</i>
</p>
<ul><li> <i>string mId;</i> — Module's ID.</li>
<li> <i>string mName;</i> — Module's name.</li>
<li> <i>string mDescr;</i> — Module's description.</li>
<li> <i>string mType;</i> — Module's type.</li>
<li> <i>string mVers;</i> — Module's version.</li>
<li> <i>string mAutor;</i> — Module's author.</li>
<li> <i>string mLicense;</i> — Module's license.</li>
<li> <i>string mSource;</i> — Module's source/origin.</li></ul>
<p><i>Methods:</i>
</p>
<ul><li> <i>virtual void modStart( );</i> — Module's start.</li>
<li> <i>virtual void modStop( );</i> — Module's stop.</li>
<li> <i>virtual void modInfo( vector&lt;string&gt; &amp;list );</i> — The list of available elements of information about the module. There are the following information elements: </li></ul>
<dl><dd>Module — module's ID;</dd>
<dd>Name — localized module's name;</dd>
<dd>Type — module's type;</dd>
<dd>Source — module's source (container);</dd>
<dd>Version — module's version;</dd>
<dd>Author — module's author;</dd>
<dd>Description — module's description;</dd>
<dd>License — module's license.</dd></dl>
<ul><li> <i>virtual string modInfo( const string &amp;name );</i> — Request of the specified information element.</li>
<li> <i>virtual void perSYSCall( unsigned int cnt );</i> — Сall from system thread, with period 10 seconds and seconds counter <i>cnt</i>.</li>
<li> <i>void postEnable( int flag );</i> — Connecting the module to the dynamic tree of objects.</li>
<li> <i>void modFuncReg( ExpFunc *func );</i> — Registration of the exported function.</li></ul>
</td></tr>
<tr>
<th> API of the modules of the "DB" subsystem
</th></tr>
<tr>
<td><b>DB type (child from TTypeBD):</b>
<ul><li> <i>virtual TBD *openBD( const string &amp;id );</i> — Open/create DB.</li></ul>
</td></tr>
<tr>
<td><b>DB (child from TBD):</b>
<ul><li> <i>virtual void enable( );</i> — DB enable.</li>
<li> <i>virtual void disable( );</i> — DB disable.</li>
<li> <i>virtual void allowList( vector&lt;string&gt; &amp;list ) const;</i> — Tables' list in the DB.</li>
<li> <i>virtual void sqlReq( const string &amp;req, vector&lt; vector&lt;string&gt; &gt; *tbl = NULL, char intoTrans = EVAL_BOOL );</i> — Sending the SQL-request <i>req</i> to the DB and receiving the result in tabular form <i>tbl</i>. If set <i>intoTrans</i> to true then will open transaction for the request, else if set to false then transaction will close.</li>
<li> <i>virtual void transCloseCheck( );</i> — The function call periodic for opened transaction check to close for old transaction or overloaded.</li>
<li> <i>virtual TTable *openTable( const string &amp;table, bool create );</i> — Open/create the table.</li></ul>
</td></tr>
<tr>
<td><b>Table (child from TTable):</b>
<ul><li> <i>virtual void fieldStruct( TConfig &amp;cfg );</i> — Getting the table's structure.</li>
<li> <i>virtual bool fieldSeek( int row, TConfig &amp;cfg );</i> — Sequential scan of the table fields.</li>
<li> <i>virtual void fieldGet( TConfig &amp;cfg );</i> — Getting the specified field.</li>
<li> <i>virtual void fieldSet( TConfig &amp;cfg );</i> — Setting the specified field.</li>
<li> <i>virtual void fieldDel( TConfig &amp;cfg );</i> — Deleting the specified field.</li></ul>
</td></tr>
<tr>
<th> API of the modules of subsystem "Transports"
</th></tr>
<tr>
<td><b>Transport's type (child from TTypeTransport):</b>
<ul><li> <i>virtual TTransportIn  *In( const string &amp;name, const string &amp;db );</i> — Create/open new "input" transport.</li>
<li> <i>virtual TTransportOut *Out( const string &amp;name, const string &amp;db );</i> — Create/open new "output" transport.</li></ul>
</td></tr>
<tr>
<td><b>Input transport (child from TTransportIn):</b>
<ul><li> <i>virtual string getStatus( );</i> — Interface status.</li>
<li> <i>virtual void setAddr( const string &amp;addr );</i> — The transport address set. It would be redefined for processing and checking for specific to the module transport's address format.</li>
<li> <i>virtual void start();</i> — Transport's start.</li>
<li> <i>virtual void stop();</i> — Transport's stop.</li></ul>
</td></tr>
<tr>
<td><b>Output transport (child from TTransportOut):</b>
<ul><li> <i>virtual string getStatus( );</i> — Interface status.</li>
<li> <i>virtual void setAddr( const string &amp;addr );</i> — The transport address set. It would be redefined for processing and checking for specific to the module transport's address format.</li>
<li> <i>virtual void start( );</i> — Transport's start.</li>
<li> <i>virtual void stop( );</i> — Transport's stop.</li>
<li> <i>virtual int messIO( const char *obuf, int len_ob, char *ibuf = NULL, int len_ib = 0, int time = 0 );</i> — Sending data via the transport. Timeout <i>time</i> of the connection is indicated in milliseconds. </li></ul>
</td></tr>
<tr>
<th> API of the modules of subsystem "Protocols"
</th></tr>
<tr>
<td><b>Protocol (child from TProtocol):</b>
<ul><li> <i>virtual void itemListIn( vector&lt;string&gt; &amp;ls, const string &amp;curIt = "" );</i> — The input protocol subelements list, at case the protocol allow. Used for select in object of input transport configuration.</li>
<li> <i>virtual void outMess( XMLNode &amp;io, TTransportOut &amp;tro );</i> — Data transfer in the XML tree <i>in</i> to the remote system by means of transport <i>tro</i> and the current output protocol.</li>
<li> <i>virtual TProtocolIn *in_open( const string &amp;name )</i> — Open/create the input protocol.</li></ul>
</td></tr>
<tr>
<td><b>Input protocol (child from TProtocolIn):</b>
<ul><li> <i>virtual bool mess( const string &amp;request, string &amp;answer, const string &amp;sender );</i> — Transfer of unstructured message to the protocol.</li></ul>
</td></tr>
<tr>
<th> API  of the modules of "Data acquisition" subsystem
</th></tr>
<tr>
<td><b>Controller's type (child from TTypeDAQ):</b>
<ul><li> <i>virtual void compileFuncLangs( vector&lt;string&gt; &amp;ls );</i> — The list of user programming languages that are supported by the module.</li>
<li> <i>virtual void compileFuncSnthHgl( const string &amp;lang, XMLNode &amp;shgl );</i> — Syntax highlight rules <i>shgl</i> request for user programming language <i>lang</i>.</li>
<li> <i>virtual string compileFunc( const string &amp;lang, TFunction &amp;fnc_cfg, const string &amp;prog_text );</i> — Compilation of the user procedure and creation of the object of function's execution for the specified language of user programming.</li>
<li> <i>virtual bool redntAllow( );</i> — The sign of support of the redundancy mechanisms by the module. Should by simply redefined and return true.</li>
<li> <i>virtual TController *ContrAttach( const string &amp;name, const string &amp;daq_db );</i> — Opening/connection of the controller.</li></ul>
</td></tr>
<tr>
<td><b>Controller (child from TController):</b>
<ul><li> <i>virtual string getStatus( );</i> — Call for specific controller status get.</li>
<li> <i>virtual void enable_( );</i> — Controller enable.</li>
<li> <i>virtual void disable_( );</i> — Controller disable.</li>
<li> <i>virtual void start_( );</i> — Controller's start.</li>
<li> <i>virtual void stop_( );</i> — Controller's stop.</li>
<li> <i>virtual void redntDataUpdate( bool firstArchiveSync = false );</i> — An operation of the data receiving from the redundant station execution. It is called automatically by the service task of the redundancy scheme and before starting to synchronize the archives with the parameter <i>firstArchiveSync</i> set.</li>
<li> <i>virtual TParamContr *ParamAttach( const string &amp;name, int type );</i> — Creation/opening of the new parameter.</li></ul>
</td></tr>
<tr>
<td><b>Controller's parameter (child from TParamContr-&gt;TValue):</b>
<ul><li> <i>virtual void enable( );</i> — Enable parameter.</li>
<li> <i>virtual void disable( );</i> — Disable parameter.</li>
<li> <i>virtual void setType( const string &amp;tpId );</i> — Is called to change the parameter type <i>tpId</i> and can be processed in the object module for self data change.</li>
<li> <i>virtual TVal* vlNew( );</i> — Call at new attribute creation. Would be redefined for specific behavior into self, inherited from <i>TVal</i>, class at accessing to attribute.</li>
<li> <i>virtual void vlSet( TVal &amp;val, const TVariant &amp;pvl );</i> — Call for attribute into direct write mode <i>TVal::DirWrite</i> (synchronous mode or writing to internal object's buffer) at a value set, for direct writing to physical controller or object's buffer.</li>
<li> <i>virtual void vlGet( TVal &amp;val );</i> — Call for attribute into direct read mode <i>TVal::DirRead</i> (synchronous mode or reading from internal object's buffer) at a value get, for direct reading from physical controller or object's buffer.</li>
<li> <i>virtual void vlArchMake( TVal &amp;val );</i> — Call at a value archive creation with attribute <i>val</i> as the source for quality properties initialization to archive's buffer according with specific of data source and its acquisition.</li></ul>
</td></tr>
<tr>
<th> API of the modules of the "Archives" subsystem
</th></tr>
<tr>
<td><b>Archiver's type (child from TTypeArchivator):</b>
<ul><li> <i>virtual TMArchivator *AMess(const string &amp;id, const string &amp;db );</i> — Creation of the messages' archive.</li>
<li> <i>virtual TVArchivator *AVal(const string &amp;id, const string &amp;db );</i> — Creation of the messages' archiver.</li></ul>
</td></tr>
<tr>
<td><b>Messages' archiver (child from TMArchivator):</b>
<ul><li> <i>virtual void start( );</i> — Archiver's start.</li>
<li> <i>virtual void stop( );</i> — Archiver's stop.</li>
<li> <i>virtual time_t begin( );</i> — The beginning of the data in the archive.</li>
<li> <i>virtual time_t end( );</i> — The end of the data in the archive.</li>
<li> <i>virtual void put( vector&lt;TMess::SRec&gt; &amp;mess );</i> — Put the message to the archiver.</li>
<li> <i>virtual void get( time_t b_tm, time_t e_tm, vector&lt;TMess::SRec&gt; &amp;mess, const string &amp;category = "", char level = 0, time_t upTo = 0 );</i> — Get the message from the archiver.</li></ul>
</td></tr>
<tr>
<td><b>Values' archiver (child from TVArchivator):</b>
<ul><li> <i>virtual void setValPeriod( double per );</i> — Set the periodicity of the archiver's values.</li>
<li> <i>virtual void setArchPeriod( int per );</i> — Set the archiving periodicity.</li>
<li> <i>virtual void start( );</i> — Start the archiver.</li>
<li> <i>virtual void stop( bool full_del = false );</i> — Stop the archiver with the possibility of complete deleting if the <i>full_del</i> flag is set.</li>
<li> <i>virtual TVArchEl *getArchEl( TVArchive &amp;arch );</i> — Getting the <i>arch</i> archive, which is served by the archiver.</li></ul>
</td></tr>
<tr>
<td><b>An archive element of values (child from TVArchEl):</b>
<ul><li> <i>virtual void fullErase( );</i> — Complete deleting of the part of archive in the archiver.</li>
<li> <i>virtual int64_t end( );</i> — End time of the archive in the archiver.</li>
<li> <i>virtual int64_t begin( );</i> — Start time of the archive in the archiver.</li>
<li> <i>virtual TVariant getValProc( int64_t *tm, bool up_ord );</i> — Request processing function of the single value from the archive.</li>
<li> <i>virtual void getValsProc( TValBuf &amp;buf, int64_t beg, int64_t end );</i> — Function of the request processing by the module to get data group values <i>buf</i> for set time interval.</li>
<li> <i>virtual void setValsProc( TValBuf &amp;buf, int64_t beg, int64_t end );</i> — Function of the request processing by the module to set data values <i>buf</i> for set time interval.</li></ul>
</td></tr>
<tr>
<th> API of the modules of subsystem "User interfaces"
</th></tr>
<tr>
<td><b>User interface (child from TUI):</b><br />
<p>It does not contain specific functions!
</p>
</td></tr>
<tr>
<th> API модулей подсистемы "Специальные"
</th></tr>
<tr>
<td><b>Specials (child from TSpecial):</b><br />
<p>It does not contain specific functions!
</p>
</td></tr></table>
<h2><span class="mw-headline" id="Debugging_and_Testing_OpenSCADA"><span class="mw-headline-number">20</span> Debugging and Testing OpenSCADA</span></h2>
<p>To monitor the quality of code and test the performance of various parts of the system the special modules are written that perform testing with the issue of testing protocol. These modules must be executed after the completion of any part of the project.
</p>
<h2><span class="mw-headline" id="Rules_for_design_and_commenting_of_the_sources_of_OpenSCADA_and_its_modules"><span class="mw-headline-number">21</span> Rules for design and commenting of the sources of OpenSCADA and its modules</span></h2>
<p>When writing and design of the sources of OpenSCADA and its modules you must to follow the rules:
</p>
<ul><li> indent between the levels of enclosure: 4 characters;</li>
<li> tabulation space: 8 symbols;</li>
<li> braces of opening placed in previous command place, if the shorter for 80 symbols;</li>
<li> braces of closing must be placed in separate lines at the level of the previous text;</li>
<li> it is possible to write an enclosure in the single line with the previous level of enclosure, in case of increasing the readability of the code;</li>
<li> distance between the descriptions of the functions of at least one character;</li>
<li> the distance between the definition of variables and the text of the program at least one symbol;</li>
<li> it is possible to define variables in the text while saving the readability;</li>
<li> to avoid long lines more than 100 characters;</li>
<li> preprocessor commands must be located on the first level, regardless of the current level of the text;</li>
<li> for the formatting the source code, inherited from the other free applications and examples, it is recommended to use the utility:</li></ul>
<dl><dd><i>indent -bli0 -i4 -ts8 -l100 -npsl -npcs -nprs -nsaf -nsai -nsaw -brs -br -cdw -nbc -lp &lt;filename&gt;</i>.</dd></dl>
<p>Commenting rules of OpenSCADA:
</p>
<ul><li> obligatory commenting and thorough description is necessary for class declarations;</li>
<li> declarations of public methods of the class should be thoroughly described with the individual description of each parameter;</li>
<li> declarations of public attributes should also be thoroughly commented;</li>
<li> text functions do not need to be thoroughly commented, but the implicit places are to be commented.</li></ul>
<h2><span class="mw-headline" id="Conventional_signs_in_the_text_and_source_code"><span class="mw-headline-number">22</span> Conventional signs in the text and source code</span></h2>
<p><b>????[{TAGS}]</b> — must be implemented shortly or according to the schedule in <i>TAGS</i>:
</p>
<ul><li> <i>API</i> — at the API significant changing in the stable;</li>
<li> <i>v1.0</i> — at some specified release.</li></ul>
<p><b>?!?!</b> — section is not completely implemented and can be implemented not at the schedule but an occasion;<br />
<b>!!!!</b> — section requires rethinking and explains-clears-warns such sort of implementing-commenting.
</p>
<h2><span class="mw-headline" id="Links"><span class="mw-headline-number">23</span> Links</span></h2>
<ul><li> <a class="external" href="http://oscada.org/wiki/File:API_uml_classdep.odg" title="File:API uml classdep.odg">Diagram: Static class diagram.</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:Oscada_struct.odg" title="File:Oscada struct.odg">Diagram: Block scheme of OpenSCADA.</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:Oscada_subsys_daq_str.odg" title="File:Oscada subsys daq str.odg">Diagram: Hierarchical structure of the subsystem "DAQ".</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:Oscada_subsys_db_str.odg" title="File:Oscada subsys db str.odg">Diagram: Hierarchical structure of the subsystem "DB".</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:Oscada_subsys_arch_str.odg" title="File:Oscada subsys arch str.odg">Diagram: Hierarchical structure of the subsystem "Archives".</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:Oscada_subsys_tr_str.odg" title="File:Oscada subsys tr str.odg">Diagram: Hierarchical structure of the subsystem "Transports" and "Protocols".</a></li>
<li> <a class="external" href="http://oscada.org/wiki/File:Oscada_UserOM.odg" title="File:Oscada UserOM.odg">Diagram: User object model of the core OpenSCADA.</a></li></ul>






</div><table style="border-top: dotted 2px #999999; margin-top: 20pt; color: gray;" width="100%"><tr><td style="text-align: left;" width="40%"><a href="http://oscada.org/wiki/Documents/API/en">Documents/API/en</a> - <a href="http://oscada.org/en/main/about-the-project/licenses/">GFDL</a></td><td style="text-align: center;">June 2022</td><td style="text-align: right;" width="40%">OpenSCADA 1+r2832</td></tr></table></body>
</html>